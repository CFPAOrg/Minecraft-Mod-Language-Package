{
  "block.hexal.slipway": "Slipway",
  "block.hexal.mediafied_storage": "Mote Nexus",
  "block.hexal.relay": "Relay",

  "entity.hexal.wisp.projectile": "Projectile Wisp",
  "entity.hexal.wisp.ticking": "Cyclic Wisp",
  "entity.hexal.wisp.wandering": "Wandering Wisp",


  "hexcasting.mishap.non_player": "%s expected to be cast by a player.",
  "hexcasting.mishap.no_wisp": "%s expected to be cast by a wisp.",
  "hexcasting.mishap.others_wisp": "That wisp is owned by %s, not you.",
  "hexcasting.mishap.no_links": "%s has no links.",
  "hexcasting.mishap.self_link": "Tried to link %s to itself.",
  "hexcasting.mishap.no_bound_storage": "No bound Mote Nexus.",
  "hexcasting.mishap.storage_unloaded": "Bound Mote Nexus is unloaded.",
  "hexcasting.mishap.excessive_reproduction": "Wisp %s tried to reproduce excessively; only 1 child per tick.",

  "hexcasting.mishap.invalid_value.class.linkable": "a linkable",
  "hexcasting.mishap.invalid_value.class.wisp": "a wisp",
  "hexcasting.mishap.invalid_value.class.consumable_entity": "a consumable entity",
  "hexcasting.mishap.invalid_value.class.wisp.casting": "a casting wisp",
  "hexcasting.mishap.invalid_value.class.type.block": "a block type",
  "hexcasting.mishap.invalid_value.class.type.item": "an item type",
  "hexcasting.mishap.invalid_value.class.type.entity": "an entity or entity type",
  "hexcasting.mishap.invalid_value.class.type.block.able": "an item type that has a block",
  "hexcasting.mishap.invalid_value.class.type.list.double": "a list of numbers",
  "hexcasting.mishap.invalid_value.class.gate": "a gate",
  "hexcasting.mishap.invalid_value.class.mote": "a mote",
  "hexcasting.mishap.invalid_value.class.moteentity.itemitemframe": "a mote, item entity, or item frame",
  "hexcasting.mishap.invalid_value.moteitemtype": "a mote or item type",
  "hexcasting.mishap.invalid_value.motemotelist": "a mote or list of motes",
  "hexcasting.mishap.invalid_value.motemotelistmotelistlist": "a mote, list of motes, or list of lists of motes",
  "hexcasting.mishap.invalid_value.veclist": "a vector or a list of vectors",
  "hexcasting.mishap.invalid_value.blockitementityitemframeitem": "a block, item entity, item frame, or mote",
  "hexcasting.mishap.invalid_value.entity.itemitemframe": "an item entity or item frame",
  "hexcasting.mishap.invalid_value.int.strictly_positive": "a strictly positive integer",
  "hexcasting.mishap.invalid_value.crafting_recipe": "a valid crafting recipe",
  "hexcasting.mishap.invalid_value.mote_duplicated": "each mote to appear only once",
  "hexcasting.mishap.invalid_value.cant_combine_motes": "two motes that can be combined",
  "hexcasting.mishap.invalid_value.mote_not_size_one": "a mote with no NBT data or of size one",
  "hexcasting.mishap.invalid_value.gate.offset": "an offset of at most %f blocks",


  "hexcasting.iota.hexal:iota_type": "Iota Type",
  "hexcasting.iota.hexal:entity_type": "Entity Type",
  "hexcasting.iota.hexal:item_type": "Item Type",
  "hexcasting.iota.hexal:gate": "Gate",
  "hexcasting.iota.hexal:item": "Item",

  "hexal.spelldata.entity_type": "Type",
  "hexal.spelldata.gate": "Gate %d",
  "hexal.spelldata.mote": "%s x%d",

  "hexcasting.spell.hexal:type/iota": "Classifier's Purification",
  "hexcasting.spell.hexal:type/entity": "Physician's Purification",
  "hexcasting.spell.hexal:type/block_item": "Sorter's Purification",
  "hexcasting.spell.hexal:type/item_held": "Sorter's Reflection",

  "hexcasting.spell.hexal:raycast/entity/type": "Scout's Exaltation",
  "hexcasting.spell.hexal:get_entity/type": "Entity Distillation: Type",
  "hexcasting.spell.hexal:zone_entity/type": "Zone Exaltation: Type",
  "hexcasting.spell.hexal:zone_entity/not_type": "Zone Exaltation: Not-Type",

  "hexcasting.spell.hexal:current_tick": "Timekeeper's Reflection",
  "hexcasting.spell.hexal:remaining_evals": "Thanatos' Reflection",
  "hexcasting.spell.hexal:breath": "Diver's Purification",
  "hexcasting.spell.hexal:health": "Nurse's Purification",
  "hexcasting.spell.hexal:armour": "Squire's Purification",
  "hexcasting.spell.hexal:toughness": "Boxer's Purification",
  "hexcasting.spell.hexal:light_level": "Lamplighter's Purification",

  "hexcasting.spell.hexal:factorial": "Factorial Purification",
  "hexcasting.spell.hexal:running/sum": "Running Sum Purification",
  "hexcasting.spell.hexal:running/mul": "Running Product Purification",

  "hexcasting.spell.hexal:everbook/read": "Mnemosyne's Gambit",
  "hexcasting.spell.hexal:everbook/write": "Elysium's Gambit",
  "hexcasting.spell.hexal:everbook/delete": "Lethe's Gambit",
  "hexcasting.spell.hexal:everbook/toggle_macro": "Brigh's Gambit",

  "hexcasting.spell.hexal:smelt": "Smelt",
  "hexcasting.spell.hexal:freeze": "Freeze",
  "hexcasting.spell.hexal:falling_block": "Falling Block",
  "hexcasting.spell.hexal:place_type": "Place Block II",
  "hexcasting.spell.hexal:particles": "Particles",

  "hexcasting.spell.hexal:interop/fabric_only/phase_block": "Phase Block",

  "hexcasting.spell.hexal:wisp/summon/projectile": "Summon Projectile Wisp",
  "hexcasting.spell.hexal:wisp/summon/ticking": "Summon Cyclic Wisp",
  "hexcasting.spell.hexal:wisp/self": "Identity Reflection",
  "hexcasting.spell.hexal:wisp/media": "Reservoir Reflection",
  "hexcasting.spell.hexal:wisp/hex": "Manager's Purification",
  "hexcasting.spell.hexal:wisp/owner": "Allegiance Distillation",
  "hexcasting.spell.hexal:wisp/move/target/set": "Pathfinder's Gambit",
  "hexcasting.spell.hexal:wisp/move/target/get": "Pathfinder's Reflection",
  "hexcasting.spell.hexal:wisp/move/speed/set": "Haste",
  "hexcasting.spell.hexal:wisp/move/speed/get": "Speedometer's Reflection",
  "hexcasting.spell.hexal:wisp/trigger/tick": "Delay Wisp",
  "hexcasting.spell.hexal:wisp/trigger/comm": "Listen",
  "hexcasting.spell.hexal:wisp/trigger/move": "Wander",
  "hexcasting.spell.hexal:wisp/consume": "Consume Wisp",
  "hexcasting.spell.hexal:wisp/seon/set": "Bind Wisp",
  "hexcasting.spell.hexal:wisp/seon/get": "Familiar's Reflection",
  "hexcasting.spell.hexal:wisp/transfer/allow": "Allow Transfer",
  "hexcasting.spell.hexal:wisp/transfer/disallow": "Disallow Transfer",
  "hexcasting.spell.hexal:wisp/transfer/others/allow": "Allow Transfer Others",
  "hexcasting.spell.hexal:wisp/transfer/others/disallow": "Disallow Transfer Others",

  "hexcasting.spell.hexal:get_entity/wisp": "Entity Purification: Wisp",
  "hexcasting.spell.hexal:zone_entity/wisp": "Zone Distillation: Wisp",
  "hexcasting.spell.hexal:zone_entity/not_wisp": "Zone Distillation: Non-Wisp",

  "hexcasting.spell.hexal:link": "Link",
  "hexcasting.spell.hexal:link/others": "Link Others",
  "hexcasting.spell.hexal:link/unlink": "Unlink",
  "hexcasting.spell.hexal:link/unlink/others": "Unlink Others",
  "hexcasting.spell.hexal:link/get": "Phonebook Purification",
  "hexcasting.spell.hexal:link/get_index": "Recognition Purification",
  "hexcasting.spell.hexal:link/num": "Popularity Reflection",

  "hexcasting.spell.hexal:link/comm/send": "Send Iota",
  "hexcasting.spell.hexal:link/comm/read": "Recitation Reflection",
  "hexcasting.spell.hexal:link/comm/num": "Postmaster's Reflection",
  "hexcasting.spell.hexal:link/comm/clear": "Unclogging Gambit",
  "hexcasting.spell.hexal:link/comm/open_transmit": "Open Transmit",
  "hexcasting.spell.hexal:link/comm/close_transmit": "Close Transmit",

  "hexcasting.spell.hexal:gate/make": "Gate's Reflection",
  "hexcasting.spell.hexal:gate/mark": "Gate's Opening",
  "hexcasting.spell.hexal:gate/unmark": "Gate's Dismissal",
  "hexcasting.spell.hexal:gate/mark/num/get": "Marked Purification",
  "hexcasting.spell.hexal:gate/mark/get": "Marked Distillation",
  "hexcasting.spell.hexal:gate/close": "Gate's Closing",

  "hexcasting.spell.hexal:mote/storage/bind": "Bind Storage",
  "hexcasting.spell.hexal:mote/storage/bind/temp": "Bind Storage - Temporary",
  "hexcasting.spell.hexal:mote/contained_type/get": "Stocktake Reflection",
  "hexcasting.spell.hexal:mote/contained/get": "Stocktake Purification",
  "hexcasting.spell.hexal:mote/storage/remaining_capacity/get": "Capacity Reflection",
  "hexcasting.spell.hexal:mote/storage/contains": "Containment Distillation",
  "hexcasting.spell.hexal:mote/make": "Mediafy Item",
  "hexcasting.spell.hexal:mote/return": "Return Item",
  "hexcasting.spell.hexal:mote/count/get": "Weighing Purification",
  "hexcasting.spell.hexal:mote/combine": "Stacking Distillation",
  "hexcasting.spell.hexal:mote/combinable": "Stacking Distillation II",
  "hexcasting.spell.hexal:mote/split": "Splitting Gambit",
  "hexcasting.spell.hexal:mote/storage/get": "Depot Purification",
  "hexcasting.spell.hexal:mote/storage/set": "Depot Gambit",
  "hexcasting.spell.hexal:mote/craft": "Craft",
  "hexcasting.spell.hexal:mote/villager/level/get": "Seniority Purification",
  "hexcasting.spell.hexal:mote/trade/get": "Offering Purification",
  "hexcasting.spell.hexal:mote/trade": "Trade",
  "hexcasting.spell.hexal:mote/use_on": "Use Item On",

  "hexcasting.spell.hexal:tick": "Accelerate",



  "hexcasting.spell.book.hexal:light_level": "Lamplighter's Prfn.",

  "hexcasting.spell.book.hexal:running/sum": "Running Sum Prfn.",
  "hexcasting.spell.book.hexal:running/mul": "Running Product Prfn.",

  "hexcasting.spell.book.hexal:get_entity/wisp": "Entity Prfn.: Wisp",
  "hexcasting.spell.book.hexal:zone_entity/wisp": "Zone Dstl.: Wisp",
  "hexcasting.spell.book.hexal:zone_entity/not_wisp": "Zone Dstl.: Non-Wisp",

  "hexcasting.spell.book.hexal:mote/storage/bind/temp": "Bind Storage - Temp.",



  "hexal.entry.slipways": "Slipways",
  "hexal.page.slipways": "I have heard tales of some geodes in which glowing portals called slipways lie. These slipways are regularly depicted with glowing sparks surrounding them that bear an incredible resemblance to the $(l:hexal:patterns/spells/wisps)$(thing)wisps/$ that I have heard tell of, which may be a connection to look into.",

  "hexal.entry.relay": "Relay",
  "hexal.page.relay.0": "Often I wish to $(l:hexal:patterns/spells/links#hexal:link)$(action)link/$ together multiple $(l:hexal:patterns/spells/wisps)$(thing)wisps/$, so that they can share media and information over long distances. However running long chains of wisps to transfer these over great distances is inconvenient, and has great upkeep costs. To resolve this issue I have made Relays. Since they are solid blocks rather than media constructs themselves, they are able to maintain the links without any upkeep costs at all.",
  "hexal.page.relay.1": "Any relays connected together will form a network, with any wisps connected to a relay network able to share media between each other as if they were directly connected. Further, any iota sent to one relay in the network is passed on to every other non-relay connected to the network. Relays have a range of 32 blocks (this means two relays can connect at a distance of 64 blocks). The colour of a network's links can be changed by right clicking on any relay with a colouriser.",
  "hexal.page.relay.2": "Relays have no owner, so if you want your wisps to $(l:hexal:patterns/spells/wisps#hexal:wisp/transfer/allow)$(action)transfer media/$ with them you must specifically allow them to do so.",

  "hexal.entry.hexal_basics": "Hexal Basic Patterns",
  "hexal.page.hexal_basics.current_tick": "Adds a number to the stack which seems to be related to how Nature represents time; If I cast the pattern, then cast the same pattern a second later, the number it adds has increased by 20.",
  "hexal.page.hexal_basics.remaining_evals": "Adds the number of evaluations a hex is still capable of to the stack. This is reduced by $(l:patterns/meta#hexcasting:eval)$(action)Hermes' Gambit/$ and $(l:patterns/meta#hexcasting:for_each)$(action)Thoth's Gambit/$.",
  "hexal.page.hexal_basics.breath": "Removes a Living entity from the stack and returns how much breath it has left (i.e., how close it is to drowning).",
  "hexal.page.hexal_basics.health": "Removes a Living entity from the stack and returns how much health it has left (i.e., how close it is to dying).",
  "hexal.page.hexal_basics.armour": "Removes a Living entity from the stack and returns how much armour it has.",
  "hexal.page.hexal_basics.toughness": "Removes a Living entity from the stack and returns how much toughness it has (another property of armour).",
  "hexal.page.hexal_basics.light_level": "Removes a position vector from the stack and returns the light level at that position.",

  "hexal.entry.hexal_maths": "Hexal Maths",
  "hexal.page.hexal_maths.factorial": "Takes a number from the stack and computes its factorial, for example inputting 4 would return 4*3*2*1=24.",
  "hexal.page.hexal_maths.running/sum": "Takes a list from the stack and computes its running sum, for example inputting [1,2,5] would return [1,3,8].",
  "hexal.page.hexal_maths.running/mul": "Takes a list from the stack and computes its running product, for example inputting [1,2,5] would return [1,2,10].",

  "hexal.entry.hexal_spell": "Hexal Spells",
  "hexal.page.hexal_spell.smelt.0": "Remove a location, item entity, or mote from the stack, then either smelt the block at the location or smelt all the items in the item entity or mote.",
  "hexal.page.hexal_spell.smelt.1": "Costs three quarters of an $(l:items/amethyst)$(item)Amethyst Dust/$ per item smelted (i.e. three quarters of an $(l:items/amethyst)$(item)Amethyst Dust/$ for smelting a block, 6 $(l:items/amethyst)$(item)Amethyst Dust/$ to smelt a stack of 8 items.)",
  "hexal.page.hexal_spell.freeze": "Freezes the block at a block location. For example, turns water into ice, and ice into packed ice. Costs one $(l:items/amethyst)$(item)Amethyst Dust/$.",
  "hexal.page.hexal_spell.falling_block": "Remove a location from the stack, and force the block there to fall as if it were sand or gravel. Costs one and a half $(l:items/amethyst)$(item)Amethyst Dust/$.",
  "hexal.page.hexal_spell.place_type": "Accepts an item type or mote and a location, and attempts to place a block of that item type at that location. If a mote was passed it will instead place from the record referenced by that mote. Costs an eighth of an $(l:items/amethyst)$(item)Amethyst Dust/$.",
  "hexal.page.hexal_spell.particles": "Accepts a location or a list of locations, and either creates a particle at the location, or creates lines of particles between the locations in the list. Costs two thousandths of an $(l:items/amethyst)$(item)Amethyst Dust/$ per location.",

  "hexal.entry.fabric_only_hexal": "Fabric-Only Hexal Spells",
  "hexal.page.fabric_only_hexal.interop/fabric_only/phase_block": "Takes a position and a number, and phases the block at that position out for that many seconds. Costs one ten-thousandth of an $(l:items/amethyst)$(item)Amethyst Dust/$ times the square of the time to phase out for.",

  "hexal.entry.wisps": "Wisps",
  "hexal.page.wisps.0": "I have discovered a way to create constructs from the media itself, visible to others and able to move and act somewhat on their own. They are able to cast hexes in my place, similar to how a $(l:patterns/meta#hexcasting:eval)$(action)Hermes' Gambit/$ evaluates patterns. They do take some of my attention to operate this however, and if too many try and execute at once I will only be able to run some of them, leaving the rest for the next instant.",
  "hexal.page.wisps.1": "When they are created I assign them a 'reservoir' of media that they have access to, which is taken from me and used to form the wisp. A wisp uses up part of its reservoir simply existing, and when it evaluates the pattern list it is carrying any costs incurred are removed from its reservoir. All wisps seem to take three $(l:items/amethyst)$(item)Amethyst Dust/$ to summon, in addition to whatever media is used for their reservoir.",
  "hexal.page.wisps.2": "Wisps are punished severely for attempting to hold onto another caster's truename, incurring a 20 times increase in the wisp's media upkeep per truename iota in any of the wisp's iota storage mechanisms.",
  "hexal.page.wisps.wisp/summon/projectile.0": "This wisp is summoned and launched like an arrow, casting its hex on whatever it hits. The initial stack when it executes will be a reference to itself, then a reference to what it hit.",
  "hexal.page.wisps.wisp/summon/projectile.1": "This could be a block position or an entity reference. The first vector accepted is the location the wisp will be summoned, while the direction of the second is the direction the wisp will be launched, and the second's magnitude seems to affect the wisp's velocity. The cost of the spell increases with the squared magnitude of velocity. The number accepted determines the wisp's reservoir in $(l:items/amethyst)$(item)Amethyst Dust/$. It loses approximately 3 tenths of an $(l:items/amethyst)$(item)Amethyst Dust/$ of media every second once summoned, and has a range of influence of 4 blocks.",
  "hexal.page.wisps.wisp/summon/ticking.0": "Similar to Summon Projectile Wisp, but with only one vector input for the position to summon the wisp. Cyclic wisps are unmoving once summoned, instead executing their hex up to 20 times each second.",
  "hexal.page.wisps.wisp/summon/ticking.1": "The first time it casts the stack will start with a reference to itself, from which point it will always start with the stack and ravenmind in the state they finished on the last cast. This wisp has a less stable form making it lose significantly more media every second, losing approximately seven tenths of an $(l:items/amethyst)$(item)Amethyst Dust/$ per second once summoned. It has a range of influence of 8 blocks.",
  "hexal.page.wisps.wisp/self": "Add a reference to the casting wisp to the stack. This must be cast by a wisp; trying to cast it through a staff will fail rather spectacularly.",
  "hexal.page.wisps.wisp/media": "Add the amount of media in the wisp's reservoir to the stack. This must be cast by a wisp; trying to cast it through a staff will fail rather spectacularly.",
  "hexal.page.wisps.wisp/hex": "Removes a reference to a wisp from the stack, and replaces it with the wisp's contained hex. Must be a wisp you summoned, or a wisp that has $(l:hexal:patterns/spells/wisps#hexal:wisp/transfer/allow)allowed$(action) transfer with the caster or caster's owner.",
  "hexal.page.wisps.wisp/owner": "Removes a reference to a wisp and an entity from the stack, and returns true if that entity owns that wisp, and false otherwise.",
  "hexal.page.wisps.wisp/move/target/set": "Removes a position vector from the stack; The Cyclic Wisp that executed this pattern will move in a straight line towards that position (colliding with terrain in its path) until it reaches it.",
  "hexal.page.wisps.wisp/move/target/get": "Adds to the stack the position vector that the executing Cyclic Wisp is currently moving towards.",
  "hexal.page.wisps.wisp/move/speed/set": "Removes a number from the stack, and sets the executing Cyclic Wisp's maximum speed to that number.",
  "hexal.page.wisps.wisp/move/speed/get": "Gets the executing Cyclic Wisp's current maximum speed.",
  "hexal.page.wisps.wisp/transfer/allow": "When two wisps are $(l:hexal:patterns/spells/links)$(thing)linked/$ together, they transfer media between each other until they are balanced. By default this only happens between wisps with the same owner. This takes an index, and explicitly allows the wisp to exchange media with the linkable at that index.",
  "hexal.page.wisps.wisp/transfer/disallow": "Correspondingly, this takes an index and disallows the wisp from exchanging media with the linkable at that index.",
  "hexal.page.wisps.wisp/transfer/others/allow": "This takes a wisp that you own and an index, and allows the wisp to exchange media with the linkable at that index.",
  "hexal.page.wisps.wisp/transfer/others/disallow": "This takes a wisp that you own and an index, and disallows the wisp from exchanging media with the linkable at that index.",
  "hexal.page.wisps.get_entity/wisp": "Transform the position on the stack into the wisp at that location (or $(l:casting/influences)$(thing)Null/$ if there isn't one).",
  "hexal.page.wisps.zone_entity/wisp": "Take a position and maximum distance on the stack, and combine them into a list of wisps near the position.",
  "hexal.page.wisps.zone_entity/not_wisp": "Take a position and maximum distance on the stack, and combine them into a list of non-wisp entities near the position.",
  "hexal.page.wisps.wisp/trigger/tick": "Removes an integer from the stack, then delays the wisp's next cast until at least that many twentieth's of a second have passed. This and other triggers like it will halve the wisp's upkeep cost while it isn't casting.",
  "hexal.page.wisps.wisp/trigger/comm": "The wisp's next cast will not occur until it has received at least one $(l:hexal:patterns/spells/links#hexal:link/comm/send)$(action)communication/$.",
  "hexal.page.wisps.wisp/trigger/move": "The wisp's next cast will not occur until it has reached the position it is $(l:hexal:patterns/spells/wisps#hexal:wisp/move/target/set)$(action)navigating/$ towards.",

  "hexal.entry.links": "Links",
  "hexal.page.links.0": "These patterns outline a system that I have found for communicating information from one $(l:hexal:patterns/spells/wisps)$(thing)wisp/$ to another, among other things. There are a number of patterns related to creating these links, and a number of patterns related to sending and receiving iotas over a link once it is created. A wisp can have any number of links active, with each costing a negligible amount of media to maintain each twentieth of a second.",
  "hexal.page.links.1": "The links of a given linkable are indexed by the order they are created, with this number used by a number of patterns. \"Linkable\" is not its own type, but a shorthand for any type that can be coerced into a linkable (e.g. Entity -> Linkable entities, Vec -> Linkable blocks, ...). Links can span up to double the sum of the two linkable's ranges. To connect linkables over truly vast distances I would do well to look into building some $(l:hexal:items/relay)$(item)Relays/$.",
  "hexal.page.links.link": "Links the caster to the entity removed from the stack, which must be linkable. This costs one $(l:items/amethyst)$(item)Amethyst Shard/$.",
  "hexal.page.links.link/others": "May be evaluated by any casting instrument. Links two entities, which must be linkable. This costs one $(l:items/amethyst)$(item)Amethyst Shard/$.",
  "hexal.page.links.link/unlink": "Removes the link at the given index from the caster's links. This costs two $(l:items/amethyst)$(item)Amethyst Dust/$.",
  "hexal.page.links.link/unlink/others": "Takes two linkables and unlinks them if they are linked. This costs two $(l:items/amethyst)$(item)Amethyst Dust/$.",
  "hexal.page.links.link/get": "Removes an index from the stack, and adds the entity connected to the link at that index to the stack.",
  "hexal.page.links.link/get_index": "Removes an entity from the stack, and adds the index to the link to that entity to the stack (or -1 if the caster isn't linked to that entity).",
  "hexal.page.links.link/num": "Adds the number of links to the wisp to the stack.",
  "hexal.page.links.link/comm/send": "Removes an iota from the stack, then removes an index from the stack and sends the iota along the link at the given index.  This costs one hundredth of an $(l:items/amethyst)$(item)Amethyst Dust/$.",
  "hexal.page.links.link/comm/read": "When something receives an iota along a link it is added to a queue. This pattern adds the first iota in the queue to the stack, removing it from the queue.",
  "hexal.page.links.link/comm/num": "Adds to the stack the number of unread iota in the caster's received iota queue.",
  "hexal.page.links.link/comm/clear": "Removes all unread iota from the caster's received iota queue.",
  "hexal.page.links.link/comm/open_transmit": "Similar to $(l:patterns/patterns_as_iotas#hexcasting:open_paren)$(action)Introspection/$, until drawing a $(l:hexal:patterns/spells/links#hexal:link/comm/close_transmit)$(action)Close Transmit/$ all patterns I draw are sent along the link whose index is at the top of the stack.",
  "hexal.page.links.link/comm/close_transmit": "When drawn after $(l:hexal:patterns/spells/links#hexal:link/comm/open_transmit)$(action)Open Transmit/$ I stop transmitting drawn patterns. If either $(l:hexal:patterns/spells/links#hexal:link/comm/open_transmit)$(action)Open Transmit/$ or $(l:hexal:patterns/spells/links#hexal:link/comm/close_transmit)$(action)Close Transmit/$ are executed by an intermediary caster such as a wisp, they will mishap.",

  "hexal.entry.tick": "Accelerate",
  "hexal.page.tick.tick.0": "Causes the block at the passed vector to perform its normal actions faster in the instant that this spell is cast.",
  "hexal.page.tick.tick.1": "Casting it costs a tenth of an $(l:items/amethyst)$(item)Amethyst Dust/$, plus a thousandth of an $(l:items/amethyst)$(item)Amethyst Dust/$ for each time it has previously been cast on that block in this hex.",

  "hexal.entry.gates": "Gates",
  "hexal.page.gates.0": "Gates are the latest in my long line of experimentation with breaking space to connect distant points and allow instantaneous travel. What gates allow me to do, that none of my previous attempts have succeeded at, is to do it $(o)efficiently$(). There are three varieties of gates that I have learned how to construct, all of which take a large amount of media to burn into reality, but are significantly cheaper to operate afterwards.",
  "hexal.page.gates.1": "Location Anchored Gates are bound to a specific position in the world, and send all that move through them to that position. Entity Anchored Gates are bound to a being that inhabits the world, and send those moving through them to the position of that being (plus an offset, chosen when burning in the gate).",
  "hexal.page.gates.2": "Drifting Gates are not bound at all, and can be used to send entities anywhere, however they lose efficiency as a result, and can only send entities to places that are in my ambit. When a gate is burnt in I will obtain on my stack a reference to that gate. With that gate reference, I can mark entities with that gate, and I can close the gate, which sends all entities marked with that gate to the gate's destination. Note that closing a gate doesn't use it up; once I have acquired a gate iota I can use it in perpetuity.",
  "hexal.page.gates.gate/make": "Adds a new gate iota to the stack. Any copy of this iota will point to the same numbered gate. Costs 32 $(l:items/amethyst)$(item)Charged Amethyst/$. If passed null, makes a Drifting Gate. If passed a vector, makes a Location Anchored Gate, If passed a vector and an entity, makes an Entity Anchored Gate.",
  "hexal.page.gates.gate/mark": "Consumes a gate iota and an entity. Marks that entity to be teleported the next time that gate is closed. Costs one twentieth of an $(l:items/amethyst)$(item)Amethyst Dust/$.",
  "hexal.page.gates.gate/unmark": "Consumes a gate iota and an entity. Unmarks that entity so that if it was marked with $(l:hexal:patterns/spells/gates#hexal:gate/mark)$(action) Gate's Opening/$ it will no longer be teleported the next time that gate is closed.",
  "hexal.page.gates.gate/mark/num/get": "Consumes a gate iota, returns how many entities are marked by that gate.",
  "hexal.page.gates.gate/mark/get": "Consumes a gate iota and an entity, returns whether that entity is marked by that gate.",
  "hexal.page.gates.gate/close": "Consumes a non-drifing gate iota, or a drifting gate iota and a position. Transports all the entities marked with the passed gate to the stored or given position, as relevant. Costs half an $(l:items/amethyst)$(item)Amethyst Shard/$, plus an $(l:items/amethyst)$(item)Amethyst Dust/$ per metre transported per entity, if the gate was drifting.",

  "hexal.entry.motes": "Motes",
  "hexal.page.motes.explanation.0": "This entry deals with bringing items into the media, making them referencable, countable, bringing order to them and to me and to my mind and-. A mediafied item iota (known as a mote) that has been added to the stack references a specific mote record in a Mote Nexus, since without something holding the thought-pattern of the item to this world it will wither away -away like my cognition is flensing-.",
  "hexal.page.motes.explanation.1": "Any duplicate of that first mote iota referencing a record references the same record, and any change to one affects them all for they all point to the one and only in the media. Splitting and merging and crafting and trading all affect all affect all-.",
  "hexal.page.motes.explanation.2": "A Mote Nexus is limited in some ways, but only some. It can contain 1023 different records, but each record can store items innumerable. I have yet to find any limit, I can merge and merge and merge forever and the record keeps growing and growing and growing...",
  "hexal.page.motes.mediafed_storage_recipe":  "The Mote Nexus is built from the mind of a cartographer endlessly mapping the contents of the $(item)Shulker Box/$ that it has been flayed into.",
  "hexal.page.motes.mote/storage/bind": "Target a Mote Nexus block in the world and bind yourself to it, meaning all items you mediafy will be added to that nexus' capacity. Targeting any other block will unbind you from your currently bound nexus. Costs 32 $(l:items/amethyst)$(item)Amethyst Dust/$.",
  "hexal.page.motes.mote/storage/bind/temp": "Target a Mote Nexus block in the world and bind to it for the remainder of this cast, temporarily overriding your primary binding. Costs one thousandth of an $(l:items/amethyst)$(item)Amethyst Dust/$.",
  "hexal.page.motes.mote/contained_type/get": "Gets all the types of motes contained in the currently bound Mote Nexus.",
  "hexal.page.motes.mote/contained/get": "Gets all the mote records from the currently bound Mote Nexus that match the passed item type or could be combined with the passed mote.",
  "hexal.page.motes.mote/storage/remaining_capacity/get": "Gets the remaining capacity of the bound Mote Nexus.",
  "hexal.page.motes.mote/storage/contains": "Returns true if the Mote Nexus at the given position contains a mote of the given type, or that would stack with the given mote, and false otherwise.",
  "hexal.page.motes.mote/make": "Convert an item in the world (either an item entity or an item frame) into a mote on your stack. If passed an existing mote instead adds the items from the entity to the mote. Mediafying an item costs a tenth of an $(l:items/amethyst)$(item)Amethyst Dust/$.",
  "hexal.page.motes.mote/return": "Returns all the items from a mote to the world at the location of your choosing. If passed a number returns at most that many items. Costs a tenth of an $(l:items/amethyst)$(item)Amethyst Dust/$.",
  "hexal.page.motes.mote/count/get": "Accepts a mote and returns the number of items in the record referenced by that mote.",
  "hexal.page.motes.mote/combine": "Combines two motes into one, merging the mote records they point to. Any pointers to the second mote will become null, any pointers to the first will remain. This can make motes holding many more items than I could carry in a stack naturally!",
  "hexal.page.motes.mote/combinable": "Returns true if the first mote can be combined with the items in the second argument (which can be a mote, item entity, or item frame), and false otherwise.",
  "hexal.page.motes.mote/split": "Splits the specified number of items off of the passed mote, creating a new mote pointing to a new mote record.",
  "hexal.page.motes.mote/storage/get": "Get the position of the Mote Nexus that contains the passed mote.",
  "hexal.page.motes.mote/storage/set": "Move the record referenced by the passed mote to the Mote Nexus at the passed position. This returns a new mote pointing to that record, and invalidates all previous motes pointing to that record.",
  "hexal.page.motes.mote/craft.0": "Takes a mote, list of motes, or list of list of motes. returns a list containing the results of crafting with those items. For example, the input Stone x128 would return [Stone Button x128].",
  "hexal.page.motes.mote/craft.1": "For more complex crafts, inserting nulls to space items properly will be required. A diamond pickaxe for example would require [[Diamond x2, Diamond x2, Diamond x2], [null, Stick x2], [null, Stick x2]] to get [Diamond Pickaxe x2]. Costs a tenth of an $(l:items/amethyst)$(item)Amethyst Dust/$.",
  "hexal.page.motes.mote/villager/level/get": "Accepts a villager, returns a number representing that villager's seniority and skill at their craft.",
  "hexal.page.motes.mote/trade/get.0": "Accepts a villager and returns all of the trades that villager is offering. This is a list of lists of lists. Each trade comprises two lists, the cost, and the returned items. The returned items is a list containing the type of item, and the number of items.",
  "hexal.page.motes.mote/trade/get.1": "The cost is a list of one or two pairs of item and number of items required by the villager for the trade to be accepted. For example, one trade offer could be [[[Emerald, 1]], [Redstone, 1]].",
  "hexal.page.motes.mote/trade.0": "Accepts a villager, a list of motes to trade with to villager, and optionally an int for which of that villager's trades to attempt. (int? above means that you can pass 2 or 3 arguments, the optional 3rd being an int).",
  "hexal.page.motes.mote/trade.1": "If no trade number was passed, it will try each of the villager's trade until finding one that accepts the passed items. If a trade number was passed it will skip straight to using that trade. It will then repeat that trade for as long as it has enough items and the villager is still willing to trade. It will then return the items the villager traded away as a mote to the stack.",
  "hexal.page.motes.mote/trade.2": "The villager will find this trade to be a learnable experience as it would if trading with you directly, and will improve its skills and trade offerings commensurately. Costs a tenth of an $(l:items/amethyst)$(item)Amethyst Dust/$.",
  "hexal.page.motes.mote/use_on": "Accepts a mote, and either an entity, or a target block and a normal vector. Uses the item on the entity/block. The mote must either only have one item in it, or the items contained must be extremely simple (no NBT data).",

  "hexal.entry.great_wisps": "Great Wisp Spells",
  "hexal.page.great_wisps.wisp/consume.0": "Remove a wisp from the stack, and disassemble the wisp. The patterns contained are lost, but the media that it contained can be repurposed if this spell is cast by another wisp.",
  "hexal.page.great_wisps.wisp/consume.1": "Costs either an $(l:items/amethyst)$(item)Amethyst Shard/$ if the wisp is owned by you or has $(l:hexal:patterns/spells/wisps#hexal:wisp/transfer/allow)allowed$(action) transfer with the caster or caster's owner, or half again as much media as the consumed wisp contains if the wisp is owned by another and has now allowed it. Repurposing the media is not completely efficient, losing one twentieth of the consumed wisp's reserve in transfer.",
  "hexal.page.great_wisps.wisp/seon/set": "Bind one of my wisps closer to me; I may only have one bound wisp at a time, but whichever wisp is bound costs significantly less upkeep and increased range.",
  "hexal.page.great_wisps.wisp/seon/get": "Returns my currently bound wisp. A new wisp can only be bound when this returns null. (This is not a great spell, I have simply placed it here for convenience.)",

  "hexal.entry.types": "Types",
  "hexal.page.types.type/iota": "Remove an iota from the stack, and adds the type of that iota to the stack.",
  "hexal.page.types.type/entity": "Remove an entity from the stack, and adds the type of the entity at that location to the stack.",
  "hexal.page.types.type/block_item": "Remove a location, $(l:hexal:hexal.entry.motes)$(item)mote/$, item entity, or item frame from the stack, and adds the type of the block at that location, or type of that item, to the stack (e.g. Grass, Stone, Stick, etc.).",
  "hexal.page.types.type/item_held": "Adds the type of the item in the caster's offhand to the stack if there is one present, or the type of the casting hand otherwise.",

  "hexal.page.types.raycast/entity/type": "Remove an entity type or item type, a position, and a direction from the stack, and returns an entity or item entity of that type at that position if one exists.",
  "hexal.page.types.get_entity/type": "Remove an entity type or item type and a position from the stack, and returns an entity or item entity of that type at that position if one exists.",
  "hexal.page.types.zone_entity/type": "Remove an entity type or item type, a position, and a radius from the stack, and returns a list of all entities or item entities of that type within that radius of that position.",
  "hexal.page.types.zone_entity/not_type": "Remove an entity type or item type, a position, and a radius from the stack, and returns a list of all entities or item entities not of that type within that radius of that position.",


  "hexal.entry.everbook": "Everbook",
  "hexal.page.everbook.0": "Your Everbook is a strange space that your broken mind can now reach. There are many yous that seem to share this record, worlds and worlds of progress, beginning again and again. Your Everbook can store patterns paired with iotas like an $(l:hexcasting:greatwork/akashiclib)$(item)Akashic Record/$, though the fragile nature of your mind these days makes it best to route all access to your Everbook through an $(l:hexcasting:greatwork/akashiclib)$(item)Akashic Record/$. Any world that you reach enlightenment in, you will have access to the entries you add to it now.",
  "hexal.page.everbook.everbook/read": "Takes the position of an $(l:hexcasting:greatwork/akashiclib)$(item)Akashic Record/$, as well as a Pattern as a key, and retrieves the iota at that key from your Everbook, storing it in the given $(l:hexcasting:greatwork/akashiclib)$(item)Akashic Record/$ if able.",
  "hexal.page.everbook.everbook/write": "Takes the position of an $(l:hexcasting:greatwork/akashiclib)$(item)Akashic Record/$, as well as a Pattern as a key, and stores the iota in that record at that key to your Everbook at the same key.",
  "hexal.page.everbook.everbook/delete": "Takes a pattern and removes the entry with that pattern key from your Everbook.",
  "hexal.page.everbook.everbook/toggle_macro.0": "Takes a pattern and marks that entry of your Everbook as a Pattern that when drawn by your hand will be treated as any other of Nature's patterns.",
  "hexal.page.everbook.everbook/toggle_macro.1": "When you draw the key of an Everbook entry that has been marked as a Pattern, if that entry is a list Nature will execute each element of the list as it would with $(l:patterns/meta#hexcasting:eval)$(action)Hermes' Gambit/$, though it does not use up an evaluation. Attempting to mark an entry as a Pattern if it is non-existent or infinitely recursive will fail.",

  "hexal.entry.everbook_entries": "Everbook Entries",
  "hexal.page.everbook_entries.0": "Every page in this entry displays the pattern key for one of the entries of your $(l:hexal:patterns/everbook)$(action)Everbook/$.",

  "hexal.everbook_pattern_entry.header": "Stored Key: %d",
  "hexal.everbook_pattern_entry.macro_header": "Macro Key: %d",



  "_comment": "Config Entries",
  "text.autoconfig.hexal.title": "Hexal Configs",
  "text.autoconfig.hexal.category.common": "Common",
  "text.autoconfig.hexal.category.client": "Client",
  "text.autoconfig.hexal.category.server": "Server",

  "text.autoconfig.hexal.option.server.terrainGeneration": "Terrain Generation",
  "text.autoconfig.hexal.option.server.generateSlipwayGeodes": "Should generate Slipway Geodes?",

  "text.autoconfig.hexal.option.server.miscSpells": "Miscellaneous Spells",
  "text.autoconfig.hexal.option.server.miscSpells.fallingBlockCost": "Falling Block Cost",
  "text.autoconfig.hexal.option.server.miscSpells.freezeCost": "Freeze Cost",
  "text.autoconfig.hexal.option.server.miscSpells.particlesCost": "Particles Cost per Vector",
  "text.autoconfig.hexal.option.server.miscSpells.placeTypeCost": "Place Type Cost",
  "text.autoconfig.hexal.option.server.miscSpells.smeltCost": "Smelt Cost per Item",

  "text.autoconfig.hexal.option.server.wispSpells": "Wisp Spells",
  "text.autoconfig.hexal.option.server.wispSpells.moveSpeedSetCost": "Move Speed Set Base Cost",
  "text.autoconfig.hexal.option.server.wispSpells.moveSpeedSetCost.@Tooltip[0]": "Cost to increase the movement speed of a wisp by 1.",
  "text.autoconfig.hexal.option.server.wispSpells.moveSpeedSetCost.@Tooltip[1]": "This is the base cost, with greater increases being quadratically based on this.",
  "text.autoconfig.hexal.option.server.wispSpells.summonTickingWispCost": "Summon Cyclic Wisp Cost",
  "text.autoconfig.hexal.option.server.wispSpells.summonProjectileWispCost": "Summon Projectile Wisp Cost per Velocity Squared",
  "text.autoconfig.hexal.option.server.wispSpells.summonProjectileWispMinCost": "Summon Cyclic Wisp Minimum Cost",

  "text.autoconfig.hexal.option.server.wispUpkeep": "Wisp Upkeep",
  "text.autoconfig.hexal.option.server.wispUpkeep.tickingWispUpkeepPerTick": "Cyclic Wisp Upkeep per Tick",
  "text.autoconfig.hexal.option.server.wispUpkeep.projectileWispUpkeepPerTick": "Projectile Wisp Upkeep per Tick",
  "text.autoconfig.hexal.option.server.wispUpkeep.untriggeredWispUpkeepDiscount": "Untriggered Wisp Upkeep Discount",
  "text.autoconfig.hexal.option.server.wispUpkeep.untriggeredWispUpkeepDiscount.@Tooltip[0]": "The upkeep cost of untriggered cyclic wisps is multiplied by this number.",
  "text.autoconfig.hexal.option.server.wispUpkeep.untriggeredWispUpkeepDiscount.@Tooltip[1]": "Bounded from 0.0 to 1.0.",
  "text.autoconfig.hexal.option.server.wispUpkeep.linkUpkeepPerTick": "Link Upkeep per Tick",
  "text.autoconfig.hexal.option.server.wispUpkeep.seonDiscountFactor": "Bound Wisp Discount Factor",
  "text.autoconfig.hexal.option.server.wispUpkeep.seonDiscountFactor.@Tooltip[0]": "The upkeep cost of bound wisps is divided by this number.",
  "text.autoconfig.hexal.option.server.wispUpkeep.seonDiscountFactor.@Tooltip[1]": "Bounded from 2.0 to 200.0.",
  "text.autoconfig.hexal.option.server.wispUpkeep.storingPlayerCostScaleFactor": "Storing Player Cost Scale Factor",
  "text.autoconfig.hexal.option.server.wispUpkeep.storingPlayerCostScaleFactor.@Tooltip[0]": "The multiplicative cost increase of wisps containing an iota of another player.",
  "text.autoconfig.hexal.option.server.wispUpkeep.storingPlayerCostScaleFactor.@Tooltip[1]": "Bounded from 1.0 to 200.0.",

  "text.autoconfig.hexal.option.server.linkSpells": "Link Spells",
  "text.autoconfig.hexal.option.server.linkSpells.linkCost": "Link Cost",
  "text.autoconfig.hexal.option.server.linkSpells.sendIotaCost": "Send Iota Cost",
  "text.autoconfig.hexal.option.server.linkSpells.unlinkCost": "Unlink Cost",

  "text.autoconfig.hexal.option.server.gateSpells": "Gate Spells",
  "text.autoconfig.hexal.option.server.gateSpells.makeGateCost": "Make Gate Cost",
  "text.autoconfig.hexal.option.server.gateSpells.markGateCost": "Mark Gate Cost",
  "text.autoconfig.hexal.option.server.gateSpells.closeGateCost": "Close Gate Cost",

  "text.autoconfig.hexal.option.server.itemSpells": "Item Spells",
  "text.autoconfig.hexal.option.server.itemSpells.bindStorageCost": "Bind Storage Cost",
  "text.autoconfig.hexal.option.server.itemSpells.bindTemporaryStorageCost": "Bind Temporary Storage Cost",
  "text.autoconfig.hexal.option.server.itemSpells.makeItemCost": "Make Item Cost",
  "text.autoconfig.hexal.option.server.itemSpells.returnItemCost": "Return Item Cost",
  "text.autoconfig.hexal.option.server.itemSpells.craftItemCost": "Craft Item Cost",
  "text.autoconfig.hexal.option.server.itemSpells.tradeItemCost": "Trade Item Cost",
  "text.autoconfig.hexal.option.server.itemSpells.maxItemsReturned": "Maximum Items Returned",
  "text.autoconfig.hexal.option.server.itemSpells.maxItemsReturned.@Tooltip[0]": "Maximum number of items that can be returned by Return Item.",
  "text.autoconfig.hexal.option.server.itemSpells.maxItemsReturned.@Tooltip[1]": "Bounded from 640 to 64,000.",
  "text.autoconfig.hexal.option.server.itemSpells.maxRecordsInMediafiedStorage": "Maximum Num. Records in Mote Nexus",
  "text.autoconfig.hexal.option.server.itemSpells.maxRecordsInMediafiedStorage.@Tooltip[0]": "Maximum number of records that can be stored in a Mote Nexus.",
  "text.autoconfig.hexal.option.server.itemSpells.maxRecordsInMediafiedStorage.@Tooltip[1]": "Bounded from 128 to 16,384.",


  "text.autoconfig.hexal.option.server.greatSpells": "Great Spells",
  "text.autoconfig.hexal.option.server.greatSpells.consumeWispOwnCost": "Consume Own Wisp Cost",
  "text.autoconfig.hexal.option.server.greatSpells.consumeWispOwnCost.@Tooltip[0]": "Cost to consume a wisp you own,",
  "text.autoconfig.hexal.option.server.greatSpells.consumeWispOwnCost.@Tooltip[1]": "or that doesn't fight back for some other reason.",
  "text.autoconfig.hexal.option.server.greatSpells.consumeWispOthersCostPerMedia": "Consume Other's Wisp Cost per Media",
  "text.autoconfig.hexal.option.server.greatSpells.consumeWispOthersCostPerMedia.@Tooltip[0]": "Cost to consume a wisp that fights back, this number is multiplied by",
  "text.autoconfig.hexal.option.server.greatSpells.consumeWispOthersCostPerMedia.@Tooltip[1]": "the media possessed by the wisp you are attempting to consume.",
  "text.autoconfig.hexal.option.server.greatSpells.consumeWispOthersCostPerMedia.@Tooltip[2]": "Bounded from 1.0 to 20.0.",
  "text.autoconfig.hexal.option.server.greatSpells.seonWispSetCost": "Bind Wisp Cost",
  "text.autoconfig.hexal.option.server.greatSpells.tickConstantCost": "Tick Constant Cost",
  "text.autoconfig.hexal.option.server.greatSpells.tickConstantCost.@Tooltip": "Constant cost to tick a block. Always applies.",
  "text.autoconfig.hexal.option.server.greatSpells.tickCostPerTicked": "Tick Cost per Time Ticked",
  "text.autoconfig.hexal.option.server.greatSpells.tickCostPerTicked.@Tooltip[0]": "Cost to tick a block per time that block has already been ticked.",
  "text.autoconfig.hexal.option.server.greatSpells.tickCostPerTicked.@Tooltip[1]": "Added to the constant cost above.",
  "text.autoconfig.hexal.option.server.greatSpells.tickRandomTickIProb": "Tick Inverse Probability of Random Ticking",
  "text.autoconfig.hexal.option.server.greatSpells.tickRandomTickIProb.@Tooltip[0]": "The inverse probability of tick randomly ticking a block.",
  "text.autoconfig.hexal.option.server.greatSpells.tickRandomTickIProb.@Tooltip[1]": "Higher numbers make random ticks less likely, lower numbers make them more likely.",
  "text.autoconfig.hexal.option.server.greatSpells.tickRandomTickIProb.@Tooltip[2]": "Bound from 600 to 2100."
}
