{
  "hexcasting.spell.hexstuff:regex/make": "Thompson's Purification",
  "hexcasting.spell.hexstuff:regex/match": "Haystack Distillation",
  "hexcasting.spell.hexstuff:regex/flag/case_insensitive": "Typesetter's Distillation",
  "hexcasting.spell.hexstuff:regex/flag/dotall": "Orator's Distillation",
  "hexcasting.spell.hexstuff:regex/flag/multiline": "Essayist's Distillation",
  "hexcasting.spell.hexstuff:display/make": "Typewriter Purification",
  "hexcasting.spell.hexstuff:display/concat": "Typewriter Distillation",
  "hexcasting.spell.hexstuff:display/color": "Lumi√®re Distillation",
  "hexcasting.spell.hexstuff:display/tooltip": "Footnote Distillation",
  "hexcasting.spell.hexstuff:display/flag/bold": "Gothic Distillation",
  "hexcasting.spell.hexstuff:display/flag/italic": "Manutius' Distillation",
  "hexcasting.spell.hexstuff:display/flag/underlined": "Notetaker's Distillation",
  "hexcasting.spell.hexstuff:display/flag/strikethrough": "Editor's Distillation",
  "hexcasting.spell.hexstuff:display/flag/obfuscated": "Censor's Distillation",
  "hexstuff.entry.regex": "Regular Expressions",
  "hexstuff.page.regex.0": "I've read tales of grand mages using arcane and inscrutable strings of characters understood by Nature known as a regular expression, representing a certain pattern in text for Nature to find.$(br)I believe I have found the texts describing the syntax of this language $(l:https://github.com/google/re2/wiki/Syntax)here$().$(br2)$(o)Have you tried using an XML parser instead?$()",
  "hexstuff.page.regex.make": "Creates a regular expression based on the provided string.",
  "hexstuff.page.regex.match": "Finds all matches of the regular expression in the string. Each element of the resulting list is a match, each match being a list of its capture groups, with group 0 being the whole match.",
  "hexstuff.page.regex.flag.case_insensitive": "Sets or clears the $(bold)i$() flag, which makes the regular expression be case-insensitive when set.",
  "hexstuff.page.regex.flag.dotall": "Sets or clears the $(bold)s$() flag, which makes a $(bold).$() able to match a newline when set.",
  "hexstuff.page.regex.flag.multiline": "Sets or clears the $(bold)m$() flag, which makes $(bold)^$() and $(bold)$$() match the start and end of a line when set.",
  "hexstuff.entry.display": "Display Iotas",
  "hexstuff.page.display.0": "I have discovered a way to make iotas that I can perceive as variously formatted text, useful for having my hexes show me things in a friendlier manner.",
  "hexstuff.page.display.make": "Creates a display iota based on the provided string.",
  "hexstuff.page.display.concat": "Creates a display iota by joining two display iotas together.",
  "hexstuff.page.display.color": "Sets the color of a display iota. The vector's x, y, and z components seem to each signify how red, green, or blue the color is, with 0 being not at all and 255 being the maximum.",
  "hexstuff.page.display.tooltip": "Sets what I see when I hover over a display iota. If passed a display, shows that display iota verbatim. If passed an item frame, item entity, or a mote, shows the tooltip I would see on the item.",
  "hexstuff.page.display.flag.bold": "Sets whether the display iota is bold.",
  "hexstuff.page.display.flag.italic": "Sets whether the display iota is italicized.",
  "hexstuff.page.display.flag.underlined": "Sets whether the display iota is underlined.",
  "hexstuff.page.display.flag.strikethrough": "Sets whether the display iota is struck through.",
  "hexstuff.page.display.flag.obfuscated": "Sets whether the display iota is obfuscated.",
  "hexcasting.mishap.invalid_value.class.regex": "a regular expression",
  "hexcasting.mishap.invalid_value.class.display": "a display iota",
  "hexcasting.mishap.invalid_value.invalid_regex": "a valid regular expression",
  "hexcasting.mishap.invalid_value.itementityitemframeitemdisplay": "a display iota, item entity, item frame, or mote"
}