{
  "entity_model_features.config.animate_once": "每个实体仅播放一次模型动画",
  "entity_model_features.config.animate_once.tooltip": "默认开启\n此设置使得每个被渲染的实体模型仅会播放一次动画\n在游戏中这通常是正常的,但在物品栏界面中可见的生物可能会出现奇怪的闪烁\n特别是当它代表了你已经能在世界中看到的真实生物时",
  "entity_model_features.config.debug": "调试",
  "entity_model_features.config.optifine_fallback_properties": "使用后备 .properties 文件",
  "entity_model_features.config.optifine_fallback_properties.tooltip": "如果启用,当常规的 .properties 文件无法找到时,EMF 将尝试加载一个后备的 .properties 文件\n例如:如果 pig_baby.properties 不存在,pig_baby.jem 将回退使用 pig.properties。\nOptiFine 仅使用这些后备文件工作,并且实际上不允许像 pig_baby.properties 这样的每个模型示例",
  "entity_model_features.config.show_reload_error_toast": "显示重新加载错误提示",
  "entity_model_features.config.show_reload_error_toast.tooltip": "如果启用,这将在资源重新加载期间发生错误时显示一条提示消息\n这有助于了解重新加载过程中是否出了问题",
  "entity_model_features.config.load_warn.1": "EMF 遇到加载错误",
  "entity_model_features.config.load_warn.3": "详情请查看日志或 EMF 设置",
  "entity_model_features.config.load_warn.2": "EMF 可以从以下位置重新记录这些错误:模型 > 调试 >",
  "entity_model_features.config.load_warn.title": "再次记录所有加载错误",
  "entity_model_features.config.load_warn.title2": "再次记录所有加载错误(包含堆栈追踪)",
  "entity_model_features.config.load_warn.tooltip": "此选项将把上一次资源重新加载时遇到的所有 EMF 加载错误,按照遇到的顺序重新打印到日志中\n并非这里的所有错误都很有用,因为它们可能缺少周围的日志上下文",
  "entity_model_features.config.optifine_floor": "取整方块 UV 值",
  "entity_model_features.config.optifine_floor.tooltip": "OptiFine 会将自定义方块 UV 中的所有 UV 值进行取整(floor)\n即,使它们全部变为整数。\n此设置将使 EMF 执行相同的操作\n如果 EMF 发现一个模型没有取整的 UV,它也会记录日志",
  "entity_model_features.config.optifine_syntax": "CEM 动画语法限制",
  "entity_model_features.config.optifine_syntax.tooltip": "如果启用,这将强制执行 OptiFine 的 CEM 语法限制,例如:\n动画中的骨骼 ID 不能以 _ 或数字开头。\n数字不能以 '.' 开头,例如 '.9'\n名为 'render' 的骨骼不能被动画引用\n启用此设置后,将为任何违反这些规则的动画记录错误并使它们失效。",
  "entity_model_features.config.models.explain": "此处可见的并非所有部件都会导出\n只有已声明的部件才会。\n您可以在导出后检查游戏日志来查明缺失部件的变换详情。",
  "entity_model_features.config.optifine_subfolders": "子文件夹模型必须存在变体",
  "entity_model_features.config.optifine_subfolders.tooltip": "在 OptiFine 中,模型文件的子文件夹选项仅在该模型存在变体时才有效。\n例如:'optifine/cem/skeleton/skeleton.jem' 只有在它有变体时才会加载\n例如 'optifine/cem/skeleton/skeleton2.jem' 或一个 .properties 文件\n此设置将使 EMF 也强制执行此规则,\n如果 EMF 发现一个没有变体的模型,它会记录此情况",
  "entity_model_features.config.debug.tooltip": "调试选项,有助于弄清楚一些问题",
  "entity_model_features.config.debug_right_click": "右键点击实体时显示 EMF 调试数据",
  "entity_model_features.config.debug_right_click.tooltip": "如果启用,当右键点击一个实体时,这将在日志和聊天中打印出 EMF 调试信息。",
  "entity_model_features.config.ebe_config_modify": "增强型方块实体 (EBE) Mod 补丁",
  "entity_model_features.config.ebe_config_modify.tooltip": "如果启用,这将允许 EMF 修改 EBE Mod 的配置\n以便为某些方块实体禁用 EBE,如果该\n方块实体实际上已加载了自定义的 EMF 模型。\nEMF 之后无法自动重新启用这些设置,\n如果需要,您必须手动完成。",
  "entity_model_features.config.force_models": "尝试阻止 EMF 模型被覆盖",
  "entity_model_features.config.force_models.tooltip": "将尝试强制实体渲染器使用 EMF 设置的模型\n这可以覆盖其他模组修改的原版模型\n但这并非对所有模组都有效",
  "entity_model_features.config.function_explanation.abs": "abs(x)\n获取一个数的绝对值。将使负数变为正数",
  "entity_model_features.config.function_explanation.acos": "acos(x)\n获取 x 的反余弦值",
  "entity_model_features.config.function_explanation.asin": "asin(x)\n获取 x 的反正弦值",
  "entity_model_features.config.function_explanation.atan": "atan(x)\n获取 x 的反正切值",
  "entity_model_features.config.function_explanation.atan2": "atan2(y, x)\n获取正 x 轴与点 (x, y) 之间的角度",
  "entity_model_features.config.function_explanation.catmullrom": "catmullrom(k, x, y, z, w)\n使用控制点 z 和 w 的 catmull-rom 样条函数在 x 和 y 之间插值",
  "entity_model_features.config.function_explanation.ceil": "ceil(x)\n将 x 向上取整到最接近的整数",
  "entity_model_features.config.function_explanation.clamp": "clamp(x, min, max)\n将一个数限制在最小值和最大值之间",
  "entity_model_features.config.function_explanation.cos": "cos(x)\n获取 x 的余弦值",
  "entity_model_features.config.function_explanation.nbt": "nbt(x,y)\n布尔函数,如果实体具有与查询 y 匹配的 NBT 标签 x,则返回 true。\nx 等价于 NBT 随机属性中 'nbt.<n>.' 之后的内容。\ny 等价于 NBT 随机属性中 '=' 之后的内容。\n例如:NBT 属性中的 'nbt.1.SleepingX=exists:true' 在动画函数中将是 'nbt(SleepingX,exists:true)'。",
  "entity_model_features.config.function_explanation.cubicbezier": "cubicbezier(k, x, y, z, w)\n使用控制点 z 和 w 的三次贝塞尔样条函数在 x 和 y 之间插值",
  "entity_model_features.config.function_explanation.degdiff": "degdiff(x, y)\n返回两个度数值 x 和 y 之间的最短角度差",
  "entity_model_features.config.function_explanation.easeinback": "easeinback(k, x, y)\n使用 ease in back 函数在 x 和 y 之间插值\n\n示例见此:https://easings.net/",
  "entity_model_features.config.function_explanation.easeinbounce": "easeinbounce(k, x, y)\n使用 ease in bounce 函数在 x 和 y 之间插值\n\n示例见此:https://easings.net/",
  "entity_model_features.config.function_explanation.easeincirc": "easeincirc(k, x, y)\n使用 ease in circ 函数在 x 和 y 之间插值\n\n示例见此:https://easings.net/",
  "entity_model_features.config.function_explanation.easeincubic": "easeincubic(k, x, y)\n使用 ease in cubic 函数在 x 和 y 之间插值\n\n示例见此:https://easings.net/",
  "entity_model_features.config.function_explanation.easeinelastic": "easeinelastic(k, x, y)\n使用 ease in elastic 函数在 x 和 y 之间插值\n\n示例见此:https://easings.net/",
  "entity_model_features.config.function_explanation.easeinexpo": "easeinexpo(k, x, y)\n使用 ease in expo 函数在 x 和 y 之间插值\n\n示例见此:https://easings.net/",
  "entity_model_features.config.function_explanation.easeinoutback": "easeinoutback(k, x, y)\n使用 ease in 和 ease out back 函数在 x 和 y 之间插值\n\n示例见此:https://easings.net/",
  "entity_model_features.config.function_explanation.easeinoutbounce": "easeinoutbounce(k, x, y)\n使用 ease in 和 ease out bounce 函数在 x 和 y 之间插值\n\n示例见此:https://easings.net/",
  "entity_model_features.config.function_explanation.easeinoutcirc": "easeinoutcirc(k, x, y)\n使用 ease in 和 ease out circ 函数在 x 和 y 之间插值\n\n示例见此:https://easings.net/",
  "entity_model_features.config.function_explanation.easeinoutcubic": "easeinoutcubic(k, x, y)\n使用 ease in 和 ease out cubic 函数在 x 和 y 之间插值\n\n示例见此:https://easings.net/",
  "entity_model_features.config.function_explanation.easeinoutelastic": "easeinoutelastic(k, x, y)\n使用 ease in 和 ease out elastic 函数在 x 和 y 之间插值\n\n示例见此:https://easings.net/",
  "entity_model_features.config.function_explanation.easeinoutexpo": "easeinoutexpo(k, x, y)\n使用 ease in 和 ease out expo 函数在 x 和 y 之间插值\n\n示例见此:https://easings.net/",
  "entity_model_features.config.function_explanation.easeinoutquad": "easeinoutquad(k, x, y)\n使用 ease in 和 ease out quad 函数在 x 和 y 之间插值\n\n示例见此:https://easings.net/",
  "entity_model_features.config.function_explanation.easeinoutquart": "easeinoutquart(k, x, y)\n使用 ease in 和 ease out quart 函数在 x 和 y 之间插值\n\n示例见此:https://easings.net/",
  "entity_model_features.config.function_explanation.easeinoutquint": "easeinoutquint(k, x, y)\n使用 ease in 和 ease out quint 函数在 x 和 y 之间插值\n\n示例见此:https://easings.net/",
  "entity_model_features.config.function_explanation.easeinoutsine": "easeinoutsine(k, x, y)\n使用 ease in 和 ease out sine 函数在 x 和 y 之间插值\n\n示例见此:https://easings.net/",
  "entity_model_features.config.function_explanation.easeinquad": "easeinquad(k, x, y)\n使用 ease in quad 函数在 x 和 y 之间插值\n\n示例见此:https://easings.net/",
  "entity_model_features.config.function_explanation.easeinquart": "easeinquart(k, x, y)\n使用 ease in quart 函数在 x 和 y 之间插值\n\n示例见此:https://easings.net/",
  "entity_model_features.config.function_explanation.easeinquint": "easeinquint(k, x, y)\n使用 ease in quint 函数在 x 和 y 之间插值\n\n示例见此:https://easings.net/",
  "entity_model_features.config.function_explanation.easeinsine": "easeinsine(k, x, y)\n使用 ease in sine 函数在 x 和 y 之间插值\n\n示例见此:https://easings.net/",
  "entity_model_features.config.function_explanation.easeoutback": "easeoutback(k, x, y)\n使用 ease out back 函数在 x 和 y 之间插值\n\n示例见此:https://easings.net/",
  "entity_model_features.config.function_explanation.easeoutbounce": "easeoutbounce(k, x, y)\n使用 ease out bounce 函数在 x 和 y 之间插值\n\n示例见此:https://easings.net/",
  "entity_model_features.config.function_explanation.easeoutcirc": "easeoutcirc(k, x, y)\n使用 ease out circ 函数在 x 和 y 之间插值\n\n示例见此:https://easings.net/",
  "entity_model_features.config.function_explanation.easeoutcubic": "easeoutcubic(k, x, y)\n使用 ease out cubic 函数在 x 和 y 之间插值\n\n示例见此:https://easings.net/",
  "entity_model_features.config.function_explanation.easeoutelastic": "easeoutelastic(k, x, y)\n使用 ease out elastic 函数在 x 和 y 之间插值\n\n示例见此:https://easings.net/",
  "entity_model_features.config.function_explanation.easeoutexpo": "easeoutexpo(k, x, y)\n使用 ease out expo 函数在 x 和 y 之间插值\n\n示例见此:https://easings.net/",
  "entity_model_features.config.function_explanation.easeoutquad": "easeoutquad(k, x, y)\n使用 ease out quad 函数在 x 和 y 之间插值\n\n示例见此:https://easings.net/",
  "entity_model_features.config.function_explanation.easeoutquart": "easeoutquart(k, x, y)\n使用 ease out quart 函数在 x 和 y 之间插值\n\n示例见此:https://easings.net/",
  "entity_model_features.config.function_explanation.easeoutquint": "easeoutquint(k, x, y)\n使用 ease out quint 函数在 x 和 y 之间插值\n\n示例见此:https://easings.net/",
  "entity_model_features.config.function_explanation.easeoutsine": "easeoutsine(k, x, y)\n使用 ease out sine 函数在 x 和 y 之间插值\n\n示例见此:https://easings.net/",
  "entity_model_features.config.function_explanation.exp": "exp(x)\n获取 e(欧拉常数)的 x 次幂",
  "entity_model_features.config.function_explanation.floor": "floor(x)\n将 x 向下取整到最接近的整数",
  "entity_model_features.config.function_explanation.fmod": "fmod(x, y)\n类似于 % 运算符,但返回值总是与除数符号相同",
  "entity_model_features.config.function_explanation.frac": "frac(x)\n获取 x 的小数部分(小数点后的部分)",
  "entity_model_features.config.function_explanation.hermite": "hermite(k, x, y, z, w)\n使用控制点 z 和 w 的 Hermite 样条函数在 x 和 y 之间插值",
  "entity_model_features.config.function_explanation.if": "if(cond, val, [cond2, val2, ...], val_else)\n根据一个或多个条件选择一个值",
  "entity_model_features.config.function_explanation.keyframe": "keyframe(k, a, b, c,...)\n基于当前帧 'k' 和关键帧在值之间平滑插值。'a' 是 'k=0','b' 是 'k=1','c' 是 'k=2',依此类推。",
  "entity_model_features.config.function_explanation.keyframeloop": "keyframeloop(k, a, b, c,...)\n基于当前帧 'k' 和关键帧在值之间平滑插值。'a' 是 'k=0','b' 是 'k=1','c' 是 'k=2',依此类推,但当 'k' 大于关键帧数量时,动画会循环回到帧 'a'。",
  "entity_model_features.config.function_explanation.lerp": "lerp(k, x, y)\nX 和 Y 之间的线性插值",
  "entity_model_features.config.function_explanation.log": "log(x)\n获取 x 的自然对数",
  "entity_model_features.config.function_explanation.max": "max(x, y, ...)\n从数字列表中获取最大的数字",
  "entity_model_features.config.function_explanation.min": "min(x, y ,...)\n从数字列表中获取最小的数字",
  "entity_model_features.config.function_explanation.pow": "pow(x, y)\n获取 x 的 y 次幂",
  "entity_model_features.config.function_explanation.print": "print(id, n, x)\n每 N 帧打印一次值 \"x\"",
  "entity_model_features.config.function_explanation.printb": "printb(id, n, x)\n每 N 帧打印一次布尔值 \"x\"",
  "entity_model_features.config.function_explanation.quadbezier": "quadbezier(k, x, y, z)\n使用控制点 z 的二次贝塞尔样条函数在 x 和 y 之间插值",
  "entity_model_features.config.function_explanation.raddiff": "raddiff(x, y)\n返回两个弧度值 x 和 y 之间的最短弧度差",
  "entity_model_features.config.function_explanation.random": "random(seed)\n从 0 到 1 的随机数。提供种子(seed)将总是返回相同的结果。种子是可选的",
  "entity_model_features.config.function_explanation.round": "round(x)\n将 x 四舍五入到最接近的整数",
  "entity_model_features.config.function_explanation.signum": "signum(x)\n获取 x 的符号(正或负)",
  "entity_model_features.config.function_explanation.sin": "sin(x)\n获取 x 的正弦值",
  "entity_model_features.config.function_explanation.between": "between(x, min, max)\n检查一个值是否在最小值和最大值之间",
  "entity_model_features.config.function_explanation.equals": "equals(x, y, epsilon)\n带有误差范围地比较两个浮点值",
  "entity_model_features.config.function_explanation.in": "in(x, val1, val2, ...)\n检查一个值是否等于多个值中的某一个",
  "entity_model_features.config.function_explanation.sqrt": "sqrt(x)\n获取 x 的平方根",
  "entity_model_features.config.function_explanation.tan": "tan(x)\n获取 x 的正切值",
  "entity_model_features.config.function_explanation.ifb": "if(cond, val, [cond2, val2, ...], val_else)\n根据一个或多个条件选择一个值\n仅返回布尔值",
  "entity_model_features.config.function_explanation.randomb": "random(seed)\n随机布尔值 true|false。提供种子(seed)将总是返回相同的结果。种子是可选的",
  "entity_model_features.config.function_explanation.catch": "catch(x,c,id)\n将返回 x,但是如果 x 是 NaN 或引起其他动画错误,则将返回 c。\nid 是可选的,如果添加了它,catch 函数将把使用 c 的原因打印到带有此 id 的游戏日志中\n主要用于动画调试,如果有可能会触发此情况,您真的应该去修复它。",
  "entity_model_features.config.function_explanation.todeg": "todeg(rad)\n将弧度转换为度",
  "entity_model_features.config.function_explanation.torad": "torad(deg)\n将度转换为弧度",
  "entity_model_features.config.function_explanation.wrapdeg": "wrapdeg(x)\n将度数值 x 包装到与其匹配的 -180 到 180 的范围内",
  "entity_model_features.config.function_explanation.wraprad": "wraprad(x)\n将弧度值 x 包装到与其匹配的 -pi 到 pi 的范围内",
  "entity_model_features.config.general": "常规",
  "entity_model_features.config.general.tooltip": "常规设置",
  "entity_model_features.config.large_mob_lod": "为大型生物保留 LOD",
  "entity_model_features.config.large_mob_lod.tooltip": "如果启用,这将根据生物的大小减少上述设置的细节层次(LOD)影响。\n较大生物的跳帧现象将比较小生物不那么明显",
  "entity_model_features.config.lod": "动画 LOD 距离",
  "entity_model_features.config.lod.tooltip": "设置动画开始跳帧的距离,\n降低细节层次(LOD),这有助于提高性能\n无 = 不跳帧\n16 = 距离玩家每 16 格方块跳过 1 帧\n较低的数字意味着更多的跳帧和更高的性能增益\n但当然,动画的帧率会变得更低,LOD 距离设置得越近越明显",
  "entity_model_features.config.log_math": "记录动画计算",
  "entity_model_features.config.log_math.tooltip": "将动画数学调试数据打印到日志中\n警告:极易引起卡顿！",
  "entity_model_features.config.log_models": "记录模型构建信息",
  "entity_model_features.config.log_models.tooltip": "将模型创建调试数据打印到日志中",
  "entity_model_features.config.low_fps_lod": "低 FPS 时保留 LOD",
  "entity_model_features.config.low_fps_lod.tooltip": "如果启用,这将根据您的 fps 减少上述设置的细节层次(LOD)影响。\n仅在低于 60 fps 时应用,因为在较低的 fps 下跳帧会变得越来越明显",
  "entity_model_features.config.optimizations": "优化",
  "entity_model_features.config.optimizations.tooltip": "与动画优化相关的设置",
  "entity_model_features.config.options": "选项与修复",
  "entity_model_features.config.options.tooltip": "用于基本功能或模组兼容性修复的各种选项",
  "entity_model_features.config.performance": "性能设置",
  "entity_model_features.config.physics": "物理模组补丁",
  "entity_model_features.config.physics.1": "使用原版模型",
  "entity_model_features.config.physics.2": "使用 EMF (CEM) 模型",
  "entity_model_features.config.physics.tooltip": "如果启用了物理模组,则仅在死亡时渲染原始的原版模型部件\n这能部分工作,但不是一个完美的解决方案",
  "entity_model_features.config.print_mode": "模型导出",
  "entity_model_features.config.print_mode.all_log": "所有模型 - 仅日志",
  "entity_model_features.config.print_mode.all_log_jem": "所有模型 - 日志和 .jem",
  "entity_model_features.config.print_mode.log": "未知模型 - 仅日志",
  "entity_model_features.config.print_mode.log_jem": "未知模型 - 日志和 .jem",
  "entity_model_features.config.print_mode.tooltip": "这将为 EMF 可以访问的任何模型打印部件信息或完整的 .jem 文件,每次重新加载都会执行！！\n重新加载后,.jem 文件可以在 \"MC_DIRECTORY/emf/export\" 目录中找到\n.jem 文件是 Blockbench 就绪的,具有\n正确的枢轴点、框和 UV\n未知模型指的是 OptiFine CEM 不支持的模型",
  "entity_model_features.config.debug_hover": "仅在悬停时调试渲染",
  "entity_model_features.config.debug_hover.tooltip": "使上述渲染设置仅适用于客户端悬停的实体。\n即,被您直接注视的实体。",
  "entity_model_features.config.render": "调试渲染模式",
  "entity_model_features.config.render.green": "绿色闪烁",
  "entity_model_features.config.render.lines": "仅线框",
  "entity_model_features.config.render.lines_texture": "纹理上线框",
  "entity_model_features.config.render.lines_texture_flash": "纹理上闪烁线框",
  "entity_model_features.config.render.none": "禁用",
  "entity_model_features.config.render.normal": "正常",
  "entity_model_features.config.render.tooltip": "更改自定义模型部件的渲染方式,这不影响原版模型部件。\n正常 = 正常渲染\n绿色闪烁 = 自定义部件将闪烁绿色\n轮廓 = 模型部件的轮廓将被渲染\n禁用 = 自定义模型部件将不会被渲染",
  "entity_model_features.config.substitute_vanilla": "替换缺失的模型部件",
  "entity_model_features.config.substitute_vanilla.tooltip": "EMF 将尝试用原版对应部件替换 .jem 模型文件中缺失的部件",
  "entity_model_features.config.texture_override_mode": "子模型纹理处理",
  "entity_model_features.config.texture_override_mode.dont": "忽略纹理覆盖",
  "entity_model_features.config.texture_override_mode.emf": "尝试使用 EMF 代码",
  "entity_model_features.config.texture_override_mode.iris": "优先尝试使用 Iris",
  "entity_model_features.config.texture_override_mode.tooltip": "这控制了 EMF 如何处理设置了覆盖纹理的子模型的渲染\n例如,如果一个爬行者模型有一个单独的头部件子模型纹理\n有两种方法可以做到这一点:依靠我的代码,或者依靠 Iris 模组的一个特性\n我的代码'能用',但我不是渲染缓冲区方面的专家,它可能会引起问题\nIris 特性使用了一种相当直接且看似安全/稳定的方法,但我被告知这不是 Iris 的预期行为\n如果未安装 Iris,Iris 选项将默认使用 EMF 代码\n除了在调试子模型中的纹理覆盖时,这几乎应该总是保留为默认设置",
  "entity_model_features.config.tools": "工具",
  "entity_model_features.config.tools.tooltip": "可选的工具,用于帮助模型制作或区分自定义模型",
  "entity_model_features.config.update": "模型更新速率",
  "entity_model_features.config.update.tooltip": "设置生物模型更新的频率,\n用于诸如生命值和年龄等变化\n从不 = 从不更新\n慢 = 3-5 秒\n平均 = 约 1 秒\n快 = 小于 1 秒\n即时 = 即时(可能有数百个生物时造成卡顿)",
  "entity_model_features.config.vanilla_render": "原版模型显示模式",
  "entity_model_features.config.vanilla_render.normal": "正常",
  "entity_model_features.config.vanilla_render.offset": "偏移",
  "entity_model_features.config.vanilla_render.tooltip": "此设置将同时渲染原版模型和自定义模型以进行比较\n它不会动画,因此位置可能有点奇怪",
  "entity_model_features.config.variable_explanation.age": "以刻为单位的年龄",
  "entity_model_features.config.variable_explanation.is_swinging_right_arm": "如果实体正在摆动其右臂,则为 True。注意 false 并不意味着另一只手臂在摆动",
  "entity_model_features.config.variable_explanation.is_swinging_left_arm": "如果实体正在摆动其左臂,则为 True。注意 false 并不意味着另一只手臂在摆动",
  "entity_model_features.config.variable_explanation.anger_time": "实体剩余的愤怒时间(刻)。攻击性时从 400-780 开始,当目标丢失时倒计时到 0",
  "entity_model_features.config.variable_explanation.anger_time_start": "anger_time 的起始值",
  "entity_model_features.config.variable_explanation.day_count": "当前天数计数",
  "entity_model_features.config.variable_explanation.day_time": "当前白天时间(刻)(0-24000)",
  "entity_model_features.config.variable_explanation.death_time": "实体死亡的时间。从 0 计数到 20",
  "entity_model_features.config.variable_explanation.dimension": "当前维度。主世界: 0, 下界: -1, 末地: 1",
  "entity_model_features.config.variable_explanation.distance": "实体距离客户端玩家的方块数\n\n虽然 distance 变量是为了方便而添加的,但在 OptiFine 中可以通过以下代码实现相同的效果:\n\"var.distance\": \"sqrt(pow(pos_x  -player_pos_x, 2) + pow(pos_y - player_pos_y, 2) + pow(pos_z - player_pos_z, 2))\"",
  "entity_model_features.config.variable_explanation.e": "欧拉数\n2.718281.....",
  "entity_model_features.config.variable_explanation.entity_variable": "实体变量的格式为 \"var.<name>\" (浮点数) 或 \"varb.<name>\" (布尔值)\n\n名称可以是任何字符串,例如 \"var.xyz\", \"var.last_rx\" 等。\n\n该变量附加到被渲染的实体,默认值为 0 或 false。\n\n实体变量对于在帧之间存储动画数据非常有用。",
  "entity_model_features.config.variable_explanation.entity_variable.title": "实体变量",
  "entity_model_features.config.variable_explanation.false": "常量值\nfalse",
  "entity_model_features.config.variable_explanation.fluid_depth": " submerged 实体上方和下方流体的深度,如果未 submerged 则为 0",
  "entity_model_features.config.variable_explanation.fluid_depth_down": " submerged 实体下方流体的深度,如果未 submerged 则为 0",
  "entity_model_features.config.variable_explanation.fluid_depth_up": " submerged 实体上方流体的深度,如果未 submerged 则为 0",
  "entity_model_features.config.variable_explanation.frame_time": "自上一帧以来的时间(秒)",
  "entity_model_features.config.variable_explanation.head_pitch": "头部俯仰 (x 旋转)",
  "entity_model_features.config.variable_explanation.head_yaw": "头部偏航 (y 旋转)",
  "entity_model_features.config.variable_explanation.health": "实体当前的生命值",
  "entity_model_features.config.variable_explanation.height_above_ground": "实体离地面的距离\n地面是实体下方具有可碰撞方块的最高点",
  "entity_model_features.config.variable_explanation.hurt_time": "实体受伤的时间。从 10 倒计时到 0",
  "entity_model_features.config.variable_explanation.id": "实体的唯一数字标识符\n对于同一个实体总是相同的",
  "entity_model_features.config.variable_explanation.is_aggressive": "实体是否对玩家或其他实体具有攻击性",
  "entity_model_features.config.variable_explanation.is_alive": "实体是否存活",
  "entity_model_features.config.variable_explanation.is_blocking": "实体是否正在用盾牌格挡",
  "entity_model_features.config.variable_explanation.is_burning": "实体是否着火",
  "entity_model_features.config.variable_explanation.is_child": "实体是否处于幼年状态",
  "entity_model_features.config.variable_explanation.is_climbing": "实体是否正在攀爬可攀爬的方块或者是墙上的蜘蛛",
  "entity_model_features.config.variable_explanation.is_crawling": "实体是否正在爬行",
  "entity_model_features.config.variable_explanation.is_glowing": "实体是否具有发光效果",
  "entity_model_features.config.variable_explanation.is_hurt": "实体是否正在受到伤害",
  "entity_model_features.config.variable_explanation.frame_counter": "当前帧的索引(0 到 720719,然后重置为 0)",
  "entity_model_features.config.variable_explanation.is_in_ground": "三叉戟是否刺入地面",
  "entity_model_features.config.variable_explanation.is_in_gui": "实体是否在 GUI 内",
  "entity_model_features.config.variable_explanation.is_in_hand": "实体是否被握在您的手中",
  "entity_model_features.config.variable_explanation.is_in_item_frame": "实体是否在物品展示框中",
  "entity_model_features.config.variable_explanation.is_in_lava": "实体是否接触熔岩",
  "entity_model_features.config.variable_explanation.is_in_water": "实体是否接触水",
  "entity_model_features.config.variable_explanation.is_invisible": "实体是否具有隐身效果/NBT 标签",
  "entity_model_features.config.variable_explanation.is_on_ground": "实体是否接触地面",
  "entity_model_features.config.variable_explanation.is_on_head": "实体是否被穿戴在另一个实体的头部",
  "entity_model_features.config.variable_explanation.is_on_shoulder": "鹦鹉是否坐在您的肩膀上",
  "entity_model_features.config.variable_explanation.is_ridden": "实体是否正被另一个实体骑乘",
  "entity_model_features.config.variable_explanation.is_riding": "实体是否正在骑乘另一个实体",
  "entity_model_features.config.variable_explanation.is_sitting": "猫/狼/鹦鹉是否坐着",
  "entity_model_features.config.variable_explanation.is_sneaking": "猫/豹猫是否潜行",
  "entity_model_features.config.variable_explanation.is_jumping": "生物是否正在跳跃",
  "entity_model_features.config.variable_explanation.is_sprinting": "猫/豹猫是否冲刺",
  "entity_model_features.config.variable_explanation.is_tamed": "猫/狼/鹦鹉是否被驯服",
  "entity_model_features.config.variable_explanation.is_wet": "实体是否在水中/雨中",
  "entity_model_features.config.variable_explanation.is_right_handed": "玩家是否惯用右手",
  "entity_model_features.config.variable_explanation.is_swimming": "实体是否在游泳",
  "entity_model_features.config.variable_explanation.is_gliding": "实体是否在滑翔",
  "entity_model_features.config.variable_explanation.is_first_person_hand": "游戏当前是否正在渲染第一人称手部模型",
  "entity_model_features.config.variable_explanation.limb_speed": "肢体移动速度。范围从 0 到 1(静止 = 0,冲刺 = 1)",
  "entity_model_features.config.variable_explanation.limb_swing": "肢体动画计数器。当实体移动时以刻为单位递增",
  "entity_model_features.config.variable_explanation.max_health": "实体的最大生命值",
  "entity_model_features.config.variable_explanation.model_part": "模型变量的格式为\n \"<model>.<variable_name>\"\n\n模型可以是:\n \"this\" - 当前自定义模型\n \"part\" - 自定义模型所附加的原始部件模型\n \"<part>\" - 按部件名称的原始模型\n \"<id>\" - 按 ID 的自定义模型\n \"<part>:<sub_id>:<sub_sub_id>:...\" - (分层)从按部件名称的原始模型开始,然后按 ID 查找子项\n \"<id>:<sub_id>:<sub_sub_id>:...\" - (分层)从按 ID 的模型开始,然后按 ID 查找子项\n\n如果存在重复项,则使用按部件名称或 ID 找到的第一个模型。\n按 ID 的模型搜索是深度的,即使在分层规范中使用时也是如此。\n\n分层规范允许模型组(json 部件模型)被不同的部件重用。\n例如,一个手部模型(\"shoulder:upper_arm:elbow:forearm:palm:finger[1.5]\")可以同时用于左手和右手。\n动画可以使用 \"left_hand:finger1\" 表示左手拇指,使用 \"right_hand:finger1\" 表示右手拇指。\n分层规范中的中间父项可以被跳过。\n\n变量名\n tx, ty, tz    - 平移 x, y, z\n rx, ry, rz    - 旋转 x, y, z\n sx, sy, sz    - 缩放 x, y, z\n visible       - 显示模型和子模型(布尔值)\n visible_boxes - 仅显示模型,不影响子模型(布尔值)",
  "entity_model_features.config.variable_explanation.model_part.title": "模型部件变量",
  "entity_model_features.config.variable_explanation.move_forward": "实体当前朝向方向的移动。范围从 -1 到 1,表示玩家当前移动向量单位圆的 Y 轴截距。1 是向前,-1 是向后",
  "entity_model_features.config.variable_explanation.move_strafing": "实体当前朝向方向右侧 90 度方向的移动。范围从 -1 到 1,表示玩家当前移动向量单位圆的 X 轴截距。",
  "entity_model_features.config.variable_explanation.nan": "非数字\n在运行时抛出异常\n用于调试",
  "entity_model_features.config.variable_explanation.pi": "常量值\n3.1415926",
  "entity_model_features.config.variable_explanation.is_using_item": "实体是否正在使用物品,例如玩家用桶右键点击",
  "entity_model_features.config.variable_explanation.is_holding_item_right": "物品是否持有在实体的右手槽位中",
  "entity_model_features.config.variable_explanation.is_holding_item_left": "物品是否持有在实体的左手槽位中",
  "entity_model_features.config.variable_explanation.player_pos": "客户端玩家当前的世界位置",
  "entity_model_features.config.variable_explanation.player_rot": "客户端玩家当前的世界旋转。北为 0",
  "entity_model_features.config.variable_explanation.pos": "实体当前的世界位置",
  "entity_model_features.config.variable_explanation.render_variable": "渲染变量\n render.shadow_size\n - 实体下方阴影的大小\n render.shadow_opacity\n - 阴影的透明度\n render.shadow_offset_x, render.shadow_offset_z\n - 阴影的位置\n  render.leash_offset_x, render.leash_offset_y, render.leash_offset_z\n - 拴绳连接点的位置",
  "entity_model_features.config.variable_explanation.render_variable.title": "渲染变量",
  "entity_model_features.config.variable_explanation.rot": "实体当前的世界旋转。北为 0",
  "entity_model_features.config.variable_explanation.rule_index": "当前匹配的随机模型规则的索引。默认为 0",
  "entity_model_features.config.variable_explanation.swing_progress": "实体攻击进度的完成度。从 0 计数到 1",
  "entity_model_features.config.variable_explanation.time": "总游戏时间(刻),与昼夜周期无关",
  "entity_model_features.config.variable_explanation.true": "常量值\ntrue",
  "entity_model_features.config.models": "所有模型",
  "entity_model_features.config.models.enabled": "启用模型",
  "entity_model_features.config.models.enabled.tooltip": "设置是否加载给定的 .jem 模型文件",
  "entity_model_features.config.models.part_names": "此模型的部件名称",
  "entity_model_features.config.models.export": "将模型导出为 .jem 文件",
  "entity_model_features.config.models.export.tooltip": "将此模型作为 .jem 文件导出到目录 \"MC_DIRECTORY/emf/export\"\n此文件可以在 Blockbench 中打开,并包含自定义模型所需的所有数据\n包括枢轴点、框和 UV\n附加数据也将打印在日志中,例如将此 .jem 文件放在资源包的哪个位置以供使用。",
  "entity_model_features.config.models.export.success": "模型导出成功",
  "entity_model_features.config.models.export.fail": "模型无法导出,原因:",
  "entity_model_features.config.models.arrows": "arrow.jem 和 spectral_arrow.jem 不会出现在这里,但两者都受支持",
  "entity_model_features.config.models.cape": "\nplayer_cape.jem 不会出现在这里,但也受支持,它是 player.jem 的精确副本,但仅包含 'cloak' 部件",
  "entity_model_features.config.variables": "变量",
  "entity_model_features.config.functions": "函数",
  "entity_model_features.config.player_settings": "玩家设置",
  "entity_model_features.config.only_client": "仅修改您自己的玩家模型",
  "entity_model_features.config.only_client.tooltip": "如果启用,这将仅对您自己的玩家应用自定义玩家模型\n在多人游戏中忽略所有其他玩家",
  "entity_model_features.config.math": "动画数学详情",
  "entity_model_features.config.math.explain": "本节提供了可在 EMF 自定义实体模型动画中使用的数学函数和变量的详细信息。\n包括任何使用其 API 从另一个模组添加到 EMF 的内容。\n点击每个函数和变量将提供更多详细信息。",
  "entity_model_features.config.variables.explain": "当前注册的、可用于 EMF 自定义实体模型动画的所有数学变量的列表。\n点击每个变量将提供更多详细信息。",
  "entity_model_features.config.functions.explain": "当前注册的、可用于 EMF 自定义实体模型动画的所有数学函数的列表。\n点击每个函数将提供更多详细信息。",
  "entity_model_features.title": "实体模型特性 (Entity Model Features)",
  "entity_model_features.suffix_property": "模型后缀(可选)\n匹配实体模型被设置到的最后一个随机模型后缀编号\n默认为 0\n示例:modelSuffix.1= 2 4 6\n§amodelSuffix.<n>=<列表>",
  "entity_model_features.rule_property": "模型规则(可选)\n匹配实体模型匹配到的最后一个随机模型规则编号\n默认为 0\n示例:modelRule.1= 2 4 6\n§amodelRule.<n>=<列表>",
  "entity_model_features.var_property": "实体变量 浮点数(可选)\n匹配实体的 CEM 动画变量值\n默认为 0\n示例:(对于动画变量 'var.xyz')var.1.xyz= 2 4 6\n§avar.<n>.<variable>=<列表>",
  "entity_model_features.varb_property": "实体变量 布尔值(可选)\n匹配实体的 CEM 动画变量值\n默认为 false\n示例:(对于动画变量 'varb.xyz')varb.1.xyz=true\n§avarb.<n>.<variable>=<true|false>",
  "entity_model_features.global_var_property": "全局变量 浮点数(可选)\n匹配 CEM 动画全局变量值\n默认为 0\n示例:(对于动画变量 'global_var.xyz')global_var.1.xyz= 2 4 6\n§aglobal_var.<n>.<variable>=<列表>",
  "entity_model_features.global_varb_property": "全局变量 布尔值(可选)\n匹配 CEM 动画全局变量值\n默认为 false\n示例:(对于动画变量 'global_varb.xyz')global_varb.1.xyz=true\n§aglobal_varb.<n>.<variable>=<true|false>",
  "entity_model_features.config.variable_explanation.global_variable": "全局变量的格式为 \"global_var.<name>\" (浮点数) 或 \"global_varb.<name>\" (布尔值)\n名称可以是任何字符串,例如 \"global_var.xyz\", \"global_var.last_rx\" 等。\n该变量是全局保存的,默认值为 0 或 false。\n全局变量对于存储由多个实体使用的动画数据非常有用。",
  "entity_model_features.config.variable_explanation.global_variable.title": "全局变量",
  "entity_model_features.config.variable_explanation.optifine_parts": "OptiFine 部件名称:",
  "entity_model_features.config.variable_explanation.unknown_parts": "未映射的部件名称:",
  "entity_model_features.config.prevent_hand": "阻止第一人称手部动画",

  "entity_model_features.config.reset_player": "每次渲染时重置玩家模型",
  "entity_model_features.config.reset_player.tooltip": "这使得 EMF 在每次渲染之前很久就重置玩家模型的所有原版部件变换。\n仅当玩家存在自定义模型时适用。\n这不是典型的行为,但是考虑到许多模组会改变玩家动画,\n此设置大大降低了模组和动画包之间玩家动画兼容性的难度。\n例如:玩家表情模组。\n这种兼容性仍然需要资源包制作者的努力。",
  "entity_model_features.config.models.file_names": "文件名称和位置",
  "entity_model_features.config.prevent_hand.tooltip": "如果启用,这将强制阻止所有自定义 EMF 动画在第一人称手部模型上播放",
  "entity_model_features.config.models_text": "这些都是可通过 EMF 修改的模型\n这些屏幕将仅显示/导出有关这些模型未修改状态的信息\n如果您想查看模型的当前状态,您必须在游戏中查看模型",
  "entity_model_features.config.ebe_warn.1": "一些 EBE 模组选项已被 EMF 强制禁用",
  "entity_model_features.config.ebe_warn.2": "发生这种情况是因为资源包正在为该方块实体加载自定义模型",
  "entity_model_features.config.ebe_warn.3": "当前禁用的选项:",
  "entity_model_features.config.ebe_warn.4": "这可以在 EMF 的模型设置中更改",
  "entity_model_features.config.variation_base": "要求变体存在基础模型",
  "entity_model_features.config.variation_base.tooltip": "在 OptiFine 中,最佳实践是要求变体存在一个'基础'模型,因为这在 OptiFine 中可能非常不一致。启用此设置将意味着如果没有 'pig.jem','pig2.jem' 将不会产生变体。\nEMF 不要求这样做,但如果在此启用,它将强制执行,因为最好尽可能保持 OptiFine 兼容性。\n您可以通过在 EMF 设置中通过 '模型 > 所有模型 > *模型* > 导出' 来轻松获得默认模型。\n或者只需禁用此设置。",
  "entity_model_features.config.double_chest_fix": "修复双箱模型日志错误",
  "entity_model_features.config.double_chest_fix.tooltip": "因为双箱模型 'chest_large.jem' 必须在代码中拆分为 2 个半模型,\n所以可能会有关于缺失左/右半部分的过多日志垃圾信息。\n如果启用,此选项将修复此问题,并且还会部分修复引用箱子另一侧的动画。\n仍然强烈建议您将左半部分和右半部分的动画分开。\n这是一个选项,因为影响箱子模型的其他模组可能会与此产生问题。",
  "entity_model_features.config.iris_shadow_skip": "跳过 Iris 阴影通道的动画",
  "entity_model_features.config.iris_shadow_skip.tooltip": "这将使得实体模型不会每帧为渲染和 Iris 阴影通道各动画一次\n这应该始终保持开启,仅在此处以防\n未来 Iris API 发生破坏性更改"
}