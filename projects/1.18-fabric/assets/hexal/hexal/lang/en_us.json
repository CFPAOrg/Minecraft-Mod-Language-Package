{
  "block.hexal.slipway": "Slipway",

  "entity.hexal.wisp.projectile": "Projectile Wisp",
  "entity.hexal.wisp.ticking": "Cyclic Wisp",
  "entity.hexal.wisp.wandering": "Wandering Wisp",

  "hexcasting.mishap.non_player": "%s expected to be cast by a player.",
  "hexcasting.mishap.no_wisp": "%s expected to be cast by a wisp.",
  "hexcasting.mishap.others_wisp": "That wisp is owned by %s, not you.",
  "hexcasting.mishap.no_links": "%s has no links.",
  "hexcasting.mishap.self_link": "Tried to link %s to itself.",

  "hexcasting.mishap.invalid_value.class.type.list.double": "a list of numbers",
  "hexal.mishap.invalid_value.vecitem": "a vector or item entity",


  "hexcasting.spell.hexal:compare/blocks": "Surveyor's Distillation",
  "hexcasting.spell.hexal:compare/entities": "Physician's Distillation",
  "hexcasting.spell.hexal:compare/types": "Classifier's Distillation",

  "hexcasting.spell.hexal:current_tick": "Timekeeper's Reflection",
  "hexcasting.spell.hexal:remaining_evals": "Thanatos' Reflection",
  "hexcasting.spell.hexal:breath": "Diver's Purification",
  "hexcasting.spell.hexal:health": "Nurse's Purification",
  "hexcasting.spell.hexal:light_level": "Lamplighter's Purification",

  "hexcasting.spell.hexal:factorial": "Factorial Purification",
  "hexcasting.spell.hexal:running/sum": "Running Sum Purification",
  "hexcasting.spell.hexal:running/mul": "Running Product Purification",

  "hexcasting.spell.hexal:everbook/read": "Mnemosyne's Gambit",
  "hexcasting.spell.hexal:everbook/write": "Elysium's Gambit",
  "hexcasting.spell.hexal:everbook/delete": "Lethe's Gambit",
  "hexcasting.spell.hexal:everbook/toggle_macro": "Brigh's Gambit",

  "hexcasting.spell.hexal:smelt": "Smelt",
  "hexcasting.spell.hexal:freeze": "Freeze",
  "hexcasting.spell.hexal:falling_block": "Falling Block",

  "hexcasting.spell.hexal:wisp/summon/projectile": "Summon Projectile Wisp",
  "hexcasting.spell.hexal:wisp/summon/ticking": "Summon Cyclic Wisp",
  "hexcasting.spell.hexal:wisp/media": "Reservoir Reflection",
  "hexcasting.spell.hexal:wisp/hex": "Manager's Purification",
  "hexcasting.spell.hexal:wisp/owner": "Allegiance Distillation",
  "hexcasting.spell.hexal:wisp/move/target/set": "Pathfinder's Gambit",
  "hexcasting.spell.hexal:wisp/move/target/get": "Pathfinder's Reflection",
  "hexcasting.spell.hexal:wisp/move/speed/set": "Haste",
  "hexcasting.spell.hexal:wisp/move/speed/get": "Speedometer's Reflection",
  "hexcasting.spell.hexal:wisp/trigger/tick": "Delay Wisp",
  "hexcasting.spell.hexal:wisp/trigger/comm": "Listen",
  "hexcasting.spell.hexal:wisp/trigger/move": "Wander",
  "hexcasting.spell.hexal:wisp/consume": "Consume Wisp",
  "hexcasting.spell.hexal:wisp/seon/set": "Bind Wisp",
  "hexcasting.spell.hexal:wisp/seon/get": "Familiar's Reflection",

  "hexcasting.spell.hexal:get_entity/wisp": "Entity Purification: Wisp",
  "hexcasting.spell.hexal:zone_entity/wisp": "Zone Distillation: Wisp",
  "hexcasting.spell.hexal:zone_entity/not_wisp": "Zone Distillation: Non-Wisp",

  "hexcasting.spell.hexal:link/link_entity": "Link Entity",
  "hexcasting.spell.hexal:link/link_two_entities": "Link Entities",
  "hexcasting.spell.hexal:link/unlink": "Unlink",
  "hexcasting.spell.hexal:link/get": "Phonebook Purification",
  "hexcasting.spell.hexal:link/get_index": "Recognition Purification",
  "hexcasting.spell.hexal:link/num": "Popularity Reflection",

  "hexcasting.spell.hexal:link/comm/send": "Send Iota",
  "hexcasting.spell.hexal:link/comm/read": "Recitation Reflection",
  "hexcasting.spell.hexal:link/comm/num": "Postmaster's Reflection",
  "hexcasting.spell.hexal:link/comm/open_transmit": "Open Transmit",
  "hexcasting.spell.hexal:link/comm/close_transmit": "Close Transmit",



  "hexcasting.spell.book.hexal:light_level": "Lamplighter's Prfn.",

  "hexcasting.spell.book.hexal:running/sum": "Running Sum Prfn.",
  "hexcasting.spell.book.hexal:running/mul": "Running Product Prfn.",

  "hexcasting.spell.book.hexal:get_entity/wisp": "Entity Prfn.: Wisp",
  "hexcasting.spell.book.hexal:zone_entity/wisp": "Zone Dstl.: Wisp",
  "hexcasting.spell.book.hexal:zone_entity/not_wisp": "Zone Dstl.: Non-Wisp",




  "hexal.entry.slipways": "Slipways",
  "hexal.page.slipways": "I have heard tales of some geodes in which glowing portals called slipways lie. These slipways are regularly depicted with glowing sparks surrounding them that bear an incredible resemblance to the $(l:hexal:patterns/spells/wisps)$(thing)wisps/$ that I have heard tell of, which may be a connection to look into.",


  "hexal.entry.hexal_basics": "Hexal Basic Patterns",
  "hexal.page.hexal_basics.current_tick": "Adds a number to the stack which seems to be related to how Nature represents time; If I cast the pattern, then cast the same pattern a second later, the number it adds has increased by 20.",
  "hexal.page.hexal_basics.remaining_evals": "Adds the number of evaluations a hex is still capable of to the stack. This is reduced by $(l:patterns/meta#hexcasting:eval)$(action)Hermes' Gambit/$ and $(l:patterns/meta#hexcasting:for_each)$(action)Thoth's Gambit/$.",
  "hexal.page.hexal_basics.breath": "Removes a Living entity from the stack and returns how much breath it has left (i.e., how close it is to drowning).",
  "hexal.page.hexal_basics.health": "Removes a Living entity from the stack and returns how much health it has left (i.e., how close it is to dying).",
  "hexal.page.hexal_basics.light_level": "Removes a position vector from the stack and returns the light level at that position.",

  "hexal.entry.hexal_maths": "Hexal Maths",
  "hexal.page.hexal_maths.factorial": "Removes a number from the stack and computes its factorial, for example inputting 4 would return 4*3*2*1=24.",
  "hexal.page.hexal_maths.running/sum": "Takes a list from the stack and computes its running sum, for example inputting [1,2,5] would return [1,3,8].",
  "hexal.page.hexal_maths.running/mul": "Takes a list from the stack and computes its running product, for example inputting [1,2,5] would return [1,2,10].",

  "hexal.entry.hexal_spell": "Hexal Spells",
  "hexal.page.hexal_spell.smelt.0": "Remove a location or item entity from the stack, then either smelt the block at the location or smelt all the items in the item entity.",
  "hexal.page.hexal_spell.smelt.1": "Costs three quarters of an $(l:items/amethyst)$(item)Amethyst Dust/$ per item smelted (i.e. three quarters of an $(l:items/amethyst)$(item)Amethyst Dust/$ for smelting a block, 6 $(l:items/amethyst)$(item)Amethyst Dust/$ to smelt a stack of 8 items.)",
  "hexal.page.hexal_spell.freeze": "Freezes the block at a block location. For example, turns water into ice, and ice into packed ice. Costs three $(l:items/amethyst)$(item)Amethyst Dust/$.",
  "hexal.page.hexal_spell.falling_block": "Remove a location from the stack, and force the block there to fall as if it were sand or gravel. Costs one and a half $(l:items/amethyst)$(item)Amethyst Dust/$.",

  "hexal.entry.wisps": "Wisps",
  "hexal.page.wisps.0": "I have discovered a way to create constructs from the media itself, visible to others and able to move and act somewhat on their own. They are able to cast hexes in my place, similar to how a $(l:patterns/meta#hexcasting:eval)$(action)Hermes' Gambit/$ evaluates patterns. They do take some of my attention to operate this however, and if too many try and execute at once I will only be able to run some of them, leaving the rest for the next instant.",
  "hexal.page.wisps.1": "When they are created I assign them a 'reservoir' of media that they have access to, which is taken from me and used to form the wisp. A wisp uses up part of its reservoir simply existing, and when it evaluates the pattern list it is carrying any costs incurred are removed from its reservoir. All wisps seem to take three $(l:items/amethyst)$(item)Amethyst Dust/$ to summon, in addition to whatever media is used for their reservoir.",
  "hexal.page.wisps.wisp/summon/projectile.0": "This wisp is summoned and launched like an arrow, casting its hex on whatever it hits. The initial stack when it executes will be a reference to itself, then a reference to what it hit.",
  "hexal.page.wisps.wisp/summon/projectile.1": "This could be a block position or an entity reference. The first vector accepted is the location the wisp will be summoned, while the direction of the second is the direction the wisp will be launched, and the second's magnitude seems to affect the wisp's velocity. The cost of the spell increases with the squared magnitude of velocity. The number accepted determines the wisp's reservoir in $(l:items/amethyst)$(item)Amethyst Dust/$. It loses one $(l:items/amethyst)$(item)Amethyst Dust/$ of media every second once summoned, and has a range of influence of 4 blocks.",
  "hexal.page.wisps.wisp/summon/ticking.0": "Similar to Summon Projectile Wisp, but with only one vector input for the position to summon the wisp. Cyclic wisps are unmoving once summoned, instead executing their hex up to 20 times each second.",
  "hexal.page.wisps.wisp/summon/ticking.1": "The first time it casts the stack will start with a reference to itself, from which point it will always start with the stack and ravenmind in the state they finished on the last cast. This wisp has a less stable form making it lose significantly more media every second, losing one $(l:items/amethyst)$(item)Amethyst Dust/$ per second once summoned, as well as an amount proportional to the amount remaining. It has a range of influence of 8 blocks.",
  "hexal.page.wisps.wisp/media": "Add the amount of media in the wisp's reservoir to the stack. This must be cast by a wisp; trying to cast it through a staff will fail rather spectacularly.",
  "hexal.page.wisps.wisp/hex": "Removes a reference to a wisp from the stack, and replaces it with the wisp's contained hex. Must be a wisp you summoned.",
  "hexal.page.wisps.wisp/owner": "Removes a reference to a wisp and an entity from the stack, and returns one if that entity owns that wisp, and a zero otherwise.",
  "hexal.page.wisps.wisp/move/target/set": "Removes a position vector from the stack; The Cyclic Wisp that executed this pattern will move in a straight line towards that position (colliding with terrain in its path) until it reaches it.",
  "hexal.page.wisps.wisp/move/target/get": "Adds to the stack the position vector that the executing Cyclic Wisp is currently moving towards.",
  "hexal.page.wisps.wisp/move/speed/set": "Removes a number from the stack, and sets the executing Cyclic Wisp's maximum speed to that number.",
  "hexal.page.wisps.wisp/move/speed/get": "Gets the executing Cyclic Wisp's current maximum speed.",
  "hexal.page.wisps.get_entity/wisp": "Transform the position on the stack into the wisp at that location (or $(l:casting/influences)$(thing)Null/$ if there isn't one).",
  "hexal.page.wisps.zone_entity/wisp": "Take a position and maximum distance on the stack, and combine them into a list of wisps near the position.",
  "hexal.page.wisps.zone_entity/not_wisp": "Take a position and maximum distance on the stack, and combine them into a list of non-wisp entities near the position.",
  "hexal.page.wisps.wisp/trigger/tick": "Removes an integer from the stack, then delays the wisp's next cast until at least that many twentieth's of a second have passed.",
  "hexal.page.wisps.wisp/trigger/comm": "The wisp's next cast will not occur until it has received at least one $(l:hexal:patterns/spells/links#hexal:link/comm/send)$(action)communication/$.",
  "hexal.page.wisps.wisp/trigger/move": "The wisp's next cast will not occur until it has reached the position it is $(l:hexal:patterns/spells/wisps#hexal:wisp/move/target/set)$(action)navigating/$ towards.",

  "hexal.entry.links": "Links",
  "hexal.page.links.0": "These patterns outline a system that I have found for communicating information from one $(l:hexal:patterns/spells/wisps)$(thing)wisp/$ to another, among other things. There are a number of patterns related to creating these links that are able to transmit information, and a number of patterns related to sending and receiving iotas over a link once it is created. A wisp can have any number of links active, with each costing a negligible amount of media to maintain each twentieth of a second.",
  "hexal.page.links.1": "As links are created connected to a wisp that wisp will assign an order to them, based on the order which they were created, which is used to reference the links in a number of patterns. Unless otherwise stated, these patterns must be evaluated by a wisp, with unpleasant consequences if I try to evaluate them myself.",
  "hexal.page.links.link/link_entity": "Links the casting wisp to the entity removed from the stack, which must be linkable. This costs one $(l:items/amethyst)$(item)Amethyst Shard/$.",
  "hexal.page.links.link/link_two_entities": "May be evaluated by any casting instrument. Links two entities, which must be linkable. This costs one $(l:items/amethyst)$(item)Amethyst Shard/$.",
  "hexal.page.links.link/unlink": "Removes the link at the given index from the casting wisp's links. This costs two $(l:items/amethyst)$(item)Amethyst Dust/$.",
  "hexal.page.links.link/get": "Removes an index from the stack, and adds the entity connected to the link at that index to the stack.",
  "hexal.page.links.link/get_index": "Removes an entity from the stack, and adds the index to the link to that entity to the stack (or -1 if the wisp isn't linked to that entity).",
  "hexal.page.links.link/num": "Adds the number of links to the wisp to the stack.",
  "hexal.page.links.link/comm/send": "Removes an iota from the stack, then removes an index from the stack and sends the iota along the link at the given index.  This costs one hundredth of an $(l:items/amethyst)$(item)Amethyst Dust/$.",
  "hexal.page.links.link/comm/read": "When a wisp receives an iota along a link it is added to a queue. This pattern adds the first iota in the queue to the stack, removing it from the queue.",
  "hexal.page.links.link/comm/num": "Adds to the stack the number of unread iota in the wisp's received iota queue.",
  "hexal.page.links.link/comm/open_transmit": "Similar to $(l:patterns/patterns_as_iotas#hexcasting:open_paren)$(action)Introspection/$, until drawing a $(l:hexal:patterns/spells/links#hexal:link/comm/close_transmit)$(action)Close Transmit/$ all patterns I draw are sent along the link whose index is at the top of the stack.",
  "hexal.page.links.link/comm/close_transmit": "When drawn after $(l:hexal:patterns/spells/links#hexal:link/comm/open_transmit)$(action)Open Transmit/$ I stop transmitting drawn patterns. If either $(l:hexal:patterns/spells/links#hexal:link/comm/open_transmit)$(action)Open Transmit/$ or $(l:hexal:patterns/spells/links#hexal:link/comm/close_transmit)$(action)Close Transmit/$ are executed by an intermediary caster such as a wisp, they will mishap.",

  "hexal.entry.great_wisps": "Great Wisp Spells",
  "hexal.page.great_wisps.wisp/consume.0": "Remove a wisp from the stack, and disassemble the wisp. The patterns contained are lost, but the media that it contained can be repurposed if this spell is cast by another wisp.",
  "hexal.page.great_wisps.wisp/consume.1": "Costs either an $(l:items/amethyst)$(item)Amethyst Crystal/$ if the wisp is owned by you, or half again as much media as the consumed wisp contains if the wisp is owned by another. Repurposing the media is not completely efficient, losing one twentieth of the consumed wisp's reserve in transfer.",
  "hexal.page.great_wisps.wisp/seon/set": "Bind one of my wisps closer to me; I may only have one bound wisp at a time, but whichever wisp is bound costs significantly less upkeep.",
  "hexal.page.great_wisps.wisp/seon/get": "Returns my currently bound wisp. (This is not a great spell, I have simply placed it here for convenience.)",

  "hexal.entry.type_comparison": "Type Comparisons",
  "hexal.page.type_comparison.compare/blocks": "Remove two locations from the stack; if the block at the first is equal to the block at the second, return 1. Otherwise, return 0.",
  "hexal.page.type_comparison.compare/entities": "Remove two entities from the stack; if the entities are the same type (with items comparing the type of item) return 1. Otherwise, return 0.",
  "hexal.page.type_comparison.compare/types": "Remove two iota from the stack; if iota are the same type, return 1. Otherwise, return 0. For example, removing 0 and 5 would return 1, as would removing [] and [12], while removing 1 and (1,2,3) would return 0.",




  "hexal.entry.everbook": "Everbook",
  "hexal.page.everbook.0": "Your Everbook is a strange space that your broken mind can now reach. There are many yous that seem to share this record, worlds and worlds of progress, beginning again and again. Your Everbook can store patterns paired with iotas like an $(l:hexcasting:greatwork/akashiclib)$(item)Akashic Record/$, though the fragile nature of your mind these days makes it best to route all access to your Everbook through an $(l:hexcasting:greatwork/akashiclib)$(item)Akashic Record/$. Any world that you reach enlightenment in, you will have access to the entries you add to it now.",
  "hexal.page.everbook.everbook/read": "Takes the position of an $(l:hexcasting:greatwork/akashiclib)$(item)Akashic Record/$, as well as a Pattern as a key, and retrieves the iota at that key from your Everbook, storing it in the given $(l:hexcasting:greatwork/akashiclib)$(item)Akashic Record/$ if able.",
  "hexal.page.everbook.everbook/write": "Takes the position of an $(l:hexcasting:greatwork/akashiclib)$(item)Akashic Record/$, as well as a Pattern as a key, and stores the iota in that record at that key to your Everbook at the same key.",
  "hexal.page.everbook.everbook/delete": "Takes a pattern and removes the entry with that pattern key from your Everbook.",
  "hexal.page.everbook.everbook/toggle_macro.0": "Takes a pattern and marks that entry of your Everbook as a Pattern that when drawn by your hand will be treated as any other of Nature's patterns.",
  "hexal.page.everbook.everbook/toggle_macro.1": "When you draw the key of an Everbook entry that has been marked as a Pattern, if that entry is a list Nature will execute each element of the list as it would with $(l:patterns/meta#hexcasting:eval)$(action)Hermes' Gambit/$, though it does not use up an evaluation. Attempting to mark an entry as a Pattern if it is non-existent or infinitely recursive will fail.",

  "hexal.entry.everbook_entries": "Everbook Entries",
  "hexal.page.everbook_entries.0": "Every page in this entry displays the pattern key for one of the entries of your $(l:hexal:patterns/everbook)$(action)Everbook/$.",

  "hexal.everbook_pattern_entry.header": "Stored Key: %d",
  "hexal.everbook_pattern_entry.macro_header": "Macro Key: %d"
}