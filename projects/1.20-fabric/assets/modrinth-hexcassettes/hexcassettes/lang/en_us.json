{
	"advancements.hexcassettes.quinio.title": "QUINIO",
	"advancements.hexcassettes.quinio.description": "Make a Hex cast a Hex.",
	"advancements.hexcassettes.tape_worm.title": "Tape Worm?",
	"advancements.hexcassettes.tape_worm.description": "Consume a cassette tape.",
	"advancements.hexcassettes.full_arsenal.title": "Full Album",
	"advancements.hexcassettes.full_arsenal.description": "Acquire a full arsenal of cassettes.",
	"key.categories.hexcassettes": "Hexcassettes",
	"key.hexcassettes.view_cassettes": "Ponder Cassettes",
	"hexcasting.mishap.invalid_value.hex_or_index": "a Hex or an index for the cassette",
	"item.hexcassettes.cassette": "Cassette",
	"screen.hexical.cassette": "Cassettes",
	"subtitles.hexcassettes.cassette_eject": "Cassette ejects",
	"subtitles.hexcassettes.cassette_fail": "Cassette clicks",
	"subtitles.hexcassettes.cassette_insert": "Cassette inserted",
	"subtitles.hexcassettes.cassette_loop": "Cassette whirrs",

	"hexcasting.mishap.hexcassettes:no_free_cassettes": "Could not find any free cassette to queue a Hex into.",
	"hexcasting.mishap.hexcassettes:not_enough_cassettes": "Attempted to queue a Hex into a cassette index I do not have.",

	"hexcassettes.page.async.title": "Asynchronous Hexes",
	"hexcassettes.page.async.0": "As part of their nature, _Hexes evaluate in their entirety in one instant. To postpone _Hexes for later, Nature has devised quite the whimsical solution: a $(item)Cassette Tape$() that must be crafted and then \"consumed\". I may have up to six at any time. Each one holds a _Hex I requested to delay until that _Hex is ready to cast. After casting, the $(thing)Cassette$() becomes free to hold other _Hexes.",
	"hexcassettes.page.async.craft": "After plating a $(item)Music Disc$() with a hefty amount of $(item)$(l:items/amethyst)Charged Amethyst$() to enable the $(o)abstraction$(), I can $(o)consume$() my glorious creation using a combination of magic, willpower, and a lot of chewing to add it to my mind's collection.",
    "hexcasting.action.hexcassettes:enqueue": "Enqueue",
	"hexcassettes.page.enqueue.summary.0": "Enqueues a _Hex to cast after that many twentieths of a second. Queues it into the first free $(thing)Cassette$() or the current $(thing)Cassette$() and pushes the index of that $(thing)Cassette$().",
	"hexcassettes.page.async.1": "The index number is used to distinguish $(thing)Cassettes$() from each other. It ranges from 0 to one less than the number of $(thing)Cassettes$() I have in my mind's collection. If $(l:async#hexcassettes:enqueue)$(action)Enqueue$() can not find a free $(thing)Cassette$(), incurs the Parallel Processing mishap, killing all my active $(thing)Cassettes$().$(br2)Seems to hint that my reality has a disturbingly low $(o)temporal resolution$().. best not to dwell on that.$(br2)$(o)Ibra oniki ra. QUINIO QUINIO QUINIO QUINIO alef a ra.$()",
    "hexcassettes.page.async.2": "I can ponder my $(thing)Cassettes$() by pressing $(thing)$(k:hexcassettes.view_cassettes)$() and cycle through them with the arrow keys. Queued _Hexes are represented as inserted $(thing)Cassettes$() with their label rendered to the side, and by pressing an $(thing)Cassette$(), I can cancel the corresponding _Hex.$(br2)Dying also forcibly disqueues all of my $(thing)Cassettes$(). I can rest easy that I will not trap myself in an endless death cycle.",
	"hexcassettes.page.async.3": "If a $(thing)Cassette$() enqueues a near-identical copy of itself, a phenomenon emerges that ancient _Hexcasters call a daemon: passive, constant _Hexcasting. Study into this branch of _Hexcasting seems limited due to the great danger of manipulating time: $(thing)Cassette$() _Hexes exclusively use the _media from my inventory. If left unchecked, it can easily drain my _media and then my life.",
    "hexcasting.action.hexcassettes:dequeue": "Dequeue",
    "hexcassettes.page.dequeue.summary": "Dequeues the $(thing)Cassette$() at the provided index, freeing it instantly and cancelling the _Hex within it.",
	"hexcasting.action.hexcassettes:killall": "Disqueue",
	"hexcassettes.page.killall.summary": "Dequeues all $(thing)Cassettes$(). Useful for ouroboros-like _Hexes that bypass regular dequeuing via two mutually resurrecting $(thing)Cassettes$().",
	"hexcasting.action.hexcassettes:specs": "Threading Reflection",
	"hexcassettes.page.specs.summary": "Pushes the total number of $(thing)Cassettes$() that I have in my mind's collection.",
	"hexcasting.action.hexcassettes:free": "Idling Reflection",
	"hexcassettes.page.free.summary": "Pushes a list of the indices of my non-busy $(thing)Cassettes$().",
	"hexcasting.action.hexcassettes:inspect": "Program Purification",
	"hexcassettes.page.inspect.summary": "Pushes $(l:casting/influences)$(thing)Null$() if I do not have an active $(thing)Cassette$() at that index, or the $(thing)Cassette$()'s _Hex if I do. I hear rumors of this being used for iota storage and passing information between _Hexes.",
	"hexcasting.action.hexcassettes:foretell": "Oracle Purification",
	"hexcassettes.page.foretell.summary": "Pushes $(l:casting/influences)$(thing)Null$() if I do not have an active $(thing)Cassette$() at that index, or how many twentieths of a second until that $(thing)Cassette$() fires if I do.",
    "hexcassettes.page.enqueue.summary.1": "A variant of $(l:async#hexcassettes:enqueue)$(action)Enqueue$() that takes an index right after the _Hex. It will force that $(thing)Cassette$()'s _Hex to the new one, regardless if one exists.",
	"hexcassettes.page.async.4": "If that index does not exist, incurs the Memory Overflow mishap, killing all my active $(thing)Cassettes$().",
	"hexcasting.action.hexcassettes:self": "State Reflection",
	"hexcassettes.page.self.summary": "Pushes the current index of the $(thing)Cassette$() this _Hex is running in or $(l:casting/influences)$(thing)Null$() if it is not running in a $(thing)Cassette$()."
}