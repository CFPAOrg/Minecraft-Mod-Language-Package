{
  "complexhex.entry.complexities": "Complexities",
  "hexcasting.action.complexhex:const/complex/i": "Constant Imagination",
  "complexhex.page.complexities.const.i": "Pushes 0 + 1i to the stack.",
  "hexcasting.action.complexhex:const/complex/1": "Constant Realisation",
  "complexhex.page.complexities.const.1": "Pushes 1 + 0i to the stack.",
  "complexhex.page.complexities.add": "Performs Addition, num will be treated as num + 0i.",
  "complexhex.page.complexities.sub": "Performs Subtraction, num will be treated as num + 0i.",
  "complexhex.page.complexities.mul": "Performs Multiplication",
  "complexhex.page.complexities.div": "Performs Scalar Division.",
  "complexhex.page.complexities.abs": "Pushes the Argument (the length).",
  "complexhex.page.complexities.pow": "Performs Exponentiation.",
  "hexcasting.action.complexhex:real": "Realising Complexities",
  "complexhex.page.complexities.real": "Pushes the real coefficient.",
  "hexcasting.action.complexhex:imaginary": "Imagining Complexities",
  "complexhex.page.complexities.imaginary": "Pushes the imaginary coefficient.",
  "hexcasting.action.complexhex:conjugate": "Conjugation Prfn.",
  "complexhex.page.complexities.conjugate": "Negates the imaginary coefficient of the topmost iota",

  "complexhex.entry.quaternionics": "Quaternionics",
  "hexcasting.action.complexhex:qmake": "Quaternionic Exal.",
  "complexhex.page.quaternionics.qmake": "Pushes a Quaternion with num as the real coefficient and the vector's x, y, & z as the coefficients of i, j & k respectively.",
  "hexcasting.action.complexhex:qunmake": "Quaternionic Dntg.",
  "complexhex.page.quaternionics.qunmake": "Pushes the real coefficient and a vector where the x, y, & z components are the coefficients of i, j, & k respectively.",
  "hexcasting.action.complexhex:const/quaternion/1": "Quaternionic Rfln.: 1",
  "complexhex.page.quaternionics.const.1": "Pushes 1 + 0i + 0j + 0k to the stack.",
  "hexcasting.action.complexhex:const/quaternion/i": "Quaternionic Rfln.: i",
  "complexhex.page.quaternionics.const.i": "Pushes 0 + 1i + 0j + 0k to the stack.",
  "hexcasting.action.complexhex:const/quaternion/j": "Quaternionic Rfln: j",
  "complexhex.page.quaternionics.const.j": "Pushes 0 + 0i + 1j + 0k to the stack.",
  "hexcasting.action.complexhex:const/quaternion/k": "Quaternionic Rfln: k",
  "complexhex.page.quaternionics.const.k": "Pushes 0 + 0i + 0j + 1k to the stack.",
  "complexhex.page.quaternionics.add": "Performs Addition",
  "complexhex.page.quaternionics.sub": "Performs Subtraction",
  "complexhex.page.quaternionics.mul": "Performs Multiplication, Scalar if a num & quat are given, Hamiltonian if 2 quaternions are given.",
  "complexhex.page.quaternionics.div": "Performs Scalar Division.",
  "complexhex.page.quaternionics.abs": "Pushes the Argument (the length).",
  "hexcasting.action.complexhex:qw": "Quaterionic Prfn.: 1",
  "complexhex.page.quaternionics.qw": "Pushes the coefficient of 1.",
  "hexcasting.action.complexhex:qx": "Quaterionic Prfn.: i",
  "complexhex.page.quaternionics.qx": "Pushes the coefficient of i.",
  "hexcasting.action.complexhex:qy": "Quaterionic Prfn.: j",
  "complexhex.page.quaternionics.qy": "Pushes the coefficient of j.",
  "hexcasting.action.complexhex:qz": "Quaterionic Prfn: k",
  "complexhex.page.quaternionics.qz": "Pushes the coefficient of k.",
  "hexcasting.action.complexhex:qinvert": "Quaternionic Inverse",
  "complexhex.page.quaternionics.qinvert": "Negates the coefficients of i, j, & k",
  "hexcasting.action.complexhex:quattomat": "Matrixification",
  "complexhex.page.quaternionics.quattomat": "Pushes a matrix that (should) represent the same rotation as the quaternion",
  "hexcasting.action.complexhex:mattoquat": "Quaterniation",
  "complexhex.page.quaternionics.mattoquat": "Pushes a quaternion that (should) reperesent the same rotation as the matrix",
  "hexcasting.action.complexhex:axisangle": "Axis Angle Distillation",
  "complexhex.page.quaternionics.axisangle": "Pushes a quaternion that reperesents a rotation by the given angle num radias around the given vector.",

  "complexhex.tooltip.bubble_contents": "{%s}",
  "complexhex.entry.bubble": "Bubbles",
  "hexcasting.action.complexhex:bubble": "Bubbles' Purification",
  "complexhex.page.bubble": "Pushes a Bubbled Iota, which when popped via execution (by Hermes' or the likes), will push the contained iota to the stack.",

  "complexhex.entry.bits": "BIT Manipulation",
  "complexhex.page.bitexplainer": "These are patterns to manipulate Block, Item, and Text Displays (BITs for short).$(br2)Oddly, Scout's Distillation does not seem to work on these, thus I must depend on Entity Prfn. or Zone Dstn.",
  "hexcasting.action.complexhex:summonblockdisplay": "Summon Block Display",
  "complexhex.page.summonblockdisplay": "Summons a Block Display entity at the given position, displaying the given block. (The string must be the internal name i.e \"minecraft:dirt\", not \"Dirt\").$(br)Costs about a $(l:items/amethyst)$(item)Charged Amethyst/$",
  "hexcasting.action.complexhex:summonitemdisplay": "Summon Item Display",
  "complexhex.page.summonitemdisplay": "Summons an Item Display entity at the given position, displaying the given item (The string must be the internal name i.e \"minecraft:stick\", not \"Stick\").$(br)Costs about a $(l:items/amethyst)$(item)Charged Amethyst/$",
  "hexcasting.action.complexhex:summontextdisplay": "Summon Text Display",
  "complexhex.page.summontextdisplay": "Summons a Text Display entity at the given position, displaying the given string. Costs about a $(l:items/amethyst)$(item)Charged Amethyst/$",
  "hexcasting.action.complexhex:get_entity/bit": "Entity Purification: BIT",
  "complexhex.page.get_entity/bit": "Transform the position on the stack into the BIT at that location (or $(l:casting/influences)$(thing)Null/$ if there isn't one)",
  "hexcasting.action.complexhex:zone_entity/bit": "Zone Distillation: BIT",
  "complexhex.page.zone_entity/bit": "Take a position and a maximum distance on the stack, and combine them into a list of BIT's near the position.",
  "hexcasting.action.complexhex:zone_entity/not_bit": "Zone Distillation: Not BIT",
  "complexhex.page.zone_entity/not_bit": "Take a position and a maximum distance on the stack, and combine them into a list of non-BIT's near the position.",
  "hexcasting.action.complexhex:translatebit": "Translate BIT",
  "complexhex.page.translatebit": "Translates the BIT to the given offset.",
  "hexcasting.action.complexhex:rotatebit": "Rotate BIT",
  "complexhex.page.rotatebit": "Rotates the BIT to the given Quaternion.",
  "hexcasting.action.complexhex:scalebit": "Scale BIT",
  "complexhex.page.scalebit": "Scales the BIT to the given vector.",
  "hexcasting.action.complexhex:killbit": "Kill BIT",
  "complexhex.page.killbit": "Kills & removes the given BIT.",

  "complexhex.mishap.bad_string.blockid": "a blockID",
  "complexhex.mishap.bad_string.itemid": "an itemID",
  "hexcasting.mishap.bad_string": "needs %s but got %s",
  "hexcasting.mishap.invalid_value.class.quaternion": "a quaternion",
  "hexcasting.mishap.invalid_value.class.complexnumber": "a complex number",
  "hexcasting.mishap.invalid_value.class.bubble": "a bubble",
  "hexcasting.mishap.invalid_value.class.bit": "a BIT",
  "hexcasting.mishap.invalid_value.class.long": "a long",
  "hexcasting.mishap.invalid_value.not_char": "a single character",
  "hexcasting.mishap.invalid_value.char_or_num": "a single character or a number",
  "hexcasting.mishap.bad_item.bit": "a BIT",

  "complexhex.category.maths": "Complex Mathematics",
  "complexhex.category.maths.desc": "This is a collection of transcripts from a (now defunct) \"Mathematics Corps\". I'm not sure what use these have, but I $(o)would$() like to know what the researchers were on whilst writing them. ",

  "complexhex.entry.longs": "Longs",
  "complexhex.page.longs.intro": "Whilst normal numbers in the form of $(l:patterns/numbers)doubles$() are extremely useful in all sorts of cases, there come many times where they're just not precise enough.$(br) To this end, $(thing)longs$() are used. Despite their limitations (such as only storing integers, and a lower maximum value), longs are still useful due to this granularity, each bit of them can be manipulated freely without worry for imprecision.",
  "hexcasting.action.complexhex:long": "Long Reflection",
  "complexhex.page.longs.special": "Just like with normal numbers, Nature is not so generous as to make this easy for us.$(br)(Details on next page)",
  "complexhex.page.longs.special.explanation": "Thankfully, what each angle does to the count is very similar to the norm, the only differences being: $(li)a sharp left will shift the bits in the count to the left (effectively doubling them) $(li)a sharp right will shift the bits in the count to the right (effectively halving them*)$(p)$(p)* Due to a long's inability to contain a decimal, the value will always be rounded down.",
  "complexhex.page.longs.example.43.header": "Example: 43L",
  "complexhex.page.longs.example.43": "This pattern pushes 43L: (10 + 10 + 1) * 2 + 1 = 43",
  "hexcasting.action.complexhex:long/convert": "Long Purification",
  "complexhex.page.longs.convert": "Converts between $(l:patterns/numbers)doubles$() and $(thing)longs$()$(br)Always truncates the value when converting to long",
  "complexhex.page.longs.add": "Perform Addition",
  "complexhex.page.longs.sub": "Perform Subtraction",
  "complexhex.page.longs.mul": "Perform Multiplication",
  "complexhex.page.longs.div": "Perform Floored Division",
  "complexhex.page.longs.and": "Perform Bitwise AND",
  "complexhex.page.longs.or": "Perform Bitwise OR",
  "complexhex.page.longs.not": "Perform Bitwise NOT",
  "complexhex.page.longs.xor": "Perform Bitwise XOR",
  "hexcasting.action.complexhex:shift/left": "Left Shift Distillation",
  "complexhex.page.longs.lshift": "Shifts all the bits to the left num times",
  "hexcasting.action.complexhex:shift/right/logical": "Logical Right Shift Dstl.",
  "complexhex.page.longs.rshift.logical": "Shifts all the bits to the right num times",
  "hexcasting.action.complexhex:shift/right/arithmetic": "Arithmetic R. Shift Dstl.",
  "complexhex.page.longs.rshift.arithmetic": "Shifts all the bits to the right num times while preserving the sign",

  "complexhex.entry.misc": "Miscellaneous Complexes",

  "hexcasting.action.complexhex:ascii": "UTF Purification",
  "complexhex.page.misc.ascii": "Swaps between a string of a $(italics)single character$() and an integer representing that character.<br>Uses the $(thing)UTF-16$() character map.",

  "complexhex.entry.expressions": "Expressions",
  "hexcasting.action.complexhex:new_symbol": "Symbolic Purification",
  "complexhex.page.expressions.new": "Creates a new symbol with the given (single character) label",
  "complexhex.page.expressions.ops": "Many operations that work on numbers can also apply to expressions.$(br)The full list is: Addition, Subtraction, Multiplication, Division, Powers, Absolute, Floor, Ceiling, Sine, Cosine, Tangent, Arcsin, Arccos, Arctan, Sinh, Cosh, Tanh, ArcSinh, ArcCosh, ArcTanh, Vector Pack, Logarithms, Modulo, Minimus, Minimus II, Maximus, Maximus II, And, Or, and Not$(br)In the case of operators that work on booleans, 0 is treated as \"false\" and any non-zero value is treated as \"true\".",
  "hexcasting.action.complexhex:substitute": "Substitution Exaltation",
  "complexhex.page.expressions.substitute": "Substitutes the third expression/number in place of the second expression within the first.",
  "hexcasting.action.complexhex:equals": "Equality Purification",
  "complexhex.page.expressions.equals": "Creates an expression that equals 1 if the two expressions are equal, and 0 otherwise.",
  "hexcasting.action.complexhex:piecewise": "Piecewise Exaltation",
  "complexhex.page.expressions.piecewise": "Creates a piecewise expression that simplifies to the second argument if the first simplifies to 1.0, otherwise simplifies to the third argument.",
  "hexcasting.action.complexhex:derivative": "Derivation Purification",
  "complexhex.page.expressions.derivative": "Takes in an expression and a lone symbol and returns the partial derivative of the expression with respect to the symbol.",
  "hexcasting.action.complexhex:matrix": "Neo's Exaltation",
  "complexhex.page.expressions.matrix": "Takes in a width, height and expression and creates a matrix by substituting i & j-values into the expression corresponding to a position in the matrix and putting the result in the matrix.",
  "hexcasting.action.complexhex:summon/line": "Parametric Line",
  "complexhex.page.expressions.summon.line": "Summons a parametric line at the given position. The expression given will have a t-value (0-1), x/y/z position, and time (w) substituted in and must resolve to a vector on the line.",
  "hexcasting.action.complexhex:summon/surface": "Parametric Surface",
  "complexhex.page.expressions.summon.surface": "Summons a parametric surface at the given position. The expression given will have a u&v-value (0-1), x/y/z position, and time (w) substituted in and must resolve to a vector on the surface",
  "complexhex.page.expressions.kill": "Both Parametric objects can be killed by use of the $(l:patterns/great_spells/bits#complexhex:killbit)$(action)Kill Bit/$ pattern",

  "entity.complexhex.parametric.line": "Parametric Line",
  "entity.complexhex.parametric.surface": "Parametric Surface",

  "complexhex.entry.horrors": "Cthonic Maths",
  "hexcasting.action.complexhex:sinh": "Hyp. Sine Prfn.",
  "complexhex.page.horrors.sinh": "Evaluates the hyperbolic sine of the argument",
  "hexcasting.action.complexhex:cosh": "Hyp. Cosine Prfn.",
  "complexhex.page.horrors.cosh": "Evaluates the hyperbolic sine of the argument",
  "hexcasting.action.complexhex:tanh": "Hyp. Tangent Prfn.",
  "complexhex.page.horrors.tanh": "Evaluates the hyperbolic sine of the argument",
  "hexcasting.action.complexhex:asinh": "Inv. Hyp. Sine Prfn.",
  "complexhex.page.horrors.asinh": "Evaluates the hyperbolic sine of the argument",
  "hexcasting.action.complexhex:acosh": "Inv. Hyp. Cosine Prfn.",
  "complexhex.page.horrors.acosh": "Evaluates the hyperbolic sine of the argument",
  "hexcasting.action.complexhex:atanh": "Inv. Hyp. Tangent Prfn.",
  "complexhex.page.horrors.atanh": "Evaluates the hyperbolic sine of the argument",


  "itemGroup.complexhex": "Complex Hex",

  "block.complexhex.hexbox": "Hexbox",
  "item.complexhex.inert_record": "Inert Record",
  "item.complexhex.quenched_record": "Inert Record",
  "subtitles.complexhex.block.hexbox.scratch": "Record Scratches"

}
