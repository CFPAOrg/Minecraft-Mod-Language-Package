{
	"hexcasting.mishap.overevaluate:assert": "断言失败：%s。",
	"hexcasting.mishap.overevaluate:needs_skippable": "本应在可跳过的上下文内运行。",
	"hexcasting.mishap.overevaluate:needs_thoth": "本应在托特之策略内运行。",
	"hexcasting.mishap.overevaluate:apep": "阿佩普之策略的伪栈栈顶本应存在一个iota。",
	"hexcasting.mishap.overevaluate:themis": "忒弥斯之策略的伪栈栈顶本应存在一个数，而实际为%s。",
	"hexcasting.mishap.overevaluate:themis_empty": "忒弥斯之策略的伪栈栈顶本应存在一个数，而实际没有。",
	"hexcasting.mishap.invalid_value.jumble_list": "一个整数列表，且其中各元素均应小于参数数目",
	"hexcasting.mishap.invalid_value.class.jumble": "一个理栈iota",

	"overevaluate.page.trycatch.title": "抛接异常",
	"overevaluate.page.trycatch.description": "$(hex)咒法学$()是一项危险的技艺。即便只是推断出了差错，只是认为我永远不可能碰到构想中的某种情况，也可能立即把我拉向死亡。$(br2)还好，自然有能“试探”/“try”$(hex)咒术$()的方式，还能在它们伤到我之前“捕获”/“catch”它们。如果所给$(hex)咒术$()招致了事故，剩余的部分就会被跳过，转而继续执行外层$(hex)咒术$()，阻止事故产生实际后果。$(br2)$(o)继续前进。$()",
	"hexcasting.action.overevaluate:athena": "雅典娜之策略",
	"overevaluate.page.athena.summary": "安全地施放一个图案列表，方式与$(l:patterns/meta#hexcasting:eval)$(action)赫尔墨斯之策略$()类似，并压入该列表有无招致事故。",
	"hexcasting.action.overevaluate:maat": "玛阿特之策略",
	"overevaluate.page.maat.summary": "接受一个布尔值和任意 iota。若布尔值为 False，则产生消息为该 iota 名称的事故。",
	"overevaluate.page.maat.description": "适用于制造解析至 False 时立刻终止$(hex)咒术$()的断言，也可用于触发$(l:trycatch#overevaluate:athena)$(action)雅典娜之策略$()而后安全退出。此时招致的事故不会产生负面效应。$(br2)$(o)法庭内保持肃静。$()",
	"hexcasting.action.overevaluate:athena_print": "雅典娜之揭示",
	"overevaluate.page.athena_print.summary": "揭示所处$(hex)咒术$()内$(l:trycatch#overevaluate:athena)$(action)雅典娜之策略$()最后一次捕获到的事故。",
	"hexcasting.action.overevaluate:athena_log": "雅典娜之精思",
	"overevaluate.page.athena_log.summary": "若未捕获到事故，则返回 $(l:casting/influences)$(thing)Null$()。而若捕获到了，则返回一个特殊 iota，该 iota 只在世界中$(l:https://modrinth.com/mod/hexpose)有对应的特殊力量$()时有实际意义。",

	"overevaluate.page.jumble.title": "理栈 Iota",
	"overevaluate.page.jumble.0": "理栈 iota 能操控栈的结构，它简明易读且用处极多。单个理栈 iota 就可复制、移除、重排栈中元素，同时保持了高度的可读性，且读一遍就能理解。$(br2)$(hex)咒术$()在处理理栈 iota 时，会先弹出一定数量的 iota，此数即是理栈 iota 中的第一个数。",
	"overevaluate.page.jumble.1": "这些弹出的 iota 会进入一个临时列表，称“引用列表”。然后，理栈 iota 会依次读取其第二部分——正整数列表——的各正整数，以之为索引获取引用列表中对应位置的 iota 压入栈中。$(br2)形如 $(thing)$(o)2 [1 0]$() 的理栈 iota 会弹出两个 iota。然后它会首先将引用列表中索引为 1 的 iota 压栈，再将索引为 0 的 iota 压栈。此理栈 iota 的效果和$(l:patterns/stackmanip#hexcasting:swap)$(action)弄臣之策略$()一致。",
	"hexcasting.action.overevaluate:create_jumble": "理栈之策略",
	"overevaluate.page.create_jumble.summary": "使用参数数目和数列表创建理栈 iota。",
	"hexcasting.action.overevaluate:dissolve_jumble": "理栈之分解",
	"overevaluate.page.dissolve_jumble.summary": "将理栈 iota 拆回数和数列表。",

	"overevaluate.page.soroban.title": "珠算",
	"overevaluate.page.soroban.0": "这些图案会对一个虚构的整数栈执行操作，该栈称作$(o)珠算栈$()，初始栈仅包含一个 0。$(br2)在$(l:patterns/readwrite#hexcasting:local)渡鸦之思$()被占用、使用起来太麻烦、或其递归性有所欠缺时，这些图案就能派上用场，比如用于维护$(l:patterns/meta#hexcasting:for_each)$(action)托特$()循环的迭代次数。",
	"hexcasting.action.overevaluate:soroban_retrieve": "珠算之精思",
	"overevaluate.page.soroban_retrieve.summary": "压入珠算栈的栈顶整数，而后令其增加 1。",
	"hexcasting.action.overevaluate:soroban_push": "珠算之策略",
	"overevaluate.page.soroban_push.summary": "将所给整数压入珠算栈栈顶。",
	"hexcasting.action.overevaluate:soroban_pop": "珠算之策略，第二型",
	"overevaluate.page.soroban_pop.summary": "移除珠算栈栈顶数。若珠算栈变为空，则补一项 0。",

	"overevaluate.page.extra_list.title": "更多列表操作",
	"hexcasting.action.overevaluate:rotate_list": "回换之馏化",
	"overevaluate.page.rotate_list.summary": "将列表中第一个元素移动到列表末尾，重复所给数次；若为负数，则反方向移动。",
	"hexcasting.action.overevaluate:snap_list": "根裂之策略",
	"overevaluate.page.snap_list.summary": "将列表分割为三部分：所给下标之前的列表元素、下标处的元素，以及下标之后的元素。",
	"hexcasting.action.overevaluate:apep": "阿佩普之策略",
	"overevaluate.page.apep.summary": "用第一个列表参数指定的$(hex)咒术$()“折叠”/“fold”第二个列表或图案参数。",
	"overevaluate.page.apep.description": "第一次施放会将$(hex)咒术$()作用于第一和第二个 iota，结果暂存于栈顶。下一次施放作用于第一次暂存的 iota 和原本的第三个 iota，同样暂存于栈顶元素。重复此过程，直至穷尽第一列表。最后，返回最后一次暂存的 iota。$(br2)$(o)欧拉也玩过音乐。$()",
	"hexcasting.action.overevaluate:themis": "忒弥斯之策略",
	"overevaluate.page.themis.summary": "接受一个图案列表和一个列表，或单个图案与一个列表；在第二参数处运行第一参数，并排序结果，运行的过程与$(l:patterns/meta#hexcasting:for_each)$(action)托特之策略$()类似。",
	"overevaluate.page.themis.description": "在每次迭代过后，此法术要求在栈顶有一个数对应该 iota。在策略结束时，它会按照 iota 对应数升序排列 iota，并组为列表返回。对应数一致的 iota 保留相对位置。如果遇到$(l:patterns/meta#hexcasting:halt)$(action)卡戎之策略$()，返回的经排序列表中将仅包括处理过的 iota。$(br2)$(o)重排——自然唯一无法抵消的变化。$()",

	"overevaluate.page.extra_math.title": "更多数学图案",
	"overevaluate.page.extra_math.0": "数学对$(hex)咒法学$()很重要，但这并不意味着它要很$(o)难$()。自然中部分图案之所以存在，似乎只是为了改善我的体验，或者只是为了让$(hex)咒术$()更易懂。$(br2)我感觉有些$(hex)咒术师$()可能会嗤之以鼻，认为它们“没有存在的必要”。",
	"hexcasting.action.overevaluate:root": "示根之纯化",
	"hexcasting.special.overevaluate:root": "示根之纯化：%s",
	"overevaluate.page.root.0": "根据图案尾部的长度，取数的整数次方根。上方的示例分别为平方根、立方根、四次方根。",
	"hexcasting.action.overevaluate:hadamard": "阿达玛之馏化",
	"overevaluate.page.hadamard.summary": "求向量的逐元素积。",

	"overevaluate.page.metas.title": "更多元运行",
	"hexcasting.action.overevaluate:tutu": "图图之策略",
	"overevaluate.page.tutu.summary": "什么都不会做。",
	"overevaluate.page.tutu.description": "此图案看上去可能没什么用，但它很适合作为$(l:patterns/meta#hexcasting:halt)$(action)卡戎之策略$()和$(l:extra_metaevals#overevaluate:janus)$(action)雅努斯之策略$()的“另一分支”。运行此图案不会消耗执行深度和媒质，不会产生粒子，也不会对世界产生任何影响。$(br2)$(o)唯一的取胜之道就是不要参与。$()",
	"hexcasting.action.overevaluate:janus": "雅努斯之策略",
	"overevaluate.page.janus.summary": "立即终止当前$(hex)咒术$()，无视所有限制。",
	"overevaluate.page.janus.description": "此策略适合在$(hex)咒术$()抵达期望状态时提前结束它，而不需考虑$(l:patterns/meta#hexcasting:eval)$(action)赫尔墨斯之策略$()、$(l:patterns/meta#hexcasting:for_each)$(action)托特之策略$()、$(l:patterns/meta#hexcasting:halt)$(action)卡戎之策略$()的种种局限。$(br2)$(o)咒术之将亡，其媒质也善。$()",
	"hexcasting.action.overevaluate:pluto": "普鲁托之策略",
	"hexcasting.special.overevaluate:pluto": "普鲁托之策略：%s",
	"overevaluate.page.pluto.summary": "给$(l:patterns/meta#hexcasting:halt)$(action)卡戎之策略$()附上尾部，即可让其直接跳出多层抽象。如此形成的图案族称作$(l:extra_metaevals#overevaluate:pluto)$(action)普鲁托之策略$()。",
	"overevaluate.page.pluto.description": "所给示例分别会跳出 2、3、4 层嵌套。在退出多层循环时应该很有用，而且用它就不需要$(l:patterns/meta#hexcasting:eval/cc)$(action)伊里斯之策略$()。$(br2)某些古代文献称，要是用到了尾部比第四变种还要长的图案，那就是出了大问题，应该重新整理$(hex)咒术$()。$(br2)$(o)我该怎么回显文件名的最后三个字母？$()",
	"hexcasting.action.overevaluate:nephthys": "奈芙蒂斯之策略",
	"hexcasting.special.overevaluate:nephthys": "奈芙蒂斯之策略：%s",
	"overevaluate.page.nephthys.summary": "弹出一个图案或图案列表，在栈顶往下一定位置处施放所给图案或列表，向下的元素数即是图案尾部的长度。达成的效果与外科医师之提整类似。",
	"overevaluate.page.nephthys.description": "这个图案非常好用，与$(l:patterns/stackmanip#hexcasting:mask)$(action)簿记员之策略$()配合几乎能处理栈中的所有问题，潜入栈中后压入 iota，再处理“栈顶”的 iota。这一操作的名字来源于哀悼和河流的女神，意指其“深埋”或“潜入”栈中的操作。$(br2)$(o)……时间旅行的未知……类似于盲目潜入冰冷水域的深处，再像颗橡子一样任由浮沉。$()",
	"hexcasting.action.overevaluate:atalanta": "阿塔兰忒之策略",
	"overevaluate.page.atalanta.summary": "只应在$(l:patterns/meta#hexcasting:for_each)$(action)托特之策略$()或$(l:extra_metaevals#overevaluate:sisyphus)$(action)西西弗斯之策略$()内部使用。若布尔值为 False，则跳过当前迭代剩余的部分，直接开始下一迭代。",
	"overevaluate.page.atalanta.description": "此图案常用作多重条件循环的“卫语句”。比如，在获取到实体列表后，可能只需根据一长串条件挑出一部分作为目标。使用此图案，即可避免造出层层嵌套的条件判断，而是在判断不通过时直接“$(o)continue$()”/“$(o)继续$()”到下一迭代，如此就无需执行本迭代内后续的语句了。$(br2)$(o)You shall not pass!$()",
	"hexcasting.action.overevaluate:castor": "卡斯托耳之策略",
	"overevaluate.page.castor.summary": "只应在$(l:patterns/meta#hexcasting:for_each)$(action)托特之策略$()内部使用。详情见下一页。小心“钻研过深”事故。",
	"overevaluate.page.castor.description": "此图案会出栈一个 iota，并将其作为$(l:patterns/meta#hexcasting:for_each)$(action)托特之策略$()的一个新迭代项，在当前迭代结束后立即开始。该迭代的栈顶元素即为所出栈的元素。想成把 iota 放到$(l:patterns/meta#hexcasting:for_each)$(action)托特之策略$()所接受的迭代列表的开头，可能会更好理解。$(br2)$(o)不要永远沿着路走，而要走无路之处……并留下你的足迹。$()",
	"hexcasting.action.overevaluate:pollux": "波吕克斯之策略",
	"overevaluate.page.pollux.summary": "$(l:extra_metaevals#overevaluate:castor)$(action)卡斯托耳之策略$()的兄弟图案，此图案会将新迭代置于所有迭代的末尾。同样有风险招致“钻研过深”事故。",
	"overevaluate.page.pollux.description": "效果与其兄弟图案基本一致，但新的迭代置于末尾。我曾阅读过详细记载使用这对图案的技术的卷轴，技术的名字是$(o)$(l:https://en.wikipedia.org/wiki/Depth-first_search)深度优先搜索$()和$(o)$(l:https://en.wikipedia.org/wiki/Breadth-first_search)广度优先搜索$()。$(br2)$(o)深入之前应先探索表面。$()",
	"hexcasting.action.overevaluate:sisyphus": "西西弗斯之策略",
	"overevaluate.page.sisyphus.summary": "接受一个列表，并持续不断运行，直至遇到$(l:patterns/meta#hexcasting:halt)$(action)卡戎之策略$()或$(l:extra_metaevals#overevaluate:janus)$(action)雅努斯之策略$()。",
	"overevaluate.page.sisyphus.description": "我曾听过有些能够自我复制的$(hex)咒术$()，叫作“$(o)自产生程序$()”/“$(o)quine$()”，常用于制造无限循环，但涉及它的实操比较麻烦。此策略简化了这一流程，改为循环运行列表，递归层数用尽或是遇到$(l:patterns/meta#hexcasting:halt)$(action)卡戎之策略$()为止。$(l:patterns/readwrite#hexcasting:local)渡鸦之思$()和栈会在迭代间保留。$(br2)$(o)让世人永远看得见他的负荷……应当想象西西弗是幸福的。$()",

	"overevaluate.page.extra_stack.title": "栈操作附加",
	"hexcasting.action.overevaluate:sekhmet": "塞赫麦特之策略",
	"hexcasting.special.overevaluate:sekhmet": "塞赫麦特之策略：%s",
	"overevaluate.page.sekhmet.0": "清除栈，栈顶 n 个元素除外，具体由图案的尾部长度决定。上方的示例分别会保留 0 个、1 个、2 个 iota。",
	"overevaluate.page.sekhmet.1": "此策略的效果可通过$(l:patterns/stackmanip#hexcasting:stack_len)$(action)群体之精思$()、$(l:patterns/lists#hexcasting:last_n_list)$(action)群体之策略$()、$(l:patterns/lists#hexcasting:slice)$(action)选择之提整$()、$(l:patterns/lists#hexcasting:splat)$(action)群体之拆解$()序列简单达成，但它用起来很方便。它和$(l:patterns/meta#hexcasting:for_each)$(action)托特之策略$()相性极佳，适合对付那些只需返回栈顶若干元素的伪栈。$(br2)$(o)凡事都可能，但不都有必要。$()",
	"hexcasting.action.overevaluate:geb": "盖布之策略",
	"hexcasting.special.overevaluate:geb": "盖布之策略：%s",
	"overevaluate.page.geb": "剔除栈顶往下第 n 个元素，具体由图案的尾部长度决定。上方的示例分别会剔除第 2 个、第 3 个、第 4 个 iota。",
	"hexcasting.action.overevaluate:nut": "努特之策略",
	"hexcasting.special.overevaluate:nut": "努特之策略：%s",
	"overevaluate.page.nut": "将栈顶元素沉至栈顶往下第 n 个元素处，具体由图案的尾部长度决定。上方的示例分别会沉至第 2 个、第 3 个、第 4 个 iota 处。",
	"hexcasting.action.overevaluate:swap_one_three": "反照之策略",
	"overevaluate.page.swap_one_three.summary": "反照栈顶三个 iota 的顺序，将 A, B, C 变为 C, B, A。相当于交换栈顶元素和栈顶往下第三元素。",
	"hexcasting.action.overevaluate:swap_two_three": "泡浮之策略",
	"overevaluate.page.swap_two_three.summary": "使得栈顶往下第三元素上浮过栈顶往下第二元素，相当于交换它们。",
	"hexcasting.action.overevaluate:dup_many": "狄俄斯库里之策略，第二型",
	"overevaluate.page.dup_many.summary": "接受一个数，并复制栈顶开始所给数个元素，保留顺序。"
}
