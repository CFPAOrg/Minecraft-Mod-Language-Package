{
	"hexcasting.mishap.overevaluate:assert": "断言失败：%s。",
	"hexcasting.mishap.overevaluate:needs_skippable": "本应在可跳过的上下文内运行。",
	"hexcasting.mishap.overevaluate:needs_thoth": "本应在托特之策略内运行。",
	"hexcasting.mishap.overevaluate:apep": "阿佩普之策略的伪栈栈顶本应存在一个iota。",
	"hexcasting.mishap.overevaluate:themis": "忒弥斯之策略的伪栈栈顶本应存在一个数。",

	"overevaluate.page.extra_stack.title": "栈操作附加",
	"special.overevaluate.sekhmet": "塞赫麦特之策略：%s",
	"hexcasting.action.overevaluate:sekhmet": "塞赫麦特之策略",
	"hexcasting.special.overevaluate:sekhmet": "塞赫麦特之策略：%s",
	"overevaluate.page.sekhmet.0": "清除栈，栈顶 n 个元素除外，具体由图案的尾部长度决定。上方的示例分别会保留 0 个、1 个、2 个 iota。",
	"overevaluate.page.sekhmet.1": "此策略的效果可通过$(l:patterns/stackmanip#hexcasting:stack_len)$(action)群体之精思$()、$(l:patterns/lists#hexcasting:last_n_list)$(action)群体之策略$()、$(l:patterns/lists#hexcasting:slice)$(action)选择之提整$()、$(l:patterns/lists#hexcasting:splat)$(action)群体之拆解$()序列简单达成，但它用起来很方便。它和$(l:patterns/meta#hexcasting:for_each)$(action)托特之策略$()相性极佳，适合对付那些只需返回栈顶若干元素的伪栈。$(br2)$(o)凡事都可能，但不都有必要。$()",
	"special.overevaluate.geb": "盖布之策略：%s",
	"hexcasting.action.overevaluate:geb": "盖布之策略",
	"hexcasting.special.overevaluate:geb": "盖布之策略：%s",
	"overevaluate.page.geb": "剔除栈顶往下第 n 个元素，具体由图案的尾部长度决定。上方的示例分别会剔除第 2 个、第 3 个、第 4 个 iota。",
	"special.overevaluate.nut": "努特之策略：%s",
	"hexcasting.action.overevaluate:nut": "努特之策略",
	"hexcasting.special.overevaluate:nut": "努特之策略：%s",
	"overevaluate.page.nut": "将栈顶元素沉至栈顶往下第 n 个元素处，具体由图案的尾部长度决定。上方的示例分别会沉至第 2 个、第 3 个、第 4 个 iota 处。",
	"hexcasting.action.overevaluate:swap_one_three": "反照之策略",
	"overevaluate.page.swap_one_three.summary": "反照栈顶三个 iota 的顺序，将 A, B, C 变为 C, B, A。相当于交换栈顶元素和栈顶往下第三元素。",
	"hexcasting.action.overevaluate:swap_two_three": "泡浮之策略",
	"overevaluate.page.swap_two_three.summary": "使得栈顶往下第三元素上浮过栈顶往下第二元素，相当于交换它们。",
	"hexcasting.action.overevaluate:dup_many": "狄俄斯库里之策略，第二型",
	"overevaluate.page.dup_many.summary": "接受一个数，并复制栈顶开始所给数个元素，保留顺序。",

	"overevaluate.page.soroban.title": "珠算",
	"overevaluate.page.soroban.0": "这些图案能操纵一个虚计数器，称作“珠算计数器”。在$(l:patterns/readwrite#hexcasting:local)渡鸦之思$()被占用或使用起来太麻烦时，这些图案就能派上用场，比如维护$(l:patterns/meta#hexcasting:for_each)$(action)托特$()循环的迭代次数。",
	"hexcasting.action.overevaluate:soroban_increment": "珠算之精思",
	"overevaluate.page.soroban_increment.summary": "压入珠算计数器的当前值，而后令其增加 1。计数器自 0 起始。",
	"hexcasting.action.overevaluate:soroban_decrement": "珠算之精思，第二型",
	"overevaluate.page.soroban_decrement.summary": "压入珠算计数器的当前值，而后令其减少 1。",
	"hexcasting.action.overevaluate:soroban_reset": "珠算之策略",
	"overevaluate.page.soroban_reset.summary": "将珠算计数器重置为 0。",

	"overevaluate.page.metas.title": "高阶元运行",
	"hexcasting.action.overevaluate:athena": "雅典娜之策略",
	"overevaluate.page.athena.summary": "运行一个图案列表，方式类似$(l:patterns/meta#hexcasting:eval)$(action)赫尔墨斯之策略$()，但能够处理事故。",
	"overevaluate.page.athena.description": "如果所给图案列表在运行时出现事故，则会跳过触发点后方的列表内容，继续$(hex)咒术$()的主循环，不产生事故的效果。会返回图案列表是否招致了事故。$(br2)后页图案可进一步查询事故的信息。$(br2)$(o)勇往直前。$()",
	"hexcasting.action.overevaluate:athena_print": "雅典娜之揭示",
	"overevaluate.page.athena_print.summary": "揭示所处$(hex)咒术$()内$(l:metaevals#overevaluate:athena)$(action)雅典娜之策略$()最后一次捕获到的事故。",
	"hexcasting.action.overevaluate:athena_log": "雅典娜之精思",
	"overevaluate.page.athena_log.summary": "如果世界中有对应的特殊力量，则会以$(o)文本$()形式返回$(l:metaevals#overevaluate:athena)$(action)雅典娜之策略$()最后一次捕获到的事故。",
	"hexcasting.action.overevaluate:apep": "阿佩普之策略",
	"overevaluate.page.apep.summary": "用第二列表指定的$(hex)咒术$()“折叠”/“fold”第一列表。",
	"overevaluate.page.apep.description": "第一次施放会将$(hex)咒术$()作用于第一和第二个 iota，结果暂存于栈顶。下一次施放作用于第一次暂存的 iota 和原本的第三个 iota，同样暂存于栈顶元素。重复此过程，直至穷尽第一列表。最后，返回最后一次暂存的 iota。$(br2)$(o)欧拉也玩过音乐。$()",
	"hexcasting.action.overevaluate:tutu": "图图之策略",
	"overevaluate.page.tutu.summary": "什么都不会做。",
	"overevaluate.page.tutu.description": "此图案看上去可能没什么用，但它很适合作为$(l:patterns/meta#hexcasting:halt)$(action)卡戎之策略$()和$(l:metaevals#overevaluate:janus)$(action)雅努斯之策略$()的“另一分支”。运行此图案不会消耗执行深度和媒质，不会产生粒子，也不会对世界产生任何影响。$(br2)$(o)唯一的取胜之道就是不要参与。$()",
	"hexcasting.action.overevaluate:janus": "雅努斯之策略",
	"overevaluate.page.janus.summary": "立即终止当前$(hex)咒术$()，无视所有限制。",
	"overevaluate.page.janus.description": "此策略适合在$(hex)咒术$()抵达期望状态时提前结束它，而不需考虑$(l:patterns/meta#hexcasting:eval)$(action)赫尔墨斯之策略$()、$(l:patterns/meta#hexcasting:for_each)$(action)托特之策略$()、$(l:patterns/meta#hexcasting:halt)$(action)卡戎之策略$()的种种局限。$(br2)$(o)咒术之将亡，其媒质也善。$()",
	"hexcasting.action.overevaluate:maat": "玛阿特之策略",
	"overevaluate.page.maat.summary": "接受一个布尔值和任意 iota。若布尔值为 False，则产生事故并打印 iota。",
	"overevaluate.page.maat.description": "此图案很适合在某些条件未满足时跳出$(hex)咒术$()。$(br2)$(o)法庭内保持肃静。$()",
	"special.overevaluate.nephthys": "奈芙蒂斯之策略：%s",
	"hexcasting.action.overevaluate:nephthys": "奈芙蒂斯之策略",
	"hexcasting.special.overevaluate:nephthys": "奈芙蒂斯之策略：%s",
	"overevaluate.page.nephthys.summary": "弹出一个图案或图案列表，在栈顶往下一定位置处施放所给图案或列表，向下的元素数即是图案尾部的长度。达成的效果与外科医师之提整类似。",
	"overevaluate.page.nephthys.description": "这个图案非常好用，与$(l:patterns/stackmanip#hexcasting:mask)$(action)簿记员之策略$()配合几乎能处理栈中的所有问题，潜入栈中后压入 iota，再处理“栈顶”的 iota。这一操作的名字来源于哀悼和河流的女神，意指其“深埋”或“潜入”栈中的操作。$(br2)$(o)……时间旅行的未知……类似于盲目潜入冰冷水域的深处，再像颗橡子一样任由浮沉。$()",
	"hexcasting.action.overevaluate:atalanta": "阿塔兰忒之策略",
	"overevaluate.page.atalanta.summary": "只应在$(l:patterns/meta#hexcasting:for_each)$(action)托特之策略$()或$(l:metaevals#overevaluate:sisyphus)$(action)西西弗斯之策略$()内部使用。效果与$(l:patterns/meta#hexcasting:halt)$(action)卡戎之策略$()类似，但不会完全停止迭代，而只是会跳过当前迭代剩余的部分。",
	"overevaluate.page.atalanta.description": "此图案常用作多重条件循环的“卫语句”。比如，在获取到实体列表后，可能只需根据一长串条件挑出一部分作为目标。使用此图案，即可避免造出层层嵌套的条件判断，而是在判断不通过时直接“$(o)continue$()”/“$(o)继续$()”到下一迭代，如此就无需执行本迭代内后续的语句了。$(br2)$(o)You shall not pass!$()",
	"hexcasting.action.overevaluate:castor": "卡斯托耳之策略",
	"overevaluate.page.castor.summary": "只应在$(l:patterns/meta#hexcasting:for_each)$(action)托特之策略$()内部使用。详情见下一页。小心“钻研过深”事故。",
	"overevaluate.page.castor.description": "此图案会出栈一个 iota，并将其作为$(l:patterns/meta#hexcasting:for_each)$(action)托特之策略$()的一个新迭代项，在当前迭代结束后立即开始。该迭代的栈顶元素即为所出栈的元素。想成把 iota 放到$(l:patterns/meta#hexcasting:for_each)$(action)托特之策略$()所接受的迭代列表的开头，可能会更好理解。$(br2)$(o)不要永远沿着路走，而要走无路之处……并留下你的足迹。$()",
	"hexcasting.action.overevaluate:pollux": "波吕克斯之策略",
	"overevaluate.page.pollux.summary": "$(l:metaevals#overevaluate:castor)$(action)卡斯托耳之策略$()的兄弟图案，此图案会将新迭代置于所有迭代的末尾。同样有风险招致“钻研过深”事故。",
	"overevaluate.page.pollux.description": "效果与其兄弟图案基本一致，但新的迭代置于末尾。我曾阅读过详细记载使用这对图案的技术的卷轴，技术的名字是$(o)$(l:https://en.wikipedia.org/wiki/Depth-first_search)深度优先搜索$()和$(o)$(l:https://en.wikipedia.org/wiki/Breadth-first_search)广度优先搜索$()。$(br2)$(o)深入之前应先探索表面。$()",
	"hexcasting.action.overevaluate:sisyphus": "西西弗斯之策略",
	"overevaluate.page.sisyphus.summary": "接受一个图案列表，并持续不断运行，直至遇到$(l:patterns/meta#hexcasting:halt)$(action)卡戎之策略$()或$(l:metaevals#overevaluate:janus)$(action)雅努斯之策略$()。",
	"overevaluate.page.sisyphus.description": "我曾听过有些能够自我复制的$(hex)咒术$()，叫做“$(o)自产生程序$()”，常用于制造无限循环，但涉及它的实操比较麻烦。此策略简化了这一流程，改为循环运行列表，递归层数用尽或是遇到$(l:patterns/meta#hexcasting:halt)$(action)卡戎之策略$()为止。$(l:patterns/readwrite#hexcasting:local)渡鸦之思$()和栈会在迭代间保留。$(br2)$(o)让世人永远看得见他的负荷……应当想象西西弗是幸福的。$()",
	"hexcasting.action.overevaluate:themis": "忒弥斯之策略",
	"overevaluate.page.themis.summary": "接受一个列表和一个图案列表，或一个列表与单个图案；在第一参数处运行第二参数，并排序结果，运行的过程与$(l:patterns/meta#hexcasting:for_each)$(action)托特之策略$()类似。",
	"overevaluate.page.themis.description": "在每次迭代过后，此法术要求在栈顶有一个数对应该 iota。在策略结束时，它会按照 iota 对应数升序排列 iota，并组为列表返回。对应数一致的 iota 保留相对位置。如果遇到$(l:patterns/meta#hexcasting:halt)$(action)卡戎之策略$()，返回的经排序列表中将仅包括处理过的 iota。$(br2)$(o)重排——自然唯一无法抵消的变化。$()"
}
