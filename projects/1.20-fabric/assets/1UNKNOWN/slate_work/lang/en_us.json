{
  "block.slate_work.storage_slate": "Storage Vessels",
  "block.slate_work.ambit_extender": "Ambit Extender",
  "block.slate_work.crafting_slate": "Patterned Assembler",
  "block.slate_work.speed_loci": "Wave Regulator",

  "Patterns:":"",
  "hexcasting.action.slate_work:get_storage": "Get Vessels",
  "hexcasting.action.slate_work:check_item": "Check Item",
  "hexcasting.action.slate_work:store_item": "Lay Item",
  "hexcasting.action.slate_work:get_item": "Reawaken Item",

  "Entries:": "",
  "slate_work.entry.vessels": "Storage Vessels",
  "slate_work.page.vessels.1": "As wonderful as $(thing)Vessels/$ are for storage, they have an... opaque method of interaction. The main way of interaction is with _Hexes; more specifically, using a _Hex to describe what I wish to retrieve. Importantly, these all $(l:casting/mishaps2)mishap when not casted in a Spell Circle/$. $(br2)$(br)$(o)“Riddles,” I said. $(br)“Always preferable to no answer at all,” he responded.",
  "slate_work.page.vessels.2": "To elaborate more, $(thing)Vessels/$ respects Nature's silly rules regarding the \"Stack Limit\" by working around them. Rather than directly calling an item based on its name, I more-or-less supply a \"description;\" this is a _Hex that takes an $(l:patterns/scrying/item)Item Stack Iota/$, and needs to return a boolean. Also, all patterns to do with the retrieving of $(thing)Storage Vessels/$ take a copy of the Stack, and puts it onto the 'inner' stack (Much like $(l:patterns/meta#hexcasting:for_each)$(action)Thoth's Gambit/$).",
  "slate_work.page.vessels.get_storage": "This simply returns what $(thing)Vessels/$ the current $(l:greatwork/spellcircles)Spell Circle/$ has activated. I should likely use this to check if the $(l:greatwork/spellcircles)Spell Circle/$ has collected any $(thing)Vessels/$.",
  "slate_work.page.vessels.store_item": "It is much easier to store an item into a $(thing)Vessel/$ than to pull it out. This pattern simply takes an Item Entity, and neatly sorts it into the activated $(thing)Storage Vessels/$.",
  "slate_work.page.vessels.get_item": "This takes a _Hex and runs it on every $(l:patterns/scrying/item)Item Stack/$ stored. Once the _Hex is ran, it requires either a $(thing)False/$, or a $(thing)True/$, $(thing)Vector/$ (output of the items), and $(thing)Integer/$ (amount of items)",
  "slate_work.page.vessels.get_item_cont": "Further explained, as stated in the 2nd page. This copies iotas from the stack, so if I had [Position, Count, Type] on the stack then ran a _Hex that got the Type of the $(l:patterns/scrying/item)Item Stack/$ being compared, and did an $(l:patterns/logic#hexcasting:equals)equals check/$. Then it would return only that Type, as item entities, at Position with a count of Count. $(br) It should also be stated this 'search' does not end early after finding a match.",
  "slate_work.page.vessels.check_item": "Check Item functions much like Reawaken Item; however, it only requires a boolean on the 'inner stack'. If the boolean is ever true, the spell returns true.",

  "slate_work.entry.ambit_extenders": "Ambit Extenders",
  "slate_work.page.ambit_extender.ambit_extender": "The Ambit Extender is a fabulous answer to my $(thing)Ambit/$ woes when it comes to $(l:greatwork/spellcircles)Spell Circles/$. This pops a vector from the stack, and extends ambit in the direction (negative vectors extending the negative corner of Circle Ambit). $(br2)$(br2)$(o)With great range comes with great costs, err-",
  "slate_work.page.ambit_extender.ambit_extender_cont": "While this is not as strong as... $(l:https://forum.petra-k.at/viewtopic.php?t=136)other/$ methods of giving a $(l:greatwork/spellcircles)Spell Circles/$ more $(thing)Ambit/$, I do feel like Nature takes a kinder approach to my amalgamation of free will if I use this.$(br2)This does not come cheap however, the _media cost increases with the square of the total distance changed. So if I were to give this a (0,5,0) vector, it would grant the $(l:greatwork/spellcircles)Spell Circle/$ 5 extra blocks of $(thing)Ambit/$ above it, much like if I extended the slates 5 blocks up at the cost of 25 shards",

  "slate_work.entry.wave_regulator": "Wave Regulators",
  "slate_work.page.speed_loci.speed_loci": "As I begin to explore the uses of the $(l:greatwork/spellcircles)Great Work/$, I find my self needing more control over these fascinating possibilities. So I have created the $(thing)Wave Regulator/$; what this does is it pops a number from the stack, and attempts to set the \"speed\" of the wave. More specifically, how many 20ths of a second the wave should wait before going to the next slate.",
  "slate_work.page.speed_loci.speed_loci_cont": "This system does have some limitations however. For one, it cannot set the speed to be faster than the wave could possibly move, doing nothing if I try to set the speed higher. Explained, it can only set the time to wait to any number above or equal the circles default acquired speed, or back to its regular speed. To do this, the $(thing)Wave Regulator/$ needs to pop a 0 from the stack, and it gives the $(l:greatwork/spellcircles)Spell Circle/$ full control of the $(thing)media wave/$ again.",

  "Mishaps:": "",
  "hexcasting.mishap.circle.no_vessels_ran": "At %s did not find any activated Vessels",
  "hexcasting.mishap.circle.media_costs": "At %s required more Media than what the impetus held",

  "hexcasting.mishap.no_vessels_ran": "Did not find any activated Vessels"
}