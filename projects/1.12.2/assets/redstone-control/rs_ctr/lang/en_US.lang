#PARSE_ESCAPES
itemGroup.rs_ctr=Redstone Control
# Blocks
# names & tooltips
tile.rs_ctr.rs_port\:0.name=Redstone Read Socket
tile.rs_ctr.rs_port\:0.tip=Attach on block surface to read its emitted Redstone signal.\nCan be combined with other §6Socket§7s on the same surface.\n§b§oSee also\: §6§oSignal ...\n\nCan be covered with a §asolid block§7 in §aoff-hand§7.\nOr place in §aoff-hand§7 against a §asolid block§7 to replace the block with a covered §6Socket§7. §oIn survival you need a sufficient tool in main hand to break the block.
tile.rs_ctr.rs_port\:0.tipA=timing\: §anext sync. post-tick
tile.rs_ctr.rs_port\:1.name=Redstone Write Socket
tile.rs_ctr.rs_port\:1.tip=Attach on block surface to control the Redstone signal it receives.\nCan be combined with other §6Socket§7s including another §6Write Socket§7 on the same surface (two Write Sockets combined will emit a strong signal that penetrates solid blocks).\n§b§oSee also\: §6§oSignal ...\n\nCan be covered with a §asolid block§7 in §aoff-hand§7.\nOr place in §aoff-hand§7 against a §asolid block§7 to replace the block with a covered §6Socket§7. §oIn survival you need a sufficient tool in main hand to break the block.
tile.rs_ctr.rs_port\:1.tipA=timing\: §ainstant §e[Write]
tile.rs_ctr.rs_port\:2.name=Block Access Socket
tile.rs_ctr.rs_port\:2.tip=Attach on block surface to let connected devices interact with it.\nCan be combined with other §6Socket§7s on the same surface.\n§b§oSee also\: §6§oBlock Reference ...\n\nCan be covered with a §asolid block§7 in §aoff-hand§7.\nOr place in §aoff-hand§7 against a §asolid block§7 to replace the block with a covered §6Socket§7. §oIn survival you need a sufficient tool in main hand to break the block.
tile.rs_ctr.rs_port\:3.name=Block Mirror Socket
tile.rs_ctr.rs_port\:3.tip=Attach on block to let it access the mirrored §9inventory§7, §9fluid§7 and §9energy storage§7 of a connected block through this socket.\nCan be combined with other §6Socket§7s on the same surface.\n§b§oSee also\: §6§oBlock Reference ...§b, §6§oBlock Access Socket\n\nCan be covered with a §asolid block§7 in §aoff-hand§7.\nOr place in §aoff-hand§7 against a §asolid block§7 to replace the block with a covered §6Socket§7. §oIn survival you need a sufficient tool in main hand to break the block.
tile.rs_ctr.rs_port\:3.tipA=timing\: §ainstant §e[Mirror Block IN]
tile.rs_ctr.splitter.name=Signal 4x Splitter
tile.rs_ctr.splitter.tip=Repeats the incoming signal to four different destinations.
tile.rs_ctr.splitter.tipA=timing\: §ainstant §e[IN]
tile.rs_ctr.analog_comb.name=Analog Signal Combiner
tile.rs_ctr.analog_comb.tip=Combines the 4 incoming signals by outputting the one with highest value.
tile.rs_ctr.analog_comb.tipA=timing\: §anext sync. post-tick
tile.rs_ctr.logic_comb.name=Logic Signal Combiner
tile.rs_ctr.logic_comb.tip=Combines the four incoming signals by logical §eOR§7, where the outputs will emit §e65536§7 for §etrue§7 and §e0§7 for §efalse§7.\nThe output as well as each individual input can be set to inverted which also gives you the other logic-gate types §eAND§7, §eNAND§7 and §eNOR§7.
tile.rs_ctr.logic_comb.tipA=timing\: §anext sync. post-tick
tile.rs_ctr.xor_gate.name=XOR-Gate
tile.rs_ctr.xor_gate.tip=Combines the four incoming signals by §eExclusive-OR§7, where the outputs will emit §e65536§7 if an §eodd number§7 of inputs is §etrue§7 and §e0§7 otherwise.
tile.rs_ctr.xor_gate.tipA=timing\: §anext sync. post-tick
tile.rs_ctr.num_comb.name=Arithmetic Signal Combiner
tile.rs_ctr.num_comb.tip=Combines the 4 incoming signals by adding their values together.\nInputs can be negated which allows computing subtractions too.
tile.rs_ctr.num_comb.tipA=timing\: §anext sync. post-tick
tile.rs_ctr.bin_comb.name=Binary Signal Packer
tile.rs_ctr.bin_comb.tip=The output signal results from concatenating the binary representations of the 4 input signals. How many bits are taken from each input signal is configurable\:\n§e1 bit§7 only distinguishes between §e0§7 and §e1\\n§e2 bit§7 distinguishes between §e0§7, §e1§7, §e2§7 and §e3\\n§e4 bit§7 distinguishes the values §e0§7 - §e15\\n§e8 bit§7 distinguishes the values §e0§7 - §e255\n§oOnly values within the given range can be losslessly retrieved later on by a §6§oBinary Signal Unpacker§7§o.
tile.rs_ctr.bin_comb.tipA=timing\: §anext sync. post-tick
tile.rs_ctr.bin_split.name=Binary Signal Unpacker
tile.rs_ctr.bin_split.tip=Works the opposite way of the §6Binary Signal Packer§7\:\nThe binary representation of the input signal is split into 4 pieces of §e1§7, §e2§7, §e4§7 or §e8 bit§7 each (depending on setting) which then form the individual output signals.\n\n§oThis makes it possible to send multiple signals through a shared wire. Also the operation of a §6§oLogic Signal Combiner§7§o in §e§obitwise§7§o-mode runs for all packed signals in parallel.
tile.rs_ctr.bin_split.tipA=timing\: §ainstant §e[IN]
tile.rs_ctr.wire_anchor.name=Wire Anchor
tile.rs_ctr.wire_anchor.tip=§6Signal Wire§7s can be attached on these to customize their path.\n§oMultiple of them may be placed inside a single block.
tile.rs_ctr.processor.tip=§nF§7ield §nP§7rogrammable §nG§7ate §nA§7rrays can represent any circuitry you want (within limits) in a very compact way.\n§b§oSee\: §6§oFPGA Programmer§b, §6§oFPGA Assembler\n\nOffers up to §16 Input§7 and §26 Output§7 ports but has less component capacity than the §eDIP8§7 version.
tile.rs_ctr.processor.name=Redstone FPGA §eQFP12
tile.rs_ctr.processor.tipA=timing\: §anext sync. post-tick
tile.rs_ctr.editor.name=FPGA Programmer
tile.rs_ctr.editor.tip=Used to design custom circuitry and program it onto §6Redstone FPGA§7s.
tile.rs_ctr.comparator.name=clocked Comparator
tile.rs_ctr.comparator.tip=Whenever the value of §eClock IN§7 changes, §eOUT§7 will be updated to the current comparator value read from §eBlock IN§7. A signal supplied to §eThreshold IN§7 gets subtracted from output.\n§b§oSee also\: §6§oBlock Reference ...§b, §6§oBlock Access ...\n\nThis device can be tuned to observe different block properties by attaching certain items on it\: See §9§oJEI usage recipes§7.
tile.rs_ctr.comparator.tipA=timing\: §ainstant §e[Clock IN]
tile.rs_ctr.processor2.name=Redstone FPGA §eDIP8
tile.rs_ctr.processor2.tip=§nF§7ield §nP§7rogrammable §nG§7ate §nA§7rrays can represent any circuitry you want (within limits) in a very compact way.\n§b§oSee\: §6§oFPGA Programmer§b, §6§oFPGA Assembler\n\nOffers up to §14 Input§7 and §24 Output§7 ports.
tile.rs_ctr.processor2.tipA=timing\: §anext sync. post-tick
tile.rs_ctr.processor3.name=Redstone FPGA §eBGA16
tile.rs_ctr.processor3.tip=§nF§7ield §nP§7rogrammable §nG§7ate §nA§7rrays can represent any circuitry you want (within limits) in a very compact way.\n§b§oSee\: §6§oFPGA Programmer§b, §6§oFPGA Assembler\n\nOffers high IO count with up to §18 Input§7 and §28 Output§7 ports but at the cost of increased Redstone Exhaustion.
tile.rs_ctr.processor3.tipA=timing\: §anext sync. post-tick
tile.rs_ctr.assembler.name=FPGA Assembler
tile.rs_ctr.assembler.tip=Lets you add materials to a §6Redstone FPGA§7 to improve its complexity values.
tile.rs_ctr.power_hub.name=Energy Distributor
tile.rs_ctr.power_hub.tip=Provides energy for up to 8 attached devices.\nAcceps Forge Energy compatible power through the block's back side.\n§oOnly works with capacitors installed\: See §9§oJEI usage recipes§7.\n§oAlthough not listed, all Forge Energy compatible items can be used as well.
tile.rs_ctr.power_hub.tipA=energy conversion\: §a1RF \= \\<energy_unit_FE>
tile.rs_ctr.item_translocator.name=controlled Item Translocator
tile.rs_ctr.item_translocator.tip=§esource/destin. Inventory IN§7\: the inventory to take from / put in.\n§esource/destin. Slot IN§7\: the inventory's slot ID to interact with or -1 for any slot. §oOnly X->Y, X->any or any->Y allowed, but not any->any!\n§EAmount IN§7\: the number of items to transfer. §oNegative value will transfer destin. -> source instead.\n§eClock IN§7 triggers the transfer on value change.\n§eAmount OUT§7 returns number of items actually transfered.\n§eEnergy IN§7 supplies the energy required for operation.\n§b§oSee also\: §6§oBlock Reference ...§b, §6§oBlock Access Socket
tile.rs_ctr.item_translocator.tipA=timing\: §aentity ticks\nenergy cost\: §a\\<energy_item_translocator_op> + \\<energy_item_translocator_ps> * §eitems moved§a/64
tile.rs_ctr.fluid_translocator.name=controlled Fluid Translocator
tile.rs_ctr.fluid_translocator.tip=§esource/destin. Tank IN§7\: the tank to drain from / fill in.\n§EAmount IN§7\: the fluid volume in mB to transfer. §oNegative value will transfer destin. -> source instead.\n§eClock IN§7 triggers the transfer on value change.\n§eAmount OUT§7 returns volume actually transfered.\n§eEnergy IN§7 supplies the energy required for operation.\n§b§oSee also\: §6§oBlock Reference ...§b, §6§oBlock Access Socket
tile.rs_ctr.fluid_translocator.tipA=timing\: §aentity ticks\nenergy cost\: §a\\<energy_fluid_translocator_op> + \\<energy_fluid_translocator_pb> * §efluid moved§a/B
tile.rs_ctr.panel.name=Control Panel
tile.rs_ctr.panel.tip=The surface is divided into a 4x4 grid where different §6Modules§7 can be attached. Ports for connecting wires to those Modules are on the back side.\nUse a §6Screwdriver§7 to configure or remove modules.\n§oAll installed Modules and configuration is kept when broken.
tile.rs_ctr.solar_cell.name=Solar Cell
tile.rs_ctr.solar_cell.tip=Generates energy from sunlight\nto power your pocket calculator.
tile.rs_ctr.solar_cell.tipA=energy gen\: §a\\<energy_solar>/t §e@ full sunlight
tile.rs_ctr.energy_valve.name=Power Regulator
tile.rs_ctr.energy_valve.tip=Controls and measures the amount of §9Forge Energy§7 transfered through the device\:\nChanging the value of §eClock IN§7 starts a new Energy Packet of size §eRF Limit IN§7 and §eRF flow OUT§7 returns the amount that was transfered from the previous Packet.
tile.rs_ctr.energy_valve.tipA=timing\: §ainstant §e[Clock IN]\nmaximum transfer\: §a2.147.483.647 RF/t
tile.rs_ctr.splitter_b.name=Block Reference 4x Splitter
tile.rs_ctr.splitter_b.tip=Repeats the incoming §6Block Reference§7 to four different destinations (no delay).
tile.rs_ctr.splitter_b.tipA=timing\: §ainstant §e[Block IN]
tile.rs_ctr.multiplex_b.name=Block Reference Multiplexer
tile.rs_ctr.multiplex_b.tip=Selects one of the four §6Block Reference§7 inputs to pass on as output depending on the value of §eSelect IN§7 if it's in range §e0 ... 3§7. Otherwise outputs no Block Reference.
tile.rs_ctr.multiplex_b.tipA=timing\: §anext sync. post-tick
tile.rs_ctr.frame.name=3D Block Frame
tile.rs_ctr.frame.tip=Used to mark block regions for devices\:\nDefine a §ecubiod§7 by placing §6Frame§7s in it's §e8 corners§7 §o(vertically included but horizontally excluded).\nPlace the device in one of the §ecorners§7 or §eedges§7 and let it scan. §oIt can act as corner for its own region but not for other device's regions.\nThe region may already be correctly detected with fewer than 8 corners placed but all of them are required for the device to operate.
tile.rs_ctr.block_selector.name=3D Block Selector
tile.rs_ctr.block_selector.tip=Creates §6Block Reference§7s of blocks specified by §eX, Y, Z coordinates§7 within an area defined by §63D Block Frame§7s.\nCoordinate inputs are valid in range §e0 ... size-1§7 for each axis.
tile.rs_ctr.block_selector.tipA=timing\: §anext sync. post-tick\nmax range\: §a\\<block_select_range> m
tile.rs_ctr.block_breaker.name=controlled Block Miner
tile.rs_ctr.block_breaker.tip=Breaks blocks and puts any harvested items into an adjacent inventory.\n§eBlock IN\:§7 the Block to break.\n§eClock IN\:§7 value change triggers operation.\n§eStatus OUT\:§7 result of the last operation\:\n§e-1§7 \= did nothing (unbreakable/Air), §e0§7 \= successful, §e1§7 \= can't proceed (inventory full), §e2§7 \= insufficient energy.\n§eEnergy IN\:§7 energy supply for operation.\n§b§oSee also\: §6§oBlock Reference ...§b, §6§oBlock Access Socket§b, §63D Block Selector
tile.rs_ctr.block_breaker.tipA=timing\: §aentity ticks\nenergy cost\: §a(\\<energy_breaker_op> + \\<energy_breaker_hard> * §eblock hardness§a) * (1 + \\<energy_breaker_speed>t / §eclock interval§a)
tile.rs_ctr.block_breaker1.name=controlled Block Breaker
tile.rs_ctr.block_breaker1.tip=The cheap version of the §6controlled Block Miner§7 that can't be enchanted and §cdoesn't produce drops§7 for blocks that need a tool to harvest (stone, ores, etc.).
tile.rs_ctr.block_breaker1.tipA=timing\: §aentity ticks\nenergy cost\: §a(\\<energy_breaker_op> + \\<energy_breaker_hard> * §eblock hardness§a) * (1 + \\<energy_breaker_speed>t / §eclock interval§a)
tile.rs_ctr.item_placer.name=controlled Item User
tile.rs_ctr.item_placer.tip=Emulates player right click interactions.\nRight-click block to open Fake Player inventory.\n§eBlock IN\:§7 the block location to interact with/at.\n§eConfiguration IN\:§7 {§aaim Up§7, §caim Right§7, §fuse in Air§7, §1no existing Block§7, §3Sneaking§7, §2look Pitch§7, §4look Yaw§7, §6Equiped slot§7} binary packed as\: §70b§800000000§7_§aUUUU§cRRRR§7_§80§2§fA§1B§3S§2PP§4YY§7_§800§6EEEEE\n§eClock IN\:§7 value change triggers action.\n§eStatus OUT\:§7 result of last action\: §e-1§7 \= did nothing, §e0§7 \= successful, §e1§7 \= failed, §e2§7 \= insufficient energy.\n§eEnergy IN\:§7 energy supply for operation.\n§b§oSee also\: §6§oBlock Reference ...§b, §6§oBlock Access Socket§b, §63D Block Selector
tile.rs_ctr.item_placer.tipA=timing\: §aentity ticks\nenergy cost\: §a\\<energy_placer_op> * (1 + \\<energy_placer_speed>t / §eclock interval§a)
tile.rs_ctr.delay.name=Signal Delay Line
tile.rs_ctr.delay.tip=Outputs each of the four incoming signals by one tick (0.05s) delayed.
tile.rs_ctr.delay.tipA=timing\: §anext sync. post-tick
tile.rs_ctr.delay_b.name=Block Reference Delay Line
tile.rs_ctr.delay_b.tip=Repeats each of the four incoming §6Block Reference§7s by one tick (0.05s) delayed.
tile.rs_ctr.delay_b.tipA=timing\: §anext sync. post-tick
tile.rs_ctr.counter.name=Counter
tile.rs_ctr.counter.tip=Increments/decrements §eCount OUT§7 whenever §eClock IN§7 changes. If count gets out of range §eRange IN + 1 ... 0§7 or §e0 ... Range IN - 1§7 it wraps around and §eClock OUT§7 gets flipped.\n\n§oNote\: This device operates without signal delays, so consistent timing between §e§oRange IN§7§o and §e§oClock IN§7§o can not be guaranteed!
tile.rs_ctr.counter.tipA=timing\: §ainstant §e[Clock IN]
tile.rs_ctr.oc_adapter.name=Signal IO Controller
tile.rs_ctr.oc_adapter.tip=Adapter for §9Open Computers§7. Offers §18 input§7 and §28 output§7 ports. Inputs can be configured to trigger signal change events.\nAlso has §e4 Energy§7 ports on the back to conveniently power machines from OC network.
tile.rs_ctr.oc_adapter.tipA=timing\: §anext sync. post-tick\nenergy conversion\: §a1 OC charge \= \\<energy_unit_OC>
tile.rs_ctr.ram.name=external RAM chip [%sbit]
tile.rs_ctr.ram.tip=Directly addressable memory that supports simultaneous read and write access. Offers vastly more storage capacity than typically fits into an §6FPGA§7.\nInteract with block to view/edit contents. Data remains when broken.
tile.rs_ctr.ram.tipA=timing read\: §ainstant §e[Read Address]\ntiming write\: §anext sync. world tick
tile.rs_ctr.chunk_loader.name=Chunk Loader
tile.rs_ctr.chunk_loader.tip=Keeps a region which is defined by §63D Block Frame§7s chunk loaded.\n§eActive IN§7\: operation mode\: 0 \= off, 1 \= single chunk, 2 \= region\n§erem. Time OUT§7\: minutes of remaining §6Runtime§7 which must be refilled regulary.\n§oRuntime is consumed at twice the normal rate if more than one chunk is loaded.\n\n§8§nGeneral note\:§8 be carefull with pipes and machinery crossing the boundaries of a chunk loaded area! If these attept to interact with neighboring unloaded blocks, those chunks may be hot-loaded to fullfill the request. But since no player or chunk loader is keeping them loaded, one tick later they will unload again which leads into a repeating cycle. So to avoid lag it's actually better to keep those chunks permanently loaded as well.\n§8§oDevices in this mod are save, they only hot-load chunks when absolutely necessary!
tile.rs_ctr.teleporter.tip=Improved version of the §6Teleporter§7 that is capable of moving large regions of blocks, not just a single block. This region must be defined using §63D Block Frame§7s.\nTeleportation is started by changing §eTeleport IN§7 from §e0§7 to the desired §eop-code§7 and keeping it there until §eStatus OUT \= 100§7. Switching back to §e0§7 before completion will cancel the teleport.\n\n§edestin. Block IN§7\: The position to teleport to.\n§eanchor Block IN§7\: The block to teleport or the anchor point for a region to teleport (must be inside region or frame).\n§eTeleport IN§7\: 0 \= idle, 1 \= single block, 2 \= inner volume, 4 \= outer frame, 6 \= volume + frame.\n§eStatus OUT§7\: -2 \= invalid frame, -1 \= invalid coordinates, 0 \= idle, 1...99 \= charging, 100 \= complete.\n§eEnergy IN§7\: energy supply required during charging.
tile.rs_ctr.teleporter.name=Structure Teleporter
tile.rs_ctr.teleporter.tipA=timing\: §aentity ticks\nteleport happens §apre entity ticks\nmax range (frame)\: §a\\<teleporter_range> m\nenergy cost\: §evolume§a/m³ * §edistance§a/m * \\<energy_teleport_pb>\ninter-dimensional §edistance§a \= \\<teleport_dist_cap>m\n\n§8§oAll blocks inside the regions are swapped simultaneously, being treated like during a chunk unload/reload. So this §lshould§8§o work fine with most mods, even for multiblock structures.
tile.rs_ctr.teleporter1.name=Teleporter
tile.rs_ctr.teleporter1.tip=Teleports blocks and entities by swapping the contents of the §eanchor§7 and §edestination§7 block.\nTeleportation is started by changing §eTeleport IN§7 from §e0§7 to §e1§7 and keeping it there until §eStatus OUT \= 100§7. Switching back to §e0§7 before completion will cancel the teleport.\n\n§edestin. Block IN§7\: The position to teleport to.\n§eanchor Block IN§7\: The block to teleport.\n§eTeleport IN§7\: 0 \= idle, 1 \= start teleport.\n§eStatus OUT§7\: -1 \= invalid coordinates, 0 \= idle, 1...99 \= charging, 100 \= complete.\n§eEnergy IN§7\: energy supply required during charging.
tile.rs_ctr.teleporter1.tipA=timing\: §aentity ticks\nteleport happens §apre entity ticks\nenergy cost\: §edistance§a/m * \\<energy_teleport_pb>\ninter-dimensional §edistance§a \= \\<teleport_dist_cap>m
tile.rs_ctr.block_deserializer.name=Block Reference Deserializer
tile.rs_ctr.block_deserializer.tip=Converts a §6Block Reference§7 into the world coordinates of the block location it refers to.\n§eX§7/§eY§7/§eZ-coord OUT§7 emit the coordinates and §eDimension OUT§7 the world's dimension ID. Signals supplied to §eX§7/§eY§7/§eZ-ref IN§7 get subtracted from the outputs.\n\nIf §eBlock IN§7 is not connected, the position of the device itself is outputted. And if a null reference is supplied, §eDimension OUT§7 will emit §e-2.147.483.648§7.
tile.rs_ctr.block_deserializer.tipA=timing\: §ainstant §e[Block IN]
tile.rs_ctr.block_reorienter.name=Block Reference Reorienter
tile.rs_ctr.block_reorienter.tip=Modifies a §6Block Reference§7 to access the block from a different side (relevant for §6Item§7/§6Fluid Translocator§7).\n§eSide IN§7 controls the new access side\:\n0 \= Bottom (-y), 1 \= Top (+y),\n2 \= North (-z), 3 \= South (+z),\n4 \= West (-x), 5 \= East (+x),\nelse \= keep old side
tile.rs_ctr.block_reorienter.tipA=timing\: §anext sync. post-tick
tile.rs_ctr.int_panel.name=Integrated Panel
tile.rs_ctr.int_panel.tip=A §6Control Panel§7 with integrated §6Redstone FPGA§7 for IO processing.\nOffers up to §116 Inputs§7 and §216 Outputs§7, but only up to §e4§7 of each are accessible as ports on the back.\n\nThe remaining I/Os must be assigned labels that start with two digits defining a grid position occupied by the §6Module§7 to connect with\:\n§e30§7 . . §e33\n \:  \:  \:  \:\n§e00§7 . . §e03\n§oModule I/Os are not accessible as ports!

# chat messages
msg.rs_ctr.type=§cIncompatible socket type!
msg.rs_ctr.dir_in=§cCan only connect to input ports!
msg.rs_ctr.dir_out=§cCan only connect to output ports!
msg.rs_ctr.wire0=§cInputs can only connect to outputs and vice versa!
msg.rs_ctr.wire1=§cToo far away, not enough wire!
msg.rs_ctr.wire2=§cToo far away, max length is %d blocks!
msg.rs_ctr.wire3=§cFirst port doesn't exist anymore!
msg.rs_ctr.probe0=§cMust be connected to block first!
msg.rs_ctr.probe1=§cCan only connect to Block Reference inputs!
msg.rs_ctr.split1=§cOut of split channels!
msg.rs_ctr.save_succ=§aCircuit Schematic successfully saved!
msg.rs_ctr.load_succ=§aCircuit Schematic successfully loaded!
msg.rs_ctr.invalid_file=§cThe selected file doesn't contain Circuit Schematic data!
msg.rs_ctr.no_file=§cThe selected file doesn't exist!
msg.rs_ctr.cfg_store=§2Configuration stored
msg.rs_ctr.cfg_load=§2Configuration loaded
msg.rs_ctr.copy_clr=§1Configuration cleared
msg.rs_ctr.cfg_invalid=§4Invalid configuration for component!
msg.rs_ctr.decode_hex=§bDecoding file in intel hex format ...
msg.rs_ctr.decode_img=§bDecoding file as image with %d bits per pixel ...
msg.rs_ctr.decode_bin=§bDecoding file as raw binary data ...
msg.rs_ctr.decode_bmp=§bDecoding file as bitmap ...
msg.rs_ctr.import_succ=§aMemory import successfull!
msg.rs_ctr.encode_hex=§bEncoding file in intel hex format ...
msg.rs_ctr.encode_img=§bEncoding file as %dx%d image with %d bits per pixel ...
msg.rs_ctr.encode_bin=§bEncoding file as raw binary data ...
msg.rs_ctr.encode_bmp=§bEncoding file as %dx%d bitmap ...
msg.rs_ctr.export_succ=§aMemory export successfull!
msg.rs_ctr.dir_invalid=§4To protect you from accidentally corrupting game files or other important data, you can not export to files outside the "circuitSchematics/data/" directory.

# Items
# names & tooltips
item.rs_ctr.wire.name=Signal Wire
item.rs_ctr.wire.tip=§aUse§7 on signal port to attach, then §ause§7 on another signal port of opposite polarity to connect both together.\n§oRequires 1 item per block of straight distance between ports.\n\nConnections are removed by either §ahitting§7 the port or §asneak using§7 it with an §aempty hand§7.
item.rs_ctr.wire.tipA=max length\: §a\\<max_wire_length> m
item.rs_ctr.wireless.name=Wireless Signal Connector
item.rs_ctr.wireless.tip=Like a §6Signal Wire§7 but can connect two signal ports over any distance, even across dimensions.
item.rs_ctr.wireless_b.name=Wireless Block Reference Connector
item.rs_ctr.wireless_b.tip=Like a §6Block Reference Wire§7 but can connect two signal ports over any distance, even across dimensions.
item.rs_ctr.constant.name=Constant Plug
item.rs_ctr.constant.tip=Can be attached to an input port to supply it with a constant signal value.\n§aUse§7 in air to configure value.\n§aSneak use§7 in air to change dec/hex/bin mode.
item.rs_ctr.lamp.name=Signal Status Lamp
item.rs_ctr.lamp.tip=Attach on output port to see its signal state.\n\nCan also be attached on a §6Control Panel§7 as indicator lamp.\n§eSize\:§7 1x1
item.rs_ctr.tag.name=Wire Tag
item.rs_ctr.tag.tip=§aUse§7 in air to set name.\n§aUse§7 on connected port to rename its wire connection. It will then show the name instead of an ID.
item.rs_ctr.block_wire.name=Block Reference Wire
item.rs_ctr.block_wire.tip=Connects §6Block Reference§7 ports just like the §6Signal Wire§7 connects signal ports.\n§oConsumes 1 item per block of straight distance between ports.\n§b§oSee also\: §6§oBlock Access ...
item.rs_ctr.block_wire.tipA=max length\: §a\\<max_wire_length> m
item.rs_ctr.clock.name=Clock Plug
item.rs_ctr.clock.tip=Emits a continuous square-wave signal into the port it's attached to. Switching between §e65535§7 and §e0§7.\n§aUse§7 in air configure pulse width and phase.\n§oAll clocks in the world are synchronized.\n\nCan also be attached on a §6Control Panel§7 as adjustable clock.\n§eSize\:§7 1x2
item.rs_ctr.clock.tipA=timing\: §aearly post-ticks
item.rs_ctr.wire_e.name=Energy Wire
item.rs_ctr.wire_e.tip=Connects energy ports just like the §6Signal Wire§7 connects signal ports.\n§oConsumes 1 item per block of straight distance between ports.
item.rs_ctr.wire_e.tipA=max length\: §a\\<max_wire_length> m
item.rs_ctr.processor.stats=Complexity\: §c%d §b%d §9%d §7Size\: §f%d
item.rs_ctr.wrench.name=Screwdriver
item.rs_ctr.wrench.name1=Screwdriver §9stored conf.
item.rs_ctr.wrench.tip=§aUse§7 on §6Control Panel§7 to edit a module's configuration.\n§aHit§7 on §6Control Panel§7 to remove a module (works in creative, too).\n§aSneak-use§7 on §6Control Panel§7 to copy a module's configuration. §nThen\:\n§aUse§7 to apply the copied configuration on a module.\n§aSneak-use§7 in air to clear the copied configuration.\n\nOtherwise §aUsage§7 on blocks will rotate them.
item.rs_ctr.seg7\:0.name=7-Segment Display Module §e1x1
item.rs_ctr.seg7\:1.name=7-Segment Display Module §e1x2
item.rs_ctr.seg7\:2.name=7-Segment Display Module §e2x2
item.rs_ctr.seg7\:3.name=7-Segment Display Module §e4x2
item.rs_ctr.seg7\:i.tip=A 2/4-digit 7-Segment LED-Display Module to attach on a §6Control Panel§7.\nProvides integrated encoder logic for decimal and hexadecimal. The §eOUT§7 signal can be used to chain multiple modules together to display bigger numbers.\n§aUse§7 in air to change §esize\:§7 1x1 ... 2x4.
item.rs_ctr.pointer_dsp\:0.name=Analog Display Module §e2x2
item.rs_ctr.pointer_dsp\:1.name=Analog Display Module §e2x4
item.rs_ctr.pointer_dsp\:2.name=Analog Display Module §e4x2
item.rs_ctr.pointer_dsp\:3.name=Analog Display Module §e4x4
item.rs_ctr.pointer_dsp\:i.tip=An analog pointer based display module to attach on a §6Control Panel§7.\nThe scale range is freely adjustable.\n§aUse§7 in air to change §esize\:§7 2x2 ... 4x4.
item.rs_ctr.slider.name=Slider Module
item.rs_ctr.slider.tip=A slider module to attach on a §6Control Panel§7 that allows continuous selection of values in a configurable range.\n§aInteract§7 with the upper section of the scale for fine control.\n§eSize\:§7 2x4
item.rs_ctr.text\:1.name=Text Module §e1x1
item.rs_ctr.text\:2.name=Text Module §e1x2
item.rs_ctr.text\:3.name=Text Module §e1x3
item.rs_ctr.text\:4.name=Text Module §e1x4
item.rs_ctr.text\:i.tip=Displays 4 lines of text on a §6Control Panel§7.\n§aUse§7 in air to change §esize\:§7 1x1 ... 1x4.
item.rs_ctr.lever\:0.name=Lever Module
item.rs_ctr.lever\:1.name=Lamp-Switch Module
item.rs_ctr.lever\:2.name=Lamp-Button Module
item.rs_ctr.lever\:i.tip=Switches between two signal states when §aclicked§7.\nTo be attached on a §6Control Panel§7.\n§eSize\:§7 1x1
item.rs_ctr.lever\:2.tip=Stays ON after being §aclicked§7 for a configurable time interval.\n§aSneak-click§7 to turn off early.\nTo be attached on a §6Control Panel§7.\n§eSize\:§7 1x1
item.rs_ctr.trigger.name=Signal Threshold Latch
item.rs_ctr.trigger.tip=A Latch that turns §eON§7 when §einput > enable threshold§7 and turns §eOFF§7 when §einput <\= disable threshold§7 (comparisons are flipped if enable < disable).\nBoth thresholds can be adjusted on the §6Control Panel§7.\n§eSize\:§7 1x2
item.rs_ctr.trigger.tipA=timing\: §ainstant §e[IN]
item.rs_ctr.scale.name=Signal Scaler
item.rs_ctr.scale.tip=A §6Control Panel§7 component that applies an adjustable scale factor to a signal.\n§eSize\:§7 1x2
item.rs_ctr.scale.tipA=timing\: §ainstant §e[IN]
item.rs_ctr.offset.name=Signal Offset
item.rs_ctr.offset.tip=A §6Control Panel§7 component that adds an adjustable offset to a signal.\n§eSize\:§7 1x2
item.rs_ctr.offset.tipA=timing\: §ainstant §e[IN]
item.rs_ctr.oscilloscope\:0.name=Oscilloscope Module §e2x2
item.rs_ctr.oscilloscope\:1.name=Oscilloscope Module §e2x4
item.rs_ctr.oscilloscope\:2.name=Oscilloscope Module §e4x2
item.rs_ctr.oscilloscope\:3.name=Oscilloscope Module §e4x4
item.rs_ctr.oscilloscope\:i.tip=Displays the values of 3 channels as graphs with 50/100 time samples each (left to right on screen) on a §6Control Panel§7.\nThe input signal is binary packed as 0x§3TT§1CC§2BB§4AA§7 (4x8bit) with channels §4A§7, §2B§7, §1C§7 in range §e0...100§7 (bottom to top on screen) and §3T§7 being a clock signal that makes the next sample enter the graph whenever it's value changes.\nThe output signal can be chained into another Oscilloscope Screen.\n§aUse§7 in air to change §esize\:§7 2x2 ... 4x4.\n§b§oSee also\: §6§oBinary Signal Packer§b, §6§oSignal Scaler§b, §6§oSignal Offset
item.rs_ctr.split_s.name=Signal Splitter Plug
item.rs_ctr.split_s.tip=When attached to a signal output port it allows you to connect more than one wire to that port.\n\n§oRequires one item per channel. Additional items are automatically taken from your inventory as necessary when connecting wires.
item.rs_ctr.split_s.tipA=timing\: §ainstant\nmax connections\: §a\\<max_split_links>
item.rs_ctr.split_b.name=Block Reference Splitter Plug
item.rs_ctr.split_b.tip=When attached to a Block Reference output port it allows you to connect more than one wire to that port.\n\n§oRequires one item per channel. Additional items are automatically taken from your inventory as necessary when connecting wires.
item.rs_ctr.split_b.tipA=timing\: §ainstant\nmax connections\: §a\\<max_split_links>
item.rs_ctr.edge_trigger\:0.name=Toggle Latch Plug\:§e ⍏ ⟹ ⇵
item.rs_ctr.edge_trigger\:1.name=Toggle Latch Plug\:§e ⍖ ⟹ ⇵
item.rs_ctr.edge_trigger\:i.tip=Switches the signal send into a connected wire between §e0§7 and §e65536§7 on every rising/falling edge (around §e0§7) of the signal outputted by the port it's attached on.\n\nUse in Air to change mode.\n\n§oThis can be used to convert conventional §3§orising/falling edge§7§o clock signals into the §3§otrigger on change§7§o clock signals needed for machines.
item.rs_ctr.edge_trigger\:i.tipA=timing\: §ainstant\nmax connections\: §a1
item.rs_ctr.pulse_gen.name=Pulse Generator Plug
item.rs_ctr.pulse_gen.tip=Sends a value of §e65535§7 into a connected wire if the output signal of the port this is attached on had changed during the previous tick, otherwise it emits §e0§7.
item.rs_ctr.pulse_gen.tipA=timing\: §anext sync. post-tick\nmax connections\: §a1
item.rs_ctr.cl_fuel.name=Runtime [§a%d\:%02d h§r]
item.rs_ctr.cl_fuel.tip=§aUse§7 on §6Chunk Loader§7 to refill its runtime.\n§oItem will be consumed!\n§aHit§7 a §6Chunk Loader§7 to retrieve it's stored time back.
item.rs_ctr.signal_probe.tip=Displays all signals currently going in and out of a device.\n§lYou definitely want one of these when working with this mod!\n\nAlso works as a §6Screwdriver§7.
item.rs_ctr.signal_probe.name=Signal Probe Monitor
item.rs_ctr.signal_probe.name1=Signal Probe Monitor §9stored conf.
item.rs_ctr.block_plug.name=Block Access Plug
item.rs_ctr.block_plug.tip=Directly connects §6Block Reference§7 Access to a block within §a\\<block_plug_range> m§7 distance of the port it is attached on.\n§aSneak-use§7 on block face to link, then use on port to connect.\n\n§oLink uses relative coordinates (relevant for teleport).
item.rs_ctr.remote.name0=Remote Control §4OFF
item.rs_ctr.remote.name1=Remote Control §2ON
item.rs_ctr.remote.tip=While in your inventory and turned ON, a 32-bit signal that represents the currently pressed keys is emitted into the linked port.\n§ause§7 on signal port to link.\n§ause in air§7 to turn ON/OFF.\n§asneak-use§7 in air to configure key bindings.
item.rs_ctr.socket_s.name=Panel Signal Socket
item.rs_ctr.socket_s.tip=Attach on a §6Control Panel§7 for a pair of signal ports connecting front and back side of the panel.\nAim §aup-right§7 for front facing §2output§7.\nAim §adown-left§7 for front facing §1input§7.\n§eSize\:§7 1x1
item.rs_ctr.socket_b.name=Panel Block Reference Socket
item.rs_ctr.socket_b.tip=Attach on a §6Control Panel§7 for a pair of §6Block Reference§7 ports connecting front and back side of the panel.\nAim §aup-right§7 for front facing §2output§7.\nAim §adown-left§7 for front facing §1input§7.\n§eSize\:§7 1x1
item.cd4017be.m\:battery.name=Redstone Battery
item.cd4017be.m\:actuator.name=Telekinetic Actuator
item.cd4017be.m\:telekin_alloy.name=Telekinetic Alloy
item.cd4017be.m\:corerope.name=Core-Rope Cell
item.cd4017be.m\:corerope1.name=Core-Rope Cluster
item.cd4017be.m\:corerope2.name=Core-Rope Grid

#Signal Probing Display
sp.rs_ctr.none=[       ]
sp.rs_ctr.num=hex\: %1$08X dec\: %1$d
sp.rs_ctr.i=§9 > §r
sp.rs_ctr.o=§a < §r
sp.rs_ctr.block=%d %d %d d\=%d %s
sp.rs_ctr.invalid=no signals!
sp.rs_ctr.plug=[ plug ]
sp.rs_ctr.id=#%-6d
sp.rs_ctr.unknown=unknown Value
sp.rs_ctr.null=null reference
#Signal port names
port.rs_ctr.rsR=Read
port.rs_ctr.rsW=Write
port.rs_ctr.i=IN
port.rs_ctr.i0=IN 0
port.rs_ctr.i1=IN 1
port.rs_ctr.i2=IN 2
port.rs_ctr.i3=IN 3
port.rs_ctr.i4=IN 4
port.rs_ctr.i5=IN 5
port.rs_ctr.i6=IN 6
port.rs_ctr.i7=IN 7
port.rs_ctr.o=OUT
port.rs_ctr.o0=OUT 0
port.rs_ctr.o1=OUT 1
port.rs_ctr.o2=OUT 2
port.rs_ctr.o3=OUT 3
port.rs_ctr.o4=OUT 4
port.rs_ctr.o5=OUT 5
port.rs_ctr.o6=OUT 6
port.rs_ctr.o7=OUT 7
port.rs_ctr.num0=positive
port.rs_ctr.num1=negative
port.rs_ctr.logic0=x > 0
port.rs_ctr.logic1=x <\= 0
port.rs_ctr.logic2=bit-wise
port.rs_ctr.logic3=bit-wise\ninverted
port.rs_ctr.logic4=OR
port.rs_ctr.logic5=NOR
port.rs_ctr.bin4=4x4bit -> 16bit
port.rs_ctr.bin2=4x2bit -> 8bit
port.rs_ctr.bin1=4x1bit -> 4bit
port.rs_ctr.bin8=4x8bit -> 32bit
port.rs_ctr.bins1=4bit -> 4x1bit
port.rs_ctr.bins2=8bit -> 4x2bit
port.rs_ctr.bins4=16bit -> 4x4bit
port.rs_ctr.bins8=32bit -> 4x8bit
port.rs_ctr.clk=Clock IN
port.rs_ctr.bi=Block IN
port.rs_ctr.ref=Threshold IN
port.rs_ctr.clock=⎍ %.2fs
port.rs_ctr.edge0=\n⍏ ⟹ ⇵
port.rs_ctr.edge1=\n⍖ ⟹ ⇵
port.rs_ctr.pulse=\n∆ ⟹ ⌈⌉
port.rs_ctr.energy_io=Energy I/O
port.rs_ctr.energy_i=Energy IN
port.rs_ctr.energy_o=Energy OUT
port.rs_ctr.battery0=§cno capacitor\n§cinstalled!
port.rs_ctr.battery=§aCharge\:\n§a%.4u / %.3u
port.rs_ctr.inv0=source Inventory IN
port.rs_ctr.inv1=destin. Inventory IN
port.rs_ctr.slot0=source Slot IN
port.rs_ctr.slot1=destin. Slot IN
port.rs_ctr.am_i=Amount IN
port.rs_ctr.am_o=Amount OUT
port.rs_ctr.tank0=source Tank IN
port.rs_ctr.tank1=destin. Tank IN
port.rs_ctr.rf_i=RF Limit IN
port.rs_ctr.rf_o=RF Flow OUT
port.rs_ctr.brR=Get Block OUT
port.rs_ctr.brW=Mirror Block IN
port.rs_ctr.bi0=Block IN 0
port.rs_ctr.bi1=Block IN 1
port.rs_ctr.bi2=Block IN 2
port.rs_ctr.bi3=Block IN 3
port.rs_ctr.bo=Block OUT
port.rs_ctr.sel=Select IN
port.rs_ctr.z=Z-coord IN
port.rs_ctr.y=Y-coord IN
port.rs_ctr.x=X-coord IN
port.rs_ctr.show_sel0=Area Invisible
port.rs_ctr.show_sel1=§aArea Visible
port.rs_ctr.area0=§aValid Area\: %d*%d*%d
port.rs_ctr.area1=Incomplete Area\: %d*%d*%d\n§6Missing %d corner Frames!
port.rs_ctr.area2=§cInvalid Area\: %d*%d*%d\n§oInteract to scan!
port.rs_ctr.invax0=normal
port.rs_ctr.invax1=mirrored
port.rs_ctr.status=Status OUT
port.rs_ctr.place=Configuration IN
port.rs_ctr.inc=increment
port.rs_ctr.dec=decrement
port.rs_ctr.limit=Limit IN
port.rs_ctr.count=Count OUT
port.rs_ctr.clko=Clock OUT
port.rs_ctr.ra=Read Address
port.rs_ctr.rv=Read Value
port.rs_ctr.wa=Write Address
port.rs_ctr.wv=Write Value
port.rs_ctr.area_cl0=§aValid Area %d*%d\nChunks\: %d / %d
port.rs_ctr.area_cl2=Area too large\: %d*%d\n§cToo many chunks\: %d / %d
port.rs_ctr.area_cl1=Incomplete Area\: %d*%d\n§6Missing %5$d corner Frames!
port.rs_ctr.load=Active IN
port.rs_ctr.time=rem. Time OUT
port.rs_ctr.time_cl0=Time\: %d\:%02d h [§coff§f]
port.rs_ctr.time_cl1=Time\: %d\:%02d h [§ax1§r]
port.rs_ctr.time_cl2=Time\: %d\:%02d h [§9x2§r]
port.rs_ctr.p0=anchor Block IN
port.rs_ctr.p1=destination Block IN
port.rs_ctr.tp=Teleport IN
port.rs_ctr.refx=X-ref IN
port.rs_ctr.refy=Y-ref IN
port.rs_ctr.refz=Z-ref IN
port.rs_ctr.dim=Dimension OUT
port.rs_ctr.xo=X-coord OUT
port.rs_ctr.yo=Y-coord OUT
port.rs_ctr.zo=Z-coord OUT
port.rs_ctr.side=Side IN
port.rs_ctr.remote=Remote\n#%d
sensor.rs_ctr.none=Comparator\nValue
sensor.rs_ctr.item=Stored Item Count
sensor.rs_ctr.fluid=Stored Fluid [mB]
sensor.rs_ctr.fe=Stored Energy [RF]
sensor.rs_ctr.eu=Stored Energy [EU]
sensor.rs_ctr.dfr-2=Draconic Fusion Reactor\n[°C, RF/‰, ∑mB/‰] +/-
sensor.rs_ctr.dfr-1=Draconic Fusion Reactor\n§7no Stabilizer or Injector connected!
sensor.rs_ctr.dfr0=temperature mode:\nTemperature [°C]
sensor.rs_ctr.dfr1=inverted temperature mode:\nStatus {-1:cold, 0:offline, 1:safety, 2:normal, 3:overheat}
sensor.rs_ctr.dfr2=containment field mode:\nField Charge [RF]
sensor.rs_ctr.dfr3=inverted containment field mode:\nField Strength [0...1000]
sensor.rs_ctr.dfr4=core saturation mode:\nCore Charge [RF]
sensor.rs_ctr.dfr5=inverted core saturation mode:\nCore Saturation [0...1000]
sensor.rs_ctr.dfr6=fuel mode:\nTotal Core Mass [mB]
sensor.rs_ctr.dfr7=inverted fuel mode:\nFuel Conversion [0...1000]
sensor.rs_ctr.hard=Block Hardness [% Stone]
sensor.rs_ctr.light=Light Levels\nBlock[0...15] + 256*Sky[0...15]
sensor.rs_ctr.grow=Crop Growth\n-1\: none, 0\: growing, 1\: mature

#Circuit gates
gate.cost=§8Complexity\: §c%d §b%d
gategroup.rs_ctr.io=Memory & IO
gate.rs_ctr.in=Input Socket\n§7receives external signals
gate.rs_ctr.out=Output Socket\n§7emits external signals
gate.rs_ctr.clock_out=Clock Output Socket\n§7Emits an external clock signal, switching\n§7on each execution cycle the input is §etrue§7.
gate.rs_ctr.return=Execution End Node\n§7Ensures that the connected\n§7signal is evaluated.
gate.rs_ctr.read_b=Variable Read 8bit\n§7Outputs the variable value set\n§7in previous evaluation cycle.
gate.rs_ctr.read_s=Variable Read 16bit\n§7Outputs the variable value set\n§7in previous evaluation cycle.
gate.rs_ctr.read=Variable Read 32bit\n§7Outputs the variable value set\n§7in previous evaluation cycle.
gate.rs_ctr.write_b=Variable Write 8bit\n§7Stores input in a variable to\n§7feed into next evaluation cycle.\n§3§oOperation is only performed\n§3§owhen connected to End Node!
gate.rs_ctr.write_s=Variable Write 16bit\n§7Stores input in a variable to\n§7feed into next evaluation cycle.\n§3§oOperation is only performed\n§3§owhen connected to End Node!
gate.rs_ctr.write=Variable Write 32bit\n§7Stores input in a variable to\n§7feed into next evaluation cycle.\n§3§oOperation is only performed\n§3§owhen connected to End Node!
gate.rs_ctr.feedback=Feedback Loop 32bit\n§7Variable read and write in one.\n§7Basically delays a signal by one update cycle.\n§3§oThe input/output sides on this are reversed!
gate.rs_ctr.feedback_b=Feedback Loop 8bit\n§7Variable read and write in one.\n§7Basically delays a signal by one update cycle.\n§3§oThe input/output sides on this are reversed!
gate.rs_ctr.feedback_s=Feedback Loop 16bit\n§7Variable read and write in one.\n§7Basically delays a signal by one update cycle.\n§3§oThe input/output sides on this are reversed!
gate.rs_ctr.array_b=Array 8bit\n§7Provides a fixed sized indexable list\n§7of persistent 8bit integer values.
gate.rs_ctr.array_s=Array 16bit\n§7Provides a fixed sized indexable list\n§7of persistent 16bit integer values.
gate.rs_ctr.array_i=Array 32bit\n§7Provides a fixed sized indexable list\n§7of persistent 32bit integer values.
gate.rs_ctr.aset=Array Write\n§7Writes in1 into index in2 in array in3.\n§7Valid indices are §e0 ... N-1§7 for array size N.\n§4§oAccessing an invalid index causes burnout!\n§3§oOperation is only performed\n§3§owhen connected to End Node!
gate.rs_ctr.aget=Array Read\n§7Reads the value at index in1 in array in2.\n§7Valid indices are §e0 ... N-1§7 for array size N.\n§4§oAccessing an invalid index causes burnout!
gate.rs_ctr.alen=Array Size\n§7Outputs the element count\n§7of the input array.
gate.rs_ctr.read_f=Variable Read Float\n§7Outputs the variable value set\n§7in previous evaluation cycle.
gate.rs_ctr.write_f=Variable Write Float\n§7Stores input in a variable to\n§7feed into next evaluation cycle.\n§3§oOperation is only performed\n§3§owhen connected to End Node!
gate.rs_ctr.feedback_f=Feedback Loop Float\n§7Variable read and write in one.\n§7Basically delays a signal by one update cycle.\n§3§oThe input/output sides on this are reversed!
gate.rs_ctr.array_f=Array Float\n§7Provides a fixed sized indexable list\n§7of persistent Floating Point values.
gategroup.rs_ctr.logic=Logic
gate.rs_ctr.or=OR-Gate\n§7out \= in1 ∨ in2\n§7bitwise
gate.rs_ctr.nand=NAND-Gate\n§7out \= ¬(in1 ∧ in2)\n§7bitwise
gate.rs_ctr.xor=XOR-Gate\n§7out \= in1 ⊻ in2\n§7bitwise
gate.rs_ctr.nor=NOR-Gate\n§7in \= ¬(in1 ∨ in2)\n§7bitwise
gate.rs_ctr.not=NOT-Gate\n§7out \= ¬in\n§7bitwise
gate.rs_ctr.and=AND-Gate\n§7out \= in1 ∧ in2\n§7bitwise
gate.rs_ctr.xnor=XNOR-Gate\n§7in \= ¬(in1 ⊻ in2)\n§7bitwise
gate.rs_ctr.swt=Switch\n§7in1 \= true -> out \= in2\n§7else -> out \= in3
gate.rs_ctr.branch=Execution Switch\n§7in1 \= true -> evaluate in2\n§7else -> evaluate in3
gate.rs_ctr.sequence=Execution Sequence\n§7first evaluate in1\n§7then evaluate in2
gate.rs_ctr.update=Update Trigger\n§7Always triggers the next\n§7cycle when evaluated.
gate.rs_ctr.fswt=Float Switch\n§7in1 \= true -> out \= in2\n§7else -> out \= in3
gategroup.rs_ctr.comp=Comparators
gate.rs_ctr.lt0=Less than Zero\n§7in < 0 -> out \= true\n§7else -> out \= false
gate.rs_ctr.ge0=Greater or Equal to Zero\n§7in ≥ 0 -> out \= true\n§7else -> out \= false
gate.rs_ctr.gt0=Greater than Zero\n§7in > 0 -> out \= true\n§7else -> out \= false
gate.rs_ctr.le0=Less or Equal to Zero\n§7in ≤ 0 -> out \= true\n§7else -> out \= false
gate.rs_ctr.eq0=Is Zero\n§7in \= 0 -> out \= true\n§7else -> out \= false
gate.rs_ctr.ne0=Not Zero\n§7in ≠ 0 -> out \= true\n§7else -> out \= false
gate.rs_ctr.ne=Not Equal\n§7in1 ≠ in2 -> out \= true\n§7else -> out \= false
gate.rs_ctr.lt=Less than\n§7in1 < in2 -> out \= true\n§7else -> out \= false
gate.rs_ctr.gt=Greater than\n§7in1 > in2 -> out \= true\n§7else -> out \= false
gate.rs_ctr.eq=Equal\n§7in1 \= in2 -> out \= true\n§7else -> out \= false
gate.rs_ctr.le=Less or Equal\n§7in1 ≤ in2 -> out \= true\n§7else -> out \= false
gate.rs_ctr.ge=Greater or Equal\n§7in1 ≥ in2 -> out \= true\n§7else -> out \= false
gate.rs_ctr.feq0=Float is Zero\n§7in \= ±0 -> out \= true\n§7else -> out \= false
gate.rs_ctr.flt0=Float less than Zero\n§7in < 0 -> out \= true\n§7else -> out \= false
gate.rs_ctr.fgt0=Float greater than Zero\n§7in > 0 -> out \= true\n§7else -> out \= false
gate.rs_ctr.finf=Float is Infinite\n§7in \= ±∞ -> out \= true\n§7else -> out \= false
gate.rs_ctr.fnan=Float is NaN\n§7in \= NaN -> out \= true\n§7else -> out \= false
gate.rs_ctr.fcmp=Compare Floats\n§7in1 > in2 -> out \= 1\n§7in1 \= in2 -> out \= 0\n§7else -> out \= -1
gategroup.rs_ctr.num=Integer Arithmetic
gate.rs_ctr.cst=Constant Number\n§7out \= #
gate.rs_ctr.cst0=Constant 0\n§7out \= 0
gate.rs_ctr.cst1=Constant 1\n§7out \= 1
gate.rs_ctr.neg=Negate\n§7out \= -in
gate.rs_ctr.sub=Subtract\n§7out \= in1 - in2
gate.rs_ctr.add=Add\n§7out \= in1 + in2
gate.rs_ctr.div=Divide\n§7out \= in1 / in2\n§7rounding down\n§4§oDiv/0 causes burnout!
gate.rs_ctr.dec=Decrement\n§7out \= in - 1
gate.rs_ctr.abs=Absolute value\n§7in < 0 -> out \= -in\n§7else -> out \= in
gate.rs_ctr.mul=Multiply\n§7out \= in1 * in2
gate.rs_ctr.inc=Increment\n§7out \= in + 1
gate.rs_ctr.mod=Div Remainder\n§7out \= in1 mod in2\n§7sgn(out) \= sgn(in1)\n§4§oDiv/0 causes burnout!
gate.rs_ctr.min=Minimum\n§7in1 < in2 -> out \= in1\n§7else -> out \= in2
gate.rs_ctr.max=Maximum\n§7in1 > in2 -> out \= in1\n§7else -> out \= in2
gate.rs_ctr.rand=Random Number\n§70 ≤ out < in\n§4§oBound ≤ 0 causes burnout!
gate.rs_ctr.time=Time\n§7out \= current time\n§7in \= cycle interval\:\n§70 ≤ out < in
gate.rs_ctr.time.mode=Time Source
gate.rs_ctr.time.mode0=World Age [t]
gate.rs_ctr.time.mode1=Day Time [t]
gate.rs_ctr.time.mode2=Realtime [ms]
gate.rs_ctr.time.mode3=Realtime [s]
gategroup.rs_ctr.bin=Bits & Bytes
gate.rs_ctr.bsl=Bit left shift\n§7out \= in1 * 2^in2
gate.rs_ctr.bsr=Bit right shift\n§7out \= in1 / 2^in2
gate.rs_ctr.bitspl=Bit Splitter\n§7Splits an 8-bit input value up into its individual bits.\n§7Ouputs §etrue§7 or §efalse§7 depending on whether the bit is set.
gate.rs_ctr.bitcom=Bit Combiner\n§7Composes an 8-bit output\n§7value from individual bits.
gate.rs_ctr.bytespl=Byte Splitter\n§7Splits a 32-bit number into four\n§7signed or unsigned 8-bit numbers.
gate.rs_ctr.bytecom=Byte Combiner\n§7Combines four 8-bit numbers into one 32-bit number.\n§7§oIgnoring any higher order bits of the inputs.
gate.rs_ctr.lobp=Lowest Bit Index\n§7out \= log_2(lowestSetBit(in))\n§7in \= 0 -> out \= 32
gate.rs_ctr.hobp=Highest Bit Index\n§7out \= floor(log_2(in))\n§7in \= 0 -> out \= -1
gate.rs_ctr.obcnt=Bit Count\n§7out \= #setBits(in)
gate.rs_ctr.bmask=Bit Mask\n§7out \= in AND #\n§7bitwise
gate.rs_ctr.bin_i2f=Float from binary\n§7Creates a Floating Point number\n§7from its binary representation.
gate.rs_ctr.bin_f2i=Float to binary\n§7Turns a Floating Point number\n§7into its binary representation.
gategroup.rs_ctr.float=Floating Point Arithmetic
gate.rs_ctr.fcst=Float Constant\n§7out \= #
gate.rs_ctr.fcst0=Constant 0.0\n§7out \= 0.0
gate.rs_ctr.fcst1=Constant 1.0\n§7out \= 1.0
gate.rs_ctr.fneg=Negate Float\n§7out \= -in
gate.rs_ctr.finv=Inverse Float\n§7out \= 1.0 / in
gate.rs_ctr.fabs=Absolute Float value\n§7in < 0 -> out \= -in\n§7else -> out \= in
gate.rs_ctr.fadd=Add Floats\n§7out \= in1 + in2
gate.rs_ctr.fsub=Subtract Floats\n§7out \= in1 - in2
gate.rs_ctr.fmul=Multiply Floats\n§7out \= in1 * in2
gate.rs_ctr.fdiv=Divide Floats\n§7out \= in1 / in2
gate.rs_ctr.fmod=Float Div Remainder\n§7out \= in1 mod in2
gate.rs_ctr.fmin=Minimum Float\n§7in1 < in2 -> out \= in1\n§7else -> out \= in2
gate.rs_ctr.fmax=Maximum Float\n§7in1 > in2 -> out \= in1\n§7else -> out \= in2
gate.rs_ctr.floor=Floor\n§7out \= max(integer ≤ in)
gate.rs_ctr.ceil=Ceiling\n§7out \= min(integer ≥ in)

# GUI
# Inventory names
gui.rs_ctr.constant.name=Set Value
gui.rs_ctr.tag.name=Label:
gui.rs_ctr.editor.name=Circuit Editor\:
gui.rs_ctr.debug.name=Debugger
gui.rs_ctr.state.name=Variables:
gui.rs_ctr.clock.name=Clock Settings
gui.rs_ctr.assembler.name=Processor Assembler
gui.rs_ctr.dsp_cfg.name=Configuration
gui.rs_ctr.item_placer.name=controlled Item User
gui.rs_ctr.ram.name=Memory content
gui.rs_ctr.remote.name=Remote Control Keybinds
# Gui tooltips
gui.rs_ctr.palette=Gate Palette
gui.rs_ctr.palette.open0=Open Gate Palette
gui.rs_ctr.palette.open1=Open Inventory
gui.rs_ctr.opLabel=Gate Label\n§7(relevant for\n§7variables & IO)
gui.rs_ctr.value=Value
gui.rs_ctr.interrupt0=changed value §ndoes not§r trigger next cycle
gui.rs_ctr.interrupt1=changed value triggers next cycle
gui.rs_ctr.signed0=Unsigned
gui.rs_ctr.signed1=Signed
gui.rs_ctr.array_len=Number of Entries
gui.rs_ctr.array_idx=index
gui.rs_ctr.editor.title=Name of your circuit
gui.rs_ctr.editor.del=§4delete Gate
gui.rs_ctr.editor.new=New Schematic\n§4clears the board
gui.rs_ctr.editor.compile=Compile Circuit\n§aR-C§7\: Debugger
gui.rs_ctr.editor.load=Import Schematic
gui.rs_ctr.editor.save=Save Schematic\n§aR-C§7\: export as ...
gui.rs_ctr.editor.ingreds=Circuit Complexity\:\n§c%d / %d basic\n§b%d / %d advanced\n§9%d / %d memory
gui.rs_ctr.editor.info=Controls\nBasic Mechanics\nSignal Types\nDebugging / Testing
gui.rs_ctr.editor.info0=§7§nComponent interaction\:§a left-click\n§7To add a component, first click on it in the palette, then on the board where you want to place it.\n§7§oThe palette shows up in place of your inventory when enabled via button.\n§aclick§7 on a component on the board to select it. Configuration options will appear below the bottom left of the board.\n§aclick-drag§7 to move a component around [red boxes indicate collision with other components].\n§7Moving a component outside the board area will delete it [bright red box].\n§7§nPin/Trace interaction\:§a right-click\n§7To connect two components with a trace, first §aclick§7 an input pin [left side of a component], then optionally click a few places on the board to lay out its path and finally §aclick§7 another component's output pin [right side].\n§aclick-drag§7 a trace vertex to move it.\n§aHold Alt§7 to display traces only.
gui.rs_ctr.editor.info1=§7In general a circuit receives signals from external devices through its §6input sockets§7, performs some computations on them and produces one or more results that get send back to external devices through its §6output sockets§7. This is referred to as a §ecycle§7.\n\n§6Variables§7 allow a circuit to remember information across cycles. They consist of a §6write§7 component that receives a value in one cycle and a matching [same label] §6read§7 component that spits it out again one cycle later. The read component also defines the variable's initial value. \n\n§7Normally a new cycle gets evaluated with one tick delay after an input or a variable changed its value. But you can set individual §6variable write§7s or §6input§7s to not trigger a cycle if wanted.\n§7§oNote\: changing variable values manually through the Debugger or the processor's status interface won't trigger a cycle.
gui.rs_ctr.editor.info2=§7Traces have different colors to indicate the type of signal being propagated which is determined by the component pins being connected\:\n§4§n32-bit integer§7\: standard number type also used by all redstone sockets. Has a valid range of §a-2147483648 ... 2147483647§7.\n§5§n8/16-bit integer§7\: supports a range of §a-128 ... 127§7 (signed) or §a0 ... 255§7 (unsigned) for 8 bit and §a-32768 ... 32767§7 (signed) or §a0 ... 65536§7 (unsigned) for 16 bit.\n§9§nboolean§7\: a logical signal that's either §atrue§7 or §afalse§7. When used for integer inputs, §atrue -> -1§7 and §afalse -> 0§7, conversion in the other direction uses §anon zero§7 comparison.\n§6§nfloating point§7\: represents fractional numbers, conversion rounds towards zero.\n§8§ncausal relation§7\: propagates no data, only controls execution flow.\n§e§narray§7\: reference to integrated §lR§7andom §lA§7ccess §lM§7emory to be used with §eget§7 and §eset§7 operations.
gui.rs_ctr.editor.info3=§7Although you can overwrite the circuit in an §6FPGA§7 as often as you like, it is usually a good idea to first test your design with the §edebugger§7 before hooking it up to ... let's say, your nuclear reactor control setup.\n§7The §edebugger§7 window is opened by §aright-click§7 on the §ecompile button§7 (instead of left-click). In there you can feed your circuit with different input values and see how its outputs and variable states behave after executing individual cycles.\n§7The debugger's variable editing feature is also available later in the §6FPGA§7's §estatus interface§7 (which is opened by normal interaction with the placed block).\n§7Therefore also seemingly useless §eread-only§7 and §ewrite-only§7 variables may be used for later adjustment of parameters or getting more details about the circuit's operation.
gui.rs_ctr.debug.run0=automatic execution
gui.rs_ctr.debug.run1=manual execution
gui.rs_ctr.debug.step0=force cycle\n§4§ostable state
gui.rs_ctr.debug.step1=run cycle\n§2§ounstable
gui.rs_ctr.debug.reset=reset count
gui.rs_ctr.state.io=Signal IO\:
gui.rs_ctr.hex0=decimal format
gui.rs_ctr.hex1=hexadecimal format
gui.rs_ctr.interval=Interval
gui.rs_ctr.phase=Phase Offset
gui.rs_ctr.error1=§4Causal Loop\: input value depends on itself!\n§7§oInsert a §6§oFeedback Loop§7§o operator to fix this.
gui.rs_ctr.error2=§4incompatible data type
gui.rs_ctr.error3=§4missing input signal
gui.rs_ctr.error4=§4invalid identifier
gui.rs_ctr.error5=§4duplicate variable declaration
gui.rs_ctr.error6=§4conflicting variable data types!
gui.rs_ctr.error7=§4invalid value
gui.rs_ctr.error32=§4missing Processor
gui.rs_ctr.error33=§4circuit too complex\n§4for given Processor
gui.rs_ctr.error34=§4Processor doesn't\nsupport enough I/O
gui.rs_ctr.error64=§6highly recommended\n§6to label your IO ports
gui.rs_ctr.error65=§6Gate outputs are not used!
gui.rs_ctr.save_file=Export
gui.rs_ctr.load_file=Import
gui.rs_ctr.to_assembler=Move over to Assembler
gui.rs_ctr.processor.run=manually trigger cycle
gui.rs_ctr.processor.power=Redstone exhaustion\:\n§e%.0f %%
gui.rs_ctr.assembler.stats=§c%d\n§b%d\n§9%d\n§f%d\n§e%.1f cyc\n§a%.1f c/s
gui.rs_ctr.assembler.stats1=§c%d/%7$d\n§b%d/%8$d\n§9%d/%9$d\n§f%d\n§e%.1f cyc\n§a%.1f c/s
gui.rs_ctr.assembler.stats4=§e%+d cap
gui.rs_ctr.assembler.stats5=§a%+d u/t
gui.rs_ctr.assembler.info=FPGA Assembly\nRedstone Energy\nAutomation
gui.rs_ctr.assembler.info0=§7Complex circuitry also requires more complex §6FPGA§7s.\n§7There are 3 different types of §ecomplexity§7 related to different kinds of base logic elements and each can be increased by adding specific components to the §6FPGA§7.\n§7But components also take up §esize§7 which is limited based on FPGA type.\n§7Note that different components not only provide different types of §ecomplexity§7 but may also do that at different §esize§7 costs and have different §eRedstone Energy strength§7. §oSee next tab.
gui.rs_ctr.assembler.info1=§7It seems §6Redstone§7 naturally builds up charge without any apparent energy source. §oIt's believed that it comes from radioactive decay.\n§7These charges are quite weak however, enough to perform simple logic computations but they quickly deplete when signals switch rapidly as can be seen in the burn out effect of §6Redstone Torches§7.\n§7Certain energetic materials may improve the charge strength a bit whereas trying to miniaturize circuitry and reduce material costs severely weakens it, eventually up to a point where circuits can't run stable anymore without external power supply.\n§7§oThis is characterized by §e§olongest tick burst§7§o and §e§omax continuous tick-rate§7.
gui.rs_ctr.assembler.info2=§7FPGAs can be assembled automatically from a template (slot above FPGA assembly).\n\n§7When a template is present, any inserted FPGA (of same type) will be automatically disassembled and reassembled using the same ingredients as the template contains. Any program installed will be copied as well.\n§7Finally the complete FPGA is stacked with the templates.
gui.rs_ctr.template=Template to replicate
gui.rs_ctr.to_editor=Move over to Editor
gui.rs_ctr.mat3=remaining size
gui.rs_ctr.mat2=memory (bytes)
gui.rs_ctr.mat1=advanced Complexity
gui.rs_ctr.mat0=basic Complexity
gui.rs_ctr.mat5=max continuous tick-rate
gui.rs_ctr.mat4=longest tick burst
gui.rs_ctr.max=scale upper limit
gui.rs_ctr.min=scale lower limit
gui.rs_ctr.uscale=Unit scale factor
gui.rs_ctr.style=Display Style
gui.rs_ctr.label=Label
gui.rs_ctr.unit=Unit
gui.rs_ctr.encoder0=raw segments encoding\:\n§78-bit per digit\n§e1\:§7 center\n§e2\:§7 upper left\n§e4\:§7 top\n§e8\:§7 upper right\n§e16\:§7 lower right\n§e32\:§7 bottom\n§e64\:§7 lower left\n§e128\:§7 decimal point
gui.rs_ctr.encoder1=signed raw segments encoding\:\n§7last 3 digits like §eraw segments encoding§7 using bits 0-23.\n§72 bits [24, 25] for first digit\:\n§e0\:§7 +\n§e1\:§7 +1\n§e2\:§7 -\n§e3\:§7 -1
gui.rs_ctr.encoder2=unsigned decimal encoding\n§7May be chained before other\n§7displays as digit extender.
gui.rs_ctr.encoder3=signed decimal encoding
gui.rs_ctr.encoder4=hexadecimal encoding
gui.rs_ctr.color=Display Color
gui.rs_ctr.dot=decimal point position
gui.rs_ctr.text=Text lines
gui.rs_ctr.align=Text alignment
gui.rs_ctr.v_off=OFF value
gui.rs_ctr.v_on=ON value
gui.rs_ctr.thr=Threshold value\n§oON when above
gui.rs_ctr.thr_off=Disable threshold
gui.rs_ctr.thr_on=Enable threshold
gui.rs_ctr.incr=Increment Step
gui.rs_ctr.scale=internal scale factor
gui.rs_ctr.div0=multiply adjustment
gui.rs_ctr.div1=divide adjustment
gui.rs_ctr.ofs=actual offset
gui.rs_ctr.item_placer.slot=Equipped Item\:\n§7Slot\: §4%d §8\= bits[0...5]
gui.rs_ctr.item_placer.aim=Block surface aim\:\n§7right\: %d §8\= bits[16...19]\n§7up\: %d §8\= bits[20...23]
gui.rs_ctr.item_placer.look=Look orientation\:\n§7yaw\: §4%d §8\= bits[8...9]\n§7pitch\: §2%d §8\= bits[10...11]\n§7§orelative to §1§oSocket
gui.rs_ctr.item_placer.sneak0=Sneaking\: No\n§8bit[12] \= §70
gui.rs_ctr.item_placer.sneak1=Sneaking\: Yes\n§8bit[12] \= §71
gui.rs_ctr.item_placer.side0=allow existing blocks\n§8bit[13] \= §70
gui.rs_ctr.item_placer.side1=don't allow existing blocks\n§8bit[13] \= §71
gui.rs_ctr.item_placer.air0=Use on Blocks\n§8bit[14] \= §70
gui.rs_ctr.item_placer.air1=Use in Air\n§8bit[14] \= §71
gui.rs_ctr.item_placer.creative0=Creative Mode\: OFF\n§8bit[7] \= §70
gui.rs_ctr.item_placer.creative1=Creative Mode\: ON\n§8bit[7] \= §71
gui.rs_ctr.ram.layout=Memory layout\: %2$d words of size %dbit
gui.rs_ctr.fmt_w=Image width\n§7for .png export\nBytes per line\n§7for .hex export
gui.rs_ctr.fmt_h=Image height\n§7for .png export
gui.rs_ctr.import_file=Import memory from file
gui.rs_ctr.export_file=Export memory to file
gui.rs_ctr.remote.key0=bit enable key
gui.rs_ctr.remote.key1=press a key ...

recipe.rs_ctr.circuit_mat=Processor Components
recipe.rs_ctr.battery=Capacitors
recipe.rs_ctr.sensors=Comparator tuning
recipe.rs_ctr.capacity=%.4u Charge
#added by ingame editor:
