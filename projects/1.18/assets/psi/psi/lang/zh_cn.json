{
  "itemGroup.psi": "Psi",
  "psi.desc": "这是一个打破第四面墙的笑话，享受吧",
  "psimisc.shift_for_info": "§7按§bSHIFT§7查看详情",
  "psimisc.component_type": "§a部件类型§7: %s",
  "psimisc.none": "（无）",
  "psimisc.stats": "属性",
  "psimisc.socketing": "弹夹",
  "psimisc.keybind": "Psi控制键位绑定",
  "psimisc.selected": "已选择",
  "psimisc.spell_selected": "§d选定魔法式§7: %s",
  "psimisc": "名称：",
  "psimisc.compiled": "编译成功",
  "psimisc.errored": "编译错误",
  "psimisc.weak_cad": "你的CAD属性太弱，还不足以施展这个魔法式.",
  "psimisc.canceled_spell": "有什么东西阻止了你施展那个术式",
  "psimisc.cancelled_cad_take": "有什么东西阻止了你制造CAD",
  "psimisc.constant": "常量",
  "psimisc.next_page": "下一页",
  "psimisc.prev_page": "上一页",
  "psimisc.config": "配置",
  "psimisc.not_your_programmer": "看起来有其他人正在使用它。最好还是不要弄乱里面的术式。",
  "psimisc.cant_use_programmer": "你还不知道如何操作这个。",
  "psimisc.level_display": "等级%d",
  "psimisc.level_info": "等级%d-等级点：%d",
  "psimisc.level_info_creative": "等级%d（创造）-等级点：%d",
  "psimisc.locked": "锁定",
  "psimisc.requirements": "需求",
  "psimisc.learn": "学习",
  "psimisc.levelup": "升级",
  "psimisc.wip": "PsiBeta | 不是最终版！",
  "psimisc.bullet_type": "§b型号§7: %s",
  "psimisc.bullet_cost": "§b消耗乘数§7: %s%%",
  "psimisc.level_up_info1": "你完成了这章教程！",
  "psimisc.level_up_info2": "卸下你的CAD然后按[%s]来看下一页吧！",
  "psimisc.import_from_clipboard": "从剪贴板导入",
  "psimisc.export_to_clipboard": "导出至剪贴板",
  "psimisc.must_hold_shift": "(按住SHIFT)",
  "psimisc.malformed_json": "导入错误：字符串格式不正确：%s",
  "psimisc.missing_pieces": "导入错误：导入的术式不存在.",
  "psimisc.load_prompt": "导入？",
  "psimisc.spectator": "[旁观模式]",
  "psimisc.multiple_cads": "物品栏中另一台CAD干涉了你的施法.你最多只能持有一台CAD.",
  "psimisc.provider_mod": "§7附属：§9%s",
  "psimisc.trick_pattern": "^启动式：(.+)$",
  "psimisc.programmer_help": "§a编写台帮助",
  "psimisc.ctrl_windows": "Ctrl",
  "psimisc.ctrl_mac": "Cmd",
  "psimisc.enter_commit": "按Enter提交",
  "psimisc.semicolon_line": "用;分隔行",
  "psimisc.programmer_coords": "选定：[%d, %d] | 光标：[%d, %d]",
  "psimisc.programmer_coords_no_cursor": "选定：[%d, %d]",
  "psimisc.name": "名称",
  "psimisc.requiredaddons": "需要附属：",
  "psimisc.modnotfound": "你试图导入的术式将不会被全部导入，因为它使用了未安装的模组%d中的术式",
  "psimisc.spellonnewerversion": "这个术式是在较新版本的Psi上创建的；它可能无法正常工作。",
  "psi.container.socketable": "弹仓",
  "psi.subtitle.bullet_create": "魔法式已储存",
  "psi.subtitle.cad_create": "CAD配装成功",
  "psi.subtitle.spell_cast": "魔法式发动",
  "psi.subtitle.loopcast": "循环演算",
  "block.psi.cad_assembler": "CAD装配器",
  "block.psi.programmer": "术式编写台",
  "block.psi.psidust_block": "Psi粉末块",
  "block.psi.psimetal_block": "Psi金属块",
  "block.psi.psigem_block": "Psi宝石块",
  "block.psi.black_psimetal_plate": "暗色Psi金属板",
  "block.psi.lit_black_psimetal_plate": "暗色Psi金属流光板",
  "block.psi.white_psimetal_plate": "亮色Psi金属板",
  "block.psi.lit_white_psimetal_plate": "亮色Psi金属流光板",
  "block.psi.ebony_psimetal_block": "乌金色Psi金属块",
  "block.psi.ivory_psimetal_block": "象牙白Psi金属块",
  "block.psi.conjured": "构筑方块",
  "block.psi.psimetal_plate_white": "亮色Psi金属板",
  "block.psi.psimetal_plate_white_light": "亮色Psi金属流光板",
  "item.psi.psidust": "Psi粉末",
  "item.psi.psimetal": "Psi金属锭",
  "item.psi.psigem": "Psi宝石",
  "item.psi.ebony_psimetal": "乌金色Psi金属锭",
  "item.psi.ivory_psimetal": "象牙白Psi金属锭",
  "item.psi.ebony_substance": "乌金色物质",
  "item.psi.ivory_substance": "象牙白物质",
  "item.psi.cad": "术式辅助演算机",
  "item.psi.cad_assembly_iron": "铁质CAD机体",
  "item.psi.cad_assembly_gold": "金质CAD机体",
  "item.psi.cad_assembly_psimetal": "Psi金属CAD机体",
  "item.psi.cad_assembly_ebony_psimetal": "乌金CAD机体",
  "item.psi.cad_assembly_ivory_psimetal": "象牙白CAD机体",
  "item.psi.cad_assembly_creative": "创造版CAD机体",
  "item.psi.cad_core_basic": "基础CAD核心",
  "item.psi.cad_core_overclocked": "超频CAD核心",
  "item.psi.cad_core_conductive": "传导CAD核心",
  "item.psi.cad_core_hyperclocked": "极频CAD核心",
  "item.psi.cad_core_radiative": "辐射CAD核心",
  "item.psi.cad_socket_basic": "基础CAD弹夹",
  "item.psi.cad_socket_signaling": "信号CAD弹夹",
  "item.psi.cad_socket_large": "大型CAD弹夹",
  "item.psi.cad_socket_transmissive": "透射CAD弹夹",
  "item.psi.cad_socket_huge": "巨型CAD弹夹",
  "item.psi.cad_battery_basic": "基础CAD电池",
  "item.psi.cad_battery_extended": "扩容CAD电池",
  "item.psi.cad_battery_ultradense": "致密CAD电池",
  "item.psi.cad_colorizer_white": "白色CAD着色器",
  "item.psi.cad_colorizer_orange": "橙色CAD着色器",
  "item.psi.cad_colorizer_magenta": "品红色CAD着色器",
  "item.psi.cad_colorizer_light_blue": "淡蓝色CAD着色器",
  "item.psi.cad_colorizer_yellow": "黄色CAD着色器",
  "item.psi.cad_colorizer_lime": "黄绿色CAD着色器",
  "item.psi.cad_colorizer_pink": "粉红色CAD着色器",
  "item.psi.cad_colorizer_gray": "灰色CAD着色器",
  "item.psi.cad_colorizer_light_gray": "淡灰色CAD着色器",
  "item.psi.cad_colorizer_cyan": "青色CAD着色器",
  "item.psi.cad_colorizer_purple": "紫色CAD着色器",
  "item.psi.cad_colorizer_blue": "蓝色CAD着色器",
  "item.psi.cad_colorizer_brown": "棕色CAD着色器",
  "item.psi.cad_colorizer_green": "绿色CAD着色器",
  "item.psi.cad_colorizer_red": "红色CAD着色器",
  "item.psi.cad_colorizer_black": "黑色CAD着色器",
  "item.psi.cad_colorizer_rainbow": "全色CAD着色器",
  "item.psi.cad_colorizer_psi": "CAD着色器",
  "item.psi.cad_colorizer_empty": "CAD着色器（空）",
  "item.psi.spell_bullet": "术式弹药",
  "item.psi.spell_bullet_active": "术式弹药（已编译）",
  "item.psi.spell_bullet_projectile": "投射型术式弹药",
  "item.psi.spell_bullet_projectile_active": "投射型术式弹药（已编译）",
  "item.psi.spell_bullet_loop": "循环型术式弹药",
  "item.psi.spell_bullet_loop_active": "循环型术式弹药（已编译）",
  "item.psi.spell_bullet_circle": "圈阵型术式弹药",
  "item.psi.spell_bullet_circle_active": "圈阵型术式弹药（已编译）",
  "item.psi.spell_bullet_grenade": "榴弹型术式弹药",
  "item.psi.spell_bullet_grenade_active": "榴弹型术式弹药（已编译）",
  "item.psi.spell_bullet_charge": "遥控型术式弹药",
  "item.psi.spell_bullet_charge_active": "遥控型术式弹药（已编译）",
  "item.psi.spell_bullet_mine": "地雷型术式弹药",
  "item.psi.spell_bullet_mine_active": "地雷型术式弹药（已编译）",
  "item.psi.spell_drive": "术式存储器",
  "item.psi.psimetal_shovel": "Psi金属锹",
  "item.psi.psimetal_pickaxe": "Psi金属镐",
  "item.psi.psimetal_axe": "Psi金属斧",
  "item.psi.psimetal_sword": "Psi金属剑",
  "item.psi.psimetal_shovel.broken": "Psi金属锹（损坏）",
  "item.psi.psimetal_pickaxe.broken": "Psi金属镐（损坏）",
  "item.psi.psimetal_axe.broken": "Psi金属斧（损坏）",
  "item.psi.psimetal_sword.broken": "Psi金属剑（损坏）",
  "item.psi.detonator": "术式引信",
  "item.psi.psimetal_exosuit_helmet": "Psi金属装甲头盔",
  "item.psi.psimetal_exosuit_chestplate": "Psi金属装甲胸甲",
  "item.psi.psimetal_exosuit_leggings": "Psi金属装甲护腿",
  "item.psi.psimetal_exosuit_boots": "Psi金属装甲靴子",
  "item.psi.psimetal_exosuit_helmet.broken": "Psi金属装甲头盔（损坏）",
  "item.psi.psimetal_exosuit_chestplate.broken": "Psi金属装甲胸甲（损坏）",
  "item.psi.psimetal_exosuit_leggings.broken": "Psi金属装甲护腿（损坏）",
  "item.psi.psimetal_exosuit_boots.broken": "Psi金属装甲靴子（损坏）",
  "item.psi.exosuit_controller": "装甲控制器",
  "item.psi.exosuit_sensor_light": "光传感器",
  "item.psi.exosuit_sensor_water": "水传感器",
  "item.psi.exosuit_sensor_heat": "热传感器",
  "item.psi.exosuit_sensor_stress": "应激传感器",
  "item.psi.exosuit_sensor_trigger": "引信传感器",
  "item.psi.vector_ruler": "矢量尺",
  "death.attack.psi-overload": "%s耗尽了他的ψ能量",
  "psi.component.assembly": "机体",
  "psi.component.core": "核心",
  "psi.component.socket": "弹夹",
  "psi.component.battery": "电池",
  "psi.component.dye": "着色器",
  "psi.cadstat.efficiency": "效率",
  "psi.cadstat.potency": "强度",
  "psi.cadstat.complexity": "复杂度",
  "psi.cadstat.projection": "映射",
  "psi.cadstat.bandwidth": "带宽",
  "psi.cadstat.sockets": "弹仓",
  "psi.cadstat.overflow": "溢值",
  "psi.spellstat.complexity": "复杂度",
  "psi.spellstat.complexity.desc": "动作数",
  "psi.spellstat.potency": "强度",
  "psi.spellstat.potency.desc": "魔法式的威力",
  "psi.spellstat.cost": "消耗",
  "psi.spellstat.cost.desc": "施展魔法式时消耗的能量",
  "psi.spellstat.projection": "映射",
  "psi.spellstat.projection.desc": "启动式总数",
  "psi.spellstat.bandwidth": "带宽",
  "psi.spellstat.bandwidth.desc": "术式宽度或高度的最大值",
  "psi.bullet_type_basic": "普通",
  "psi.bullet_type_projectile": "投射型",
  "psi.bullet_type_loopcast": "循环型",
  "psi.bullet_type_circle": "圈阵型",
  "psi.bullet_type_grenade": "榴弹型",
  "psi.bullet_type_charge": "遥控型",
  "psi.bullet_type_mine": "地雷型",
  "psi.event.none": "（事件类型未定义）",
  "psi.event.damage": "§b事件§7:受伤",
  "psi.event.tick": "§b事件§7:Tick",
  "psi.event.jump": "§b事件§7:跳跃",
  "psi.event.low_light": "§b事件§7:弱光",
  "psi.event.underwater": "§b事件§7:触水",
  "psi.event.on_fire": "§b事件§7:起火",
  "psi.event.low_hp": "§b事件§7:濒死",
  "psi.event.spell_detonate": "§b事件§7:引信信号",
  "psi.programmer_reference0": "§b键位",
  "psi.programmer_reference1": "删除术式：§bDelete",
  "psi.programmer_reference2": "清空术式：§b%1$s-Shift-Delete",
  "psi.programmer_reference3": "移动术式：§b%1$s+方向键",
  "psi.programmer_reference4": "旋转术式：§b%1$s-Shift-Left/Right",
  "psi.programmer_reference5": "垂直翻转术式：§b%1$s-Shift-Down",
  "psi.programmer_reference6": "复制/剪切/黏贴：§b%1$s-C/%1$s-X/%1$s-V",
  "psi.programmer_reference7": "撤销/重做：§b%1$s-Z/%1$s-Y",
  "psi.programmer_reference8": "打开面板/选择术式：§bEnter",
  "psi.programmer_reference9": "设置参数：§b数字键+方向键",
  "psi.programmer_reference10": "设置注释：§b%1$s-D",
  "psi.programmer_reference11": "切换焦点：§bTab",
  "psi.programmer_reference12": "显示提示文本：§bAlt",
  "psi.programmer_reference13": "移动光标：§bArrowKeys",
  "psi.programmer_reference14": "上传至 Imgur: §b%1$s-Shift-Alt-G",
  "psi.programmer_reference15": "分享到 Reddit: §b%1$s-Shift-Alt-R",
  "psi.programmer_reference16": "",
  "psi.programmer_reference17": "§b高级检索",
  "psi.programmer_reference18": "接收类型：§bin：（类型）",
  "psi.programmer_reference19": "输出类型：§bout：（类型）",
  "psi.programmer_reference20": "以……开头：§b（名称）_",
  "psi.programmer_reference21": "以……结尾：§b_（名称）",
  "psi.programmer_reference22": "Mod名：§b@（名称）",
  "psi.spellpiece.selector_caster": "选择符：施术者",
  "psi.spellpiece.selector_caster.desc": "获取展开术式的人",
  "psi.spellpiece.selector_focal_point": "选择符：焦点",
  "psi.spellpiece.selector_focal_point.desc": "获取该魔法式焦点所属的实体",
  "psi.spellpiece.selector_nearby_items": "选择符：附近物品",
  "psi.spellpiece.selector_nearby_items.desc": "获取指定位置附近的物品",
  "psi.spellpiece.selector_nearby_living": "选择符：附近生物",
  "psi.spellpiece.selector_nearby_living.desc": "获取指定位置附近的生物",
  "psi.spellpiece.selector_nearby_enemies": "选择符：附近敌对生物",
  "psi.spellpiece.selector_nearby_enemies.desc": "获取指定位置附近的敌对生物",
  "psi.spellpiece.selector_nearby_animals": "选择符：附近动物",
  "psi.spellpiece.selector_nearby_animals.desc": "获取指定位置附近的动物",
  "psi.spellpiece.selector_nearby_projectiles": "选择符：附近投射物",
  "psi.spellpiece.selector_nearby_projectiles.desc": "获取指定位置附近的投射物",
  "psi.spellpiece.selector_nearby_smeltables": "选择符：附近可熔物",
  "psi.spellpiece.selector_nearby_smeltables.desc": "获取指定位置附近的可熔炼物品",
  "psi.spellpiece.selector_loopcast_index": "选择符：循环型次数",
  "psi.spellpiece.selector_loopcast_index.desc": "获取循环型弹药已循环的次数",
  "psi.spellpiece.selector_block_broken": "选择符：被破坏的方块",
  "psi.spellpiece.selector_block_broken.desc": "获取被破坏的方块的位置（仅工具可用）",
  "psi.spellpiece.selector_block_side_broken": "选择符：被破环的方块 | 挖掘面",
  "psi.spellpiece.selector_block_side_broken.desc": "获取被破坏的方块的被挖掘面的法向量（仅工具可用）",
  "psi.spellpiece.selector_attack_target": "选择符：攻击目标",
  "psi.spellpiece.selector_attack_target.desc": "获取需要攻击的实体",
  "psi.spellpiece.selector_sneak_status": "选择符：潜行状态",
  "psi.spellpiece.selector_sneak_status.desc": "获取施术者潜行状态(未潜行为1，潜行时为0)",
  "psi.spellpiece.selector_time": "选择符：时间",
  "psi.spellpiece.selector_time.desc": "获取CAD的内部时间(以tick计)",
  "psi.spellpiece.selector_attacker": "选择符：攻击者",
  "psi.spellpiece.selector_attacker.desc": "获取攻击施术者的实体",
  "psi.spellpiece.selector_damage_taken": "选择符：受到的伤害",
  "psi.spellpiece.selector_damage_taken.desc": "获取施术者受到的伤害",
  "psi.spellpiece.selector_ruler_vector": "选择符：矢量尺",
  "psi.spellpiece.selector_ruler_vector.desc": "获取矢量尺界定的矢量",
  "psi.spellpiece.selector_item_presence": "选择符：物品存在性",
  "psi.spellpiece.selector_item_presence.desc": "获取物品栏中指定物品的数量",
  "psi.spellpiece.selector_block_presence": "选择符：方块存在性",
  "psi.spellpiece.selector_block_presence.desc": "获取一个方块的存在性以及其固体性",
  "psi.spellpiece.selector_saved_vector": "选择符：读取矢量",
  "psi.spellpiece.selector_saved_vector.desc": "从CAD内存中读取一个储存的矢量",
  "psi.spellpiece.selector_eidos_changelog": "选择符：时空变更记录",
  "psi.spellpiece.selector_eidos_changelog.desc": "从时空变更记录中读取一个位置",
  "psi.spellpiece.selector_nearby_charges": "选择符：遥控型弹药",
  "psi.spellpiece.selector_nearby_charges.desc": "获取指定位置附近的遥控型弹药的数量",
  "psi.spellpiece.selector_nearby_players": "选择符：附近玩家",
  "psi.spellpiece.selector_nearby_players.desc": "获取指定位置附近的玩家",
  "psi.spellpiece.selector_nearby_vehicles": "选择符：附近可骑乘实体",
  "psi.spellpiece.selector_nearby_vehicles.desc": "获取指定位置附近可骑乘的实体",
  "psi.spellpiece.selector_nearby_falling_blocks": "选择符：附近下落方块",
  "psi.spellpiece.selector_nearby_falling_blocks.desc": "获取指定位置附近的下落中的方块",
  "psi.spellpiece.selector_nearby_glowing": "选择符：高亮",
  "psi.spellpiece.selector_nearby_glowing.desc": "获取指定位置附近高亮/发光的实体",
  "psi.spellpiece.selector_caster_energy": "选择符：施术者能量",
  "psi.spellpiece.selector_caster_energy.desc": "获取施术者能量等级",
  "psi.spellpiece.selector_caster_battery": "选择符：电池",
  "psi.spellpiece.selector_caster_battery.desc": "获取CAD电池能量等级",
  "psi.spellpiece.selector_sucession_counter": "选择符：成功次数",
  "psi.spellpiece.selector_sucession_counter.desc": "获取装甲成功施展的魔法式的次数",
  "psi.spellpiece.selector_is_elytra_flying": "选择符：装备鞘翅",
  "psi.spellpiece.selector_is_elytra_flying.desc": "如果施术者装备有鞘翅，则返回1",
  "psi.spellpiece.selector_transmission": "选择符：最新消息",
  "psi.spellpiece.selector_transmission.desc": "获取此CAD在指定频道中收到的最后一条消息",
  "psi.spellpiece.selector_item_count": "选择符：物品数量",
  "psi.spellpiece.selector_item_count.desc": "计算背包中与目标格相同的物品的数量",
  "psi.spellpiece.operator_sum": "运算符：加法",
  "psi.spellpiece.operator_sum.desc": "A+B(+C)",
  "psi.spellpiece.operator_subtract": "运算符：减法",
  "psi.spellpiece.operator_subtract.desc": "A-B(-C)",
  "psi.spellpiece.operator_multiply": "运算符：乘法",
  "psi.spellpiece.operator_multiply.desc": "A*B(*C)",
  "psi.spellpiece.operator_divide": "运算符：除法",
  "psi.spellpiece.operator_divide.desc": "A/B",
  "psi.spellpiece.operator_absolute": "运算符：绝对值",
  "psi.spellpiece.operator_absolute.desc": "计算一个数的绝对值",
  "psi.spellpiece.operator_inverse": "运算符：倒数",
  "psi.spellpiece.operator_inverse.desc": "计算一个数的倒数",
  "psi.spellpiece.operator_modulus": "运算符：求余",
  "psi.spellpiece.operator_modulus.desc": "A%%B（取整）",
  "psi.spellpiece.operator_integer_divide": "运算符：整除",
  "psi.spellpiece.operator_integer_divide.desc": "A/B（取整）",
  "psi.spellpiece.operator_random": "运算符：随机",
  "psi.spellpiece.operator_random.desc": "返回在下限（默认为 0）与给定上限（不包含） 之间随机生成的数值",
  "psi.spellpiece.operator_sin": "运算符：正弦",
  "psi.spellpiece.operator_sin.desc": "sin(A)",
  "psi.spellpiece.operator_cos": "运算符：余弦",
  "psi.spellpiece.operator_cos.desc": "cos(A)",
  "psi.spellpiece.operator_asin": "运算符：反正弦",
  "psi.spellpiece.operator_asin.desc": "asin(A)",
  "psi.spellpiece.operator_acos": "运算符：反余弦",
  "psi.spellpiece.operator_acos.desc": "acos(A)",
  "psi.spellpiece.operator_max": "运算符：最大值",
  "psi.spellpiece.operator_max.desc": "获取输入值中的最大值",
  "psi.spellpiece.operator_min": "运算符：最小值",
  "psi.spellpiece.operator_min.desc": "获取输入值中的最小值",
  "psi.spellpiece.operator_square": "运算符：平方",
  "psi.spellpiece.operator_square.desc": "A^2",
  "psi.spellpiece.operator_cube": "运算符：立方",
  "psi.spellpiece.operator_cube.desc": "A^3",
  "psi.spellpiece.operator_power": "运算符：幂",
  "psi.spellpiece.operator_power.desc": "A^B",
  "psi.spellpiece.operator_square_root": "运算符：平方根",
  "psi.spellpiece.operator_square_root.desc": "sqrt(A)",
  "psi.spellpiece.operator_log": "运算符：对数",
  "psi.spellpiece.operator_log.desc": "log(A)或logB(A)",
  "psi.spellpiece.operator_ceiling": "运算符：向上取整",
  "psi.spellpiece.operator_ceiling.desc": "将一个数向上取整",
  "psi.spellpiece.operator_floor": "运算符：向下取整",
  "psi.spellpiece.operator_floor.desc": "将一个数向下取整",
  "psi.spellpiece.operator_round": "运算符：四舍五入",
  "psi.spellpiece.operator_round.desc": "将一个数四舍五入取整",
  "psi.spellpiece.operator_entity_position": "运算符：实体位置",
  "psi.spellpiece.operator_entity_position.desc": "获取一个实体的位置",
  "psi.spellpiece.operator_entity_look": "运算符：实体视线",
  "psi.spellpiece.operator_entity_look.desc": "获取一个实体的视线矢量",
  "psi.spellpiece.operator_entity_motion": "运算符：实体运动",
  "psi.spellpiece.operator_entity_motion.desc": "获取一个实体的运动矢量",
  "psi.spellpiece.operator_entity_axial_look": "运算符：实体轴向视线",
  "psi.spellpiece.operator_entity_axial_look.desc": "获取一个实体的视线矢量，与某一轴对齐",
  "psi.spellpiece.operator_focused_entity": "运算符：焦点实体",
  "psi.spellpiece.operator_focused_entity.desc": "获取指定实体所看的实体",
  "psi.spellpiece.operator_vector_raycast": "运算符：矢量追踪",
  "psi.spellpiece.operator_vector_raycast.desc": "获取射线追踪目标方块的坐标(最大范围32)",
  "psi.spellpiece.operator_vector_raycast_axis": "运算符：矢量轴向追踪",
  "psi.spellpiece.operator_vector_raycast_axis.desc": "获取射线追踪目标方块所指向面的法向单位矢量(最大范围32)",
  "psi.spellpiece.operator_vector_sum": "运算符：矢量和",
  "psi.spellpiece.operator_vector_sum.desc": "A+B(+C)",
  "psi.spellpiece.operator_vector_subtract": "运算符：矢量差",
  "psi.spellpiece.operator_vector_subtract.desc": "A-B(-C)",
  "psi.spellpiece.operator_vector_multiply": "运算符：矢量乘",
  "psi.spellpiece.operator_vector_multiply.desc": "A*B",
  "psi.spellpiece.operator_vector_divide": "运算符：矢量除",
  "psi.spellpiece.operator_vector_divide.desc": "A/B",
  "psi.spellpiece.operator_vector_cross_product": "运算符：矢量叉乘",
  "psi.spellpiece.operator_vector_cross_product.desc": "AxB",
  "psi.spellpiece.operator_vector_normalize": "运算符：矢量归一化",
  "psi.spellpiece.operator_vector_normalize.desc": "归一化一个矢量使其模为1",
  "psi.spellpiece.operator_vector_negate": "运算符：反向矢量",
  "psi.spellpiece.operator_vector_negate.desc": "求出一反向矢量",
  "psi.spellpiece.operator_vector_magnitude": "运算符：矢量模长",
  "psi.spellpiece.operator_vector_magnitude.desc": "获取一个矢量的模",
  "psi.spellpiece.operator_vector_construct": "运算符：矢量构造",
  "psi.spellpiece.operator_vector_construct.desc": "通过XYZ三个参数构造一个矢量",
  "psi.spellpiece.operator_vector_extract_x": "运算符：提取矢量X",
  "psi.spellpiece.operator_vector_extract_x.desc": "从一个矢量中提取X坐标值",
  "psi.spellpiece.operator_vector_extract_y": "运算符：提取矢量Y",
  "psi.spellpiece.operator_vector_extract_y.desc": "从一个矢量中提取Y坐标值",
  "psi.spellpiece.operator_vector_extract_z": "运算符：提取矢量Z",
  "psi.spellpiece.operator_vector_extract_z.desc": "从一个矢量中提取Z坐标值",
  "psi.spellpiece.operator_vector_project": "运算符：矢量投影",
  "psi.spellpiece.operator_vector_project.desc": "将矢量A投影到矢量B",
  "psi.spellpiece.operator_vector_dot_product": "运算符：矢量点乘",
  "psi.spellpiece.operator_vector_dot_product.desc": "A.B",
  "psi.spellpiece.operator_closest_to_point": "运算符：离点最近",
  "psi.spellpiece.operator_closest_to_point.desc": "从列表中获取距离某一点最近的实体",
  "psi.spellpiece.operator_random_entity": "运算符：随机实体",
  "psi.spellpiece.operator_random_entity.desc": "从列表中随机获取一个实体",
  "psi.spellpiece.operator_list_add": "运算符：加入列表",
  "psi.spellpiece.operator_list_add.desc": "将指定实体加入列表",
  "psi.spellpiece.operator_list_remove": "运算符：移出列表",
  "psi.spellpiece.operator_list_remove.desc": "将指定实体移出列表",
  "psi.spellpiece.operator_planar_normal_vector": "运算符：平面法向矢量",
  "psi.spellpiece.operator_planar_normal_vector.desc": "通过两个交叉的矢量获取一个法向矢量。等价于：基于<1,1,1>旋转2π/3",
  "psi.spellpiece.operator_vector_rotate": "运算符：旋转矢量",
  "psi.spellpiece.operator_vector_rotate.desc": "环绕一个轴旋转矢量",
  "psi.spellpiece.operator_gamma_function": "运算符：伽玛函数",
  "psi.spellpiece.operator_gamma_function.desc": "Γ(x)，等价于(x-1)！",
  "psi.spellpiece.operator_list_size": "运算符：列表大小",
  "psi.spellpiece.operator_list_size.desc": "获取列表中元素的数量",
  "psi.spellpiece.operator_list_union": "运算符：合并列表",
  "psi.spellpiece.operator_list_union.desc": "将两个列表合并为一个",
  "psi.spellpiece.operator_list_intersection": "运算符：列表求交",
  "psi.spellpiece.operator_list_intersection.desc": "求两个列表的交集",
  "psi.spellpiece.operator_list_exclusion": "运算符：列表求差",
  "psi.spellpiece.operator_list_exclusion.desc": "返回从第一个列表中除去第二个列表中的元素的结果",
  "psi.spellpiece.operator_list_index": "选择符：元素索引",
  "psi.spellpiece.operator_list_index.desc": "从实体列表中获取指定索引的实体",
  "psi.spellpiece.operator_root": "运算符：次方根",
  "psi.spellpiece.operator_root.desc": "取一个数的n次方根",
  "psi.spellpiece.operator_extract_sign": "运算符：符号位",
  "psi.spellpiece.operator_extract_sign.desc": "获取输入值的符号位（正0负1）",
  "psi.spellpiece.operator_vector_extract_sign": "运算符：符号位矢量",
  "psi.spellpiece.operator_vector_extract_sign.desc": "根据指定矢量各参数数值的符号位构建一个矢量",
  "psi.spellpiece.operator_closest_to_line": "运算符：离线最近",
  "psi.spellpiece.operator_closest_to_line.desc": "获取离指定线段最近的实体",
  "psi.spellpiece.operator_entity_health": "运算符：实体生命值",
  "psi.spellpiece.operator_entity_health.desc": "获取指定实体当前生命值百分比",
  "psi.spellpiece.operator_vector_absolute": "运算符：矢量绝对值",
  "psi.spellpiece.operator_vector_absolute.desc": "根据指定矢量各参数数值的绝对值构造一个矢量",
  "psi.spellpiece.operator_entity_raycast": "运算符：射线追踪-实体",
  "psi.spellpiece.operator_entity_raycast.desc": "从指定位置开始进行射线追踪，返回第一个追踪到的实体",
  "psi.spellpiece.operator_block_light": "运算符：方块亮度",
  "psi.spellpiece.operator_block_light.desc": "获取方块的亮度",
  "psi.spellpiece.operator_block_hardness.desc": "获取方块的硬度",
  "psi.spellpiece.operator_block_hardness": "运算符：方块硬度",
  "psi.spellpiece.operator_block_comparator_strength": "运算符：方块比较器",
  "psi.spellpiece.operator_block_comparator_strength.desc": "获取指定方块的比较器强度数值",
  "psi.spellpiece.operator_block_side_solidity": "运算符：方块面固体性",
  "psi.spellpiece.operator_block_side_solidity.desc": "获取指定方块的面是否是固体",
  "psi.spellpiece.operator_block_mining_level": "运算符：方块挖掘等级",
  "psi.spellpiece.operator_block_mining_level.desc": "获取指定位置的方块的挖掘等级",
  "psi.spellpiece.operator_vector_piecewise_maximum": "运算符：矢量分段最大值",
  "psi.spellpiece.operator_vector_piecewise_maximum.desc": "通过输入矢量各个对应参数的最大值构建矢量",
  "psi.spellpiece.operator_vector_piecewise_minimum": "运算符：矢量分段最小值",
  "psi.spellpiece.operator_vector_piecewise_minimum.desc": "通过输入矢量各个对应参数的最小值构建矢量",
  "psi.spellpiece.operator_entity_height": "运算符：实体高度",
  "psi.spellpiece.operator_entity_height.desc": "获取指定实体的高度",
  "psi.spellpiece.constant_number": "常量：数值",
  "psi.spellpiece.constant_number.desc": "选择然后输入以设定值",
  "psi.spellpiece.constant_pi": "常量：Pi",
  "psi.spellpiece.constant_pi.desc": "返回圆周率Pi的值",
  "psi.spellpiece.constant_e": "常量：e",
  "psi.spellpiece.constant_e.desc": "返回自然对数底数e的值",
  "psi.spellpiece.constant_tau": "常量：Tau",
  "psi.spellpiece.constant_tau.desc": "返回Tau的数值",
  "psi.spellpiece.constant_wrapper": "常量：封装",
  "psi.spellpiece.constant_wrapper.desc": "将一个变量封装为常量以用于属性计算",
  "psi.spellpiece.connector": "连接符",
  "psi.spellpiece.connector.desc": "起连接程序的作用",
  "psi.spellpiece.cross_connector": "十字连接符",
  "psi.spellpiece.cross_connector.desc": "可以连接两条路径",
  "psi.spellpiece.error_suppressor": "错误消除符",
  "psi.spellpiece.error_suppressor.desc": "消除魔法式产生的错误",
  "psi.spellpiece.error_catch": "错误捕获符",
  "psi.spellpiece.error_catch.desc": "用指定值替换错误",
  "psi.spellpiece.trick_debug": "启动式：调试",
  "psi.spellpiece.trick_debug.desc": "测试用，输出目标调试信息",
  "psi.spellpiece.trick_delay": "启动式：休眠",
  "psi.spellpiece.trick_delay.desc": "延迟术式指定tick时间",
  "psi.spellpiece.trick_die": "启动式：终结",
  "psi.spellpiece.trick_die.desc": "如果输入值处于(-1, 1)区间内则停止魔法式的执行",
  "psi.spellpiece.trick_evaluate": "启动式：求值",
  "psi.spellpiece.trick_evaluate.desc": "对指定目标求值，不作任何改变",
  "psi.spellpiece.trick_add_motion": "启动式：附加运动",
  "psi.spellpiece.trick_add_motion.desc": "给予实体一个特定方向上的速度",
  "psi.spellpiece.trick_explode": "启动式：爆炸",
  "psi.spellpiece.trick_explode.desc": "产生爆炸",
  "psi.spellpiece.trick_break_block": "启动式：破坏方块",
  "psi.spellpiece.trick_break_block.desc": "破坏一个方块",
  "psi.spellpiece.trick_break_in_sequence": "启动式：破坏方块序列",
  "psi.spellpiece.trick_break_in_sequence.desc": "破坏指定方向上的一系列方块",
  "psi.spellpiece.trick_place_block": "启动式：放置方块",
  "psi.spellpiece.trick_place_block.desc": "放置一个方块",
  "psi.spellpiece.trick_place_in_sequence": "启动式：放置方块序列",
  "psi.spellpiece.trick_place_in_sequence.desc": "在指定方向上放置一系列方块",
  "psi.spellpiece.trick_infusion": "启动式：灌注",
  "psi.spellpiece.trick_infusion.desc": "将金锭转换为Psi金属，将红石粉转换为Psi粉末",
  "psi.spellpiece.trick_blink": "启动式：闪现",
  "psi.spellpiece.trick_blink.desc": "向前方闪现",
  "psi.spellpiece.trick_mass_blink": "启动式：群体闪现",
  "psi.spellpiece.trick_mass_blink.desc": "让指定的生物朝它们所看方向闪现一段距离",
  "psi.spellpiece.trick_mass_add_motion": "启动式：群体运动",
  "psi.spellpiece.trick_mass_add_motion.desc": "给予实体列表内的所有实体一个速度",
  "psi.spellpiece.trick_mass_exodus": "启动式：群体移动",
  "psi.spellpiece.trick_mass_exodus.desc": "将实体列表内所有实体附加一个指向指定位置方向的速度",
  "psi.spellpiece.trick_move_block": "启动式：移动方块",
  "psi.spellpiece.trick_move_block.desc": "将一个方块沿单位轴向矢量移动",
  "psi.spellpiece.trick_move_block_sequence": "启动式：移动方块序列",
  "psi.spellpiece.trick_move_block_sequence.desc": "沿单位轴向矢量移动一系列方块",
  "psi.spellpiece.trick_collapse_block": "启动式：方块崩塌",
  "psi.spellpiece.trick_collapse_block.desc": "使一个方块像沙子般下落",
  "psi.spellpiece.trick_smite": "启动式：雷击",
  "psi.spellpiece.trick_smite.desc": "在指定点召唤闪电",
  "psi.spellpiece.trick_blaze": "启动式：烈焰",
  "psi.spellpiece.trick_blaze.desc": "在指定点制造火焰",
  "psi.spellpiece.trick_torrent": "启动式：洪流",
  "psi.spellpiece.trick_torrent.desc": "在指定点制造流水",
  "psi.spellpiece.trick_overgrow": "启动式：催生",
  "psi.spellpiece.trick_overgrow.desc": "催生指定点的方块",
  "psi.spellpiece.trick_greater_infusion": "启动式：高级灌注",
  "psi.spellpiece.trick_greater_infusion.desc": "将钻石转变为Psi宝石，同时也可灌注红石粉和金锭",
  "psi.spellpiece.trick_ebony_ivory": "启动式：阴阳变化",
  "psi.spellpiece.trick_ebony_ivory.desc": "灌注煤炭和石英.必须在末地进行，同样可以灌注红石，金锭和钻石",
  "psi.spellpiece.trick_speed": "启动式：速度",
  "psi.spellpiece.trick_speed.desc": "赋予速度效果",
  "psi.spellpiece.trick_haste": "启动式：急迫",
  "psi.spellpiece.trick_haste.desc": "赋予急迫效果",
  "psi.spellpiece.trick_strength": "启动式：力量",
  "psi.spellpiece.trick_strength.desc": "赋予力量效果",
  "psi.spellpiece.trick_jump_boost": "启动式：跳跃提升",
  "psi.spellpiece.trick_jump_boost.desc": "赋予跳跃提升效果",
  "psi.spellpiece.trick_water_breathing": "启动式：水肺",
  "psi.spellpiece.trick_water_breathing.desc": "赋予水下呼吸效果",
  "psi.spellpiece.trick_fire_resistance": "启动式：抗火",
  "psi.spellpiece.trick_fire_resistance.desc": "赋予抗火效果",
  "psi.spellpiece.trick_invisibility": "启动式：隐形",
  "psi.spellpiece.trick_invisibility.desc": "赋予隐身效果",
  "psi.spellpiece.trick_regeneration": "启动式：再生",
  "psi.spellpiece.trick_regeneration.desc": "赋予再生效果",
  "psi.spellpiece.trick_resistance": "启动式：抗性",
  "psi.spellpiece.trick_resistance.desc": "赋予抗性效果",
  "psi.spellpiece.trick_slowness": "启动式：缓慢",
  "psi.spellpiece.trick_slowness.desc": "赋予缓慢效果",
  "psi.spellpiece.trick_weakness": "启动式：虚弱",
  "psi.spellpiece.trick_weakness.desc": "赋予虚弱效果",
  "psi.spellpiece.trick_wither": "启动式：凋零",
  "psi.spellpiece.trick_wither.desc": "赋予凋零效果",
  "psi.spellpiece.trick_ignite": "启动式：引燃",
  "psi.spellpiece.trick_ignite.desc": "使一个实体燃烧起来",
  "psi.spellpiece.trick_eidos_anchor": "启动式：时空之锚",
  "psi.spellpiece.trick_eidos_anchor.desc": "在指定时间后将施术者送回当前位置",
  "psi.spellpiece.trick_eidos_reversal": "启动式：时空逆流",
  "psi.spellpiece.trick_eidos_reversal.desc": "让施术者时光倒流",
  "psi.spellpiece.trick_smelt_item": "启动式：熔炼物品",
  "psi.spellpiece.trick_smelt_item.desc": "将一个物品实体熔炼为对应的产物",
  "psi.spellpiece.trick_smelt_block": "启动式：熔炼方块",
  "psi.spellpiece.trick_smelt_block.desc": "将一个方块熔炼为对应的产物",
  "psi.spellpiece.trick_conjure_block": "启动式：构筑方块",
  "psi.spellpiece.trick_conjure_block.desc": "在指定位置构筑一个方块",
  "psi.spellpiece.trick_conjure_light": "启动式：构筑光线",
  "psi.spellpiece.trick_conjure_light.desc": "在指定位置构筑一团亮光",
  "psi.spellpiece.trick_conjure_block_sequence": "启动式：构筑方块序列",
  "psi.spellpiece.trick_conjure_block_sequence.desc": "在指定方向上构筑一系列的方块",
  "psi.spellpiece.trick_switch_target_slot": "启动式：切换焦点槽位（快捷栏）",
  "psi.spellpiece.trick_switch_target_slot.desc": "改变快捷栏的焦点槽位",
  "psi.spellpiece.trick_save_vector": "启动式：储存矢量",
  "psi.spellpiece.trick_save_vector.desc": "将一个矢量存入CAD的内存中",
  "psi.spellpiece.trick_play_sound": "启动式：播放音符",
  "psi.spellpiece.trick_play_sound.desc": "播放音符盒的一个声音",
  "psi.spellpiece.trick_break_loop": "启动式：终止循环",
  "psi.spellpiece.trick_break_loop.desc": "如果输入值在(-1, 1)区间内则终止循环",
  "psi.spellpiece.trick_detonate": "启动式：触发引信",
  "psi.spellpiece.trick_detonate.desc": "触发指定位置半径32格内所有的遥控型弹药",
  "psi.spellpiece.trick_till": "启动式：犁地",
  "psi.spellpiece.trick_till.desc": "犁一个方块",
  "psi.spellpiece.trick_till_sequence": "启动式：犁方块序列",
  "psi.spellpiece.trick_till_sequence.desc": "犁指定方向上一系列方块",
  "psi.spellpiece.trick_broadcast": "启动式：广播",
  "psi.spellpiece.trick_broadcast.desc": "在指定的频道上广播一个号码到附近的CAD",
  "psi.spellpiece.trick_change_slot": "启动式：设置焦点槽位（背包）",
  "psi.spellpiece.trick_change_slot.desc": "将焦点槽位设定为背包内任意槽位",
  "psi.spellpiece.trick_smelt_block_sequence": "启动式：熔炼方块序列",
  "psi.spellpiece.trick_smelt_block_sequence.desc": "熔炼指定方向上一系列方块",
  "psi.spellpiece.trick_collapse_block_sequence": "启动式：崩塌方块序列",
  "psi.spellpiece.trick_collapse_block_sequence.desc": "让一系列方块像沙子一样崩塌",
  "psi.spellpiece.trick_debug_spamless": "启动式：频道调试",
  "psi.spellpiece.trick_debug_spamless.desc": "输出目标调试信息，替换之前同一频道的信息",
  "psi.spellpiece.trick_night_vision": "启动式：夜视",
  "psi.spellpiece.trick_night_vision.desc": "赋予夜视效果",
  "psi.spellpiece.trick_particle_trail": "启动式：粒子轨迹",
  "psi.spellpiece.trick_particle_trail.desc": "从指定位置沿指定方向产生粒子轨迹",
  "psi.spellpiece.trick_spin_chamber": "启动式：旋转装弹",
  "psi.spellpiece.trick_spin_chamber.desc": "根据输入选择下一个/上一个术式弹药",
  "psi.spellpiece.trick_russian_roulette": "启动式：俄罗斯转盘",
  "psi.spellpiece.trick_russian_roulette.desc": "随机选择一个术式弹药",
  "psi.spellparam.target": "目标",
  "psi.spellparam.number": "数值",
  "psi.spellparam.root": "次方根",
  "psi.spellparam.list1": "列表A",
  "psi.spellparam.list2": "列表B",
  "psi.spellparam.list": "列表",
  "psi.spellparam.from1": "源 1",
  "psi.spellparam.from2": "源 2",
  "psi.spellparam.to1": "目标 1",
  "psi.spellparam.to2": "目标 2",
  "psi.spellparam.toggle": "切换",
  "psi.spellparam.number1": "数值A",
  "psi.spellparam.number2": "数值B",
  "psi.spellparam.number3": "数值C",
  "psi.spellparam.number4": "数值D",
  "psi.spellparam.vector1": "矢量A",
  "psi.spellparam.vector2": "矢量B",
  "psi.spellparam.vector3": "矢量C",
  "psi.spellparam.vector4": "矢量D",
  "psi.spellparam.position": "位置",
  "psi.spellparam.ray": "射线",
  "psi.spellparam.max": "最大",
  "psi.spellparam.min": "最小",
  "psi.spellparam.power": "级别",
  "psi.spellparam.direction": "方向",
  "psi.spellparam.speed": "速度",
  "psi.spellparam.x": "X",
  "psi.spellparam.y": "Y",
  "psi.spellparam.z": "Z",
  "psi.spellparam.radius": "半径",
  "psi.spellparam.distance": "距离",
  "psi.spellparam.time": "时间",
  "psi.spellparam.constant": "常量",
  "psi.spellparam.shift": "移位",
  "psi.spellparam.slot": "槽位",
  "psi.spellparam.base": "底",
  "psi.spellparam.vector": "矢量",
  "psi.spellparam.axis": "轴",
  "psi.spellparam.angle": "角度",
  "psi.spellparam.channel": "频道",
  "psi.spellparam.instrument": "乐器",
  "psi.spellparam.volume": "音量",
  "psi.spellparam.pitch": "音高",
  "psi.spellparam.mask": "图案",
  "psi.spellparam.ray_end": "射线终点",
  "psi.spellparam.ray_start": "射线起点",
  "psi.spellparam.fallback": "后退",
  "psi.datatype.void": "无",
  "psi.datatype.any": "任意",
  "psi.datatype.double": "浮点数",
  "psi.datatype.integer": "整数",
  "psi.datatype.number": "数值",
  "psi.datatype.vector3": "矢量",
  "psi.datatype.entity": "实体",
  "psi.datatype.living_entity": "实体（生物）",
  "psi.datatype.living_entity_base": "实体（生物）",
  "psi.datatype.player_entity": "实体（玩家）",
  "psi.datatype.entity_list_wrapper": "实体列表",
  "psi.spellerror.nospell": "无可供编译的魔法式",
  "psi.spellerror.invalid_base": "错误：无法解析低于2的底",
  "psi.spellerror.nthroot": "错误：偶数次方根不接受负数",
  "psi.spellerror.noname": "魔法式未命名",
  "psi.spellerror.notricks": "魔法式中缺少启动式",
  "psi.spellerror.unsetparam": "所需参数尚未设定",
  "psi.spellerror.nullparam": "指定的参数不能为空",
  "psi.spellerror.invalidparam": "指定的参数无效",
  "psi.spellerror.samesideparams": "两个或以上的参数共用一侧",
  "psi.spellerror.loop": "术式之间循环引用",
  "psi.spellerror.nonpositivevalue": "指定的参数必须是一个正数",
  "psi.spellerror.noninteger": "指定的参数必须是一个整数",
  "psi.spellerror.nonpositiveinteger": "指定的参数必须是一个正整数",
  "psi.spellerror.statoverflow": "魔法式属性溢值超出最大限制",
  "psi.spellerror.exclusiveparams": "设定了两个互斥的参数",
  "psi.spellerror.position": "错误位置·:[%d, %d].",
  "psi.spellerror.dividebyzero": "错误：不能除以0.",
  "psi.spellerror.nulltarget": "错误：术式目标实体不存在.",
  "psi.spellerror.nullvector": "错误：术式运算矢量不存在或无效.",
  "psi.spellerror.outsideradius": "错误：术式的目标超出了32格半径限制。",
  "psi.spellerror.outsidetrigdomain": "错误：数值超出了反三角函数域.",
  "psi.spellerror.bossimmune": "错误：尝试对免疫伤害的实体/boss施展魔法式",
  "psi.spellerror.nocad": "错误：施术者无CAD.",
  "psi.spellerror.memoryoutofbounds": "错误：内存访问越界.",
  "psi.spellerror.lockedmemory": "错误：内存槽位被锁定.",
  "psi.spellerror.immunetarget": "错误：目标实体免疫伤害或为boss.",
  "psi.spellerror.negativenumber": "错误：术式中的目标数值不能为负数.",
  "psi.spellerror.nonaxial": "错误：矢量不能为非轴向矢量",
  "psi.spellerror.volume": "错误：音量必须在[0,1]范围内",
  "psi.spellerror.instruments": "错误：乐器的值必须在[0,15]区间内",
  "psi.spellerror.pitch": "错误：音高必须在[0,24]区间内",
  "psi.spellerror.out_of_bounds": "错误：提供的索引不在列表范围内",
  "psi.levelskip": "Psi找到了之前存档的数据.<br>你想要加载这些数据吗？<br><br>如果选择是，那么你的等级就会立即变为%d.选择否的话，这条信息不会再次出现.",
  "psi.spellerror.armor": "错误：选择符仅能通过装甲施展",
  "psi.spellerror.no_message": "错误：CAD未收到广播的消息",
  "psi.spellerror.comparator": "错误：比较器只能在四个基本方向上测量",
  "psi.spellerror.cad_casting_only": "错误：这个术式必须通过CAD施展",
  "command.psi.learn.usage": "/psi-learn<group>[player]",
  "command.psi.learn.success": "%s习得Psi项目：%s",
  "command.psi.learn.success.all": "%s已解锁所有Psi项目",
  "command.psi.learn.should_not": "%s已习得Psi项目：%s",
  "command.psi.learn.players": "%s不是一名玩家，只有玩家能习得Psi项目",
  "command.psi.learn.console": "后台不能习得Psi项目，请指定一名玩家！/psi-learn<group>[player]",
  "command.psi.learn.not_a_group": "'%s'不是有效的Psi术式组",
  "command.psi.learn.unknown": "这名玩家没有Psi数据，请向模组作者报告这一错误。",
  "command.psi.unlearn.usage": "/psi-unlearn<group>[player]",
  "command.psi.unlearn.success": "%s已锁定Psi项目： %s",
  "command.psi.unlearn.success.all": "%s已锁定所有Psi项目",
  "command.psi.unlearn.should_not": "%s还未习得Psi项目： %s",
  "command.psi.unlearn.players": "%s不是一名玩家，只有玩家能有Psi项目",
  "command.psi.unlearn.console": "后台不能锁定Psi项目，请指定一名玩家！/psi-unlearn<group>[player]",
  "command.psi.unlearn.not_a_group": "'%s'不是有效的Psi术式组",
  "command.psi.unlearn.unknown": "这名玩家没有Psi数据，请向模组作者报告这一错误。",
  "psi.tutorial1": "教程1",
  "psi.tutorial2": "教程2",
  "psi.tutorial3": "教程3",
  "psi.tutorial4": "教程4",
  "psi.numbers_intro": "数值101",
  "psi.vectors_intro": "矢量101",
  "psi.entities_intro": "实体101",
  "psi.projectiles": "发射投射型术式",
  "psi.block_works": "方块操作",
  "psi.infusion": "Psi金属灌注",
  "psi.movement": "高级移动",
  "psi.loopcasting": "循环型术式",
  "psi.block_movement": "移动方块",
  "psi.elemental_arts": "元素艺术",
  "psi.greater_infusion": "更好的灌注",
  "psi.tool_casting": "工具施法",
  "psi.positive_effects": "正面效果",
  "psi.negative_effects": "负面效果",
  "psi.exosuit_casting": "装甲施法",
  "psi.trignometry": "三角函数",
  "psi.smeltery": "冶炼",
  "psi.flow_control": "流程控制",
  "psi.block_conjuration": "方块构筑术",
  "psi.eidos_ceversal": "时空操作",
  "psi.detection_dynamics": "探测&聚焦",
  "psi.memory_management": "内存管理",
  "psi.secondary_operators": "次级运算符",
  "psi.misc_tricks": "其它术式",
  "psi.list_operations": "列表操作",
  "psi.fake_level_psidust": "Psi粉末灌注",
  "jei.psi.category.trick": "灌注",
  "jei.psi.spell_copy": "复制魔法式",
  "psi.subtitle.book": "可爱的亚历克斯在不远处玩耍",
  "_comment": "预订内容",
  "advancement.psi:iron_cad_pickup": "棱角分明",
  "advancement.psi:iron_cad_pickup.desc": "合成一个铁质CAD机体",
  "advancement.psi:gold_assembly_pickup": "对得起它的重量",
  "advancement.psi:gold_assembly_pickup.desc": "合成一个金质CAD机体",
  "advancement.psi:psimetal_assembly_pickup": "更好的……",
  "advancement.psi:psimetal_assembly_pickup.desc": "合成一个Psi金属CAD机体",
  "advancement.psi:ebony_assembly_pickup": "硬且厚",
  "advancement.psi:ebony_assembly_pickup.desc": "合成一个乌金CAD机体",
  "advancement.psi:ivory_assembly_pickup": "光滑且性感",
  "advancement.psi:ivory_assembly_pickup.desc": "合成一个象牙白CAD机体",
  "advancement.psi:psidust": "……不可合成？",
  "advancement.psi:psidust.desc": "合成你的第一个Psi粉末",
  "advancement.psi:psimetal_pickup": "令人敬畏的合金",
  "advancement.psi:psimetal_pickup.desc": "灌注你的第一块Psi金属",
  "advancement.psi:psigem_pickup": "思维水晶",
  "advancement.psi:psigem_pickup.desc": "用钻石灌注你第一个Psi宝石",
  "advancement.psi:ebony_pickup": "高价值",
  "advancement.psi:ebony_pickup.desc": "用煤炭灌注你第一块乌金色物质",
  "advancement.psi:ivory_pickup": "不同的价值",
  "advancement.psi:ivory_pickup.desc": "用石英灌注你第一块象牙白物质",
  "advancement.psi:encyclopaedia_psionica": "将它放在我的平板上",
  "advancement.psi:encyclopaedia_psionica.desc": "合成Psi百科全书，你的Psi指南",
  "psi.book.subtitle": "术式师101",
  "psi.book.name": "Psi百科全书",
  "psi.book.landing_text": "$(thing)Psi$(0)是一个关于创造$(thing)魔法式$(0)的模组，你的智慧决定了它的上限。这本书包含所有你成为一名术式师所需要的知识。$(p)(这本书正在编写中。你可以在旧版条目下找到旧的教程。)",
  "psi.book.category.basics": "基础知识",
  "psi.book.category.basics.desc": "如果你刚刚接触$(thing)Psi$(0)，我建议你通读这里的每一个条目。所有的这些都包含有重要的信息。",
  "psi.book.entry.introduction": "简介",
  "psi.book.page.introduction.0": "欢迎来到$(thing)Psi$(0)的世界，这方宇宙当中最棒的基于术式编程的魔法科技模组！$(p)$(thing)Psi$(0)(受到Mahouka系列的启发)，让你能够在这个世界当中创造和施展$(thing)魔法式$(0)。$(p)要开始你作为一名术式编纂师的旅程，你首先需要一些$(l:components/psidust)$(item)Psi粉末$(0)$(/l)-但这不是一个简单的可合成物品。",
  "psi.book.page.introduction.1": "首先，你需要先合成$(l:basics/cad_assembler)$(item)CAD装配器$(0)$(/l)以及$(l:components/assembly#iron)$(item)铁质CAD机体$(0)$(/l)。$(p)放置并打开$(l:basics/cad_assembler)$(item)CAD装配器$(0)$(/l)，放入$(l:components/assembly#iron)$(item)铁质CAD机体$(0)$(/l)来制作一个基础的$(thing)术式辅助演算机$(0)(简称$(thing)CAD$(0))。$(p)现在，扔一些$(item)红石粉$(0)到地上，用你的$(thing)CAD$(0)对准它，施展术式($(k:use))来合成$(l:components/psidust)$(item)Psi粉末$(0)$(/l)。",
  "psi.book.entry.cadAssembler": "CAD装配器",
  "psi.book.page.cadAssembler.0": "$(item)CAD装配器$(0)是$(thing)Psi$(0)的核心，它有两个基本功能。$(p)一，它将CAD组件组装成一个$(thing)CAD$(0)。二，它装载$(o)非空的$()$(l:items/spell_bullet)$(thing)术式弹药$(0)$(/l)到$(thing)CAD$(0)中(以及其他可以装载$(l:items/spell_bullet)$(thing)弹药$(0)$(/l)的物品，例如：$(l:items/tools)$(thing)Psi金属工具$(0)$(/l))。",
  "psi.book.page.cadAssembler.1": "合成一个CAD装配器",
  "psi.book.page.cadAssembler.2": "一个最简单的可以施展术式的CAD",
  "psi.book.page.cadAssembler.3": "一个$(thing)CAD$(0)有5个组件构成；最简单的$(thing)CAD$(0)仅由一个$(l:components/assembly)$(thing)组件$(0)$(/l)组成，虽然它只能用来合成$(l:components/psidust)$(item)Psi粉末$(0)$(/l)。$(p)一个能够施展$(thing)魔法式$(0)的$(thing)CAD$(0)需要一个$(l:components/core)$(thing)核心$(0)$(/l)以及一个$(l:components/socket)$(thing)弹夹$(0)$(/l)。$(p)添加一块$(l:components/battery)$(thing)电池$(0)$(/l)可以小幅提升施术者最大$(thing)Psi能量$(0)等级，添加一个$(l:components/colorizer)$(thing)着色器$(0)$(/l)可以改变施展$(thing)魔法式$(0)时的颜色，纯粹是视觉效果。",
  "psi.book.page.cadAssembler.4": "$(thing)CAD$(0)装配完毕后，就可以放置在$(item)CAD装配器$(0)的最左侧面板中。$(p)放在面板中的时候，下面的槽位会打开；$(l:items/spell_bullet)$(thing)术式弹药$(0)$(/l)可以放置到槽内以加载到$(thing)CAD$(0)中。$(p)放入$(l:items/spell_bullet)$(thing)弹药$(0)$(/l)后，将$(thing)CAD$(0)取出并拿在手上，按下$(thing)Psi热键$(0)($(k:psimisc.keybind))，当前已装载的$(l:items/spell_bullet)$(thing)弹药$(0)$(/l)包含的$(thing)魔法式$(0)将显示在HUD上，可以选择要施展的术式弹药。",
  "psi.book.page.cadAssembler.5": "装载有一个弹药的CAD",
  "psi.book.entry.spellProgrammer": "术式编写台",
  "psi.book.page.spellProgrammer.0": "如果说$(l:basics/cad_assembler)$(item)CAD装配器$(0)$(/l)是$(thing)Psi$(0)的核心，那么$(item)术式编写台$(0)则是这个mod的中枢。这里是你编写、编译以及最后将$(thing)魔法式$(0)复制到$(l:items/spell_bullet)$(thing)术式弹药$(0)$(/l)的地方。$(p)放置并打开($(k:use))它的界面，可以看到一个9x9的网格；查看$(l:basics/tutorial_1)教程1$(/l)以了解如何使用。",
  "psi.book.page.spellProgrammer.1": "写几个小时代码",
  "psi.book.entry.vectorPrimer": "矢量入门",
  "psi.book.page.vectorPrimer.0": "$(thing)Psi$(0)广泛地使用到矢量这一概念。因此，如果你对矢量还不了解，那么我强烈建议你观看下面的视频。$(p)接下来几页的解释是$(l)简化后$()面向初学者的，不是要把它看作是权威教材。",
  "psi.book.page.vectorPrimer.1": "在$(thing)Psi$(0)的世界里(准确来说是$(thing)Minecraft$(0)世界)，所有矢量都包含三个维度。简单来说，矢量包含着三个坐标：$(o)x$(),$(o)y$(),$(o)z$()。$(p)当$(o)x$()坐标为正时表示向东，为负时表示向西；$(o)y$()的正负指示上、下；$(o)z$()的正负指示南、北。$(p)如果还是不理解，请打开调试屏幕(F3)并查看，注意名称为\"XYZ:\"的行。$(br)你会理解的。",
  "psi.book.page.vectorPrimer.2": "调试屏幕上的三维坐标，是矢量的一种形式，我们叫它$(l)位置矢量$()。$(p)一个位置矢量代表着一个方块/实体/区域在世界中的坐标。一个固定的坐标，我们可以用一个列表来表示[$(o)x$(),$(o)y$(),$(o)z$()]。$(p)但是，不是所有的矢量都代表着一个位置-注意到：$(l)任意三个数值可以构成一个矢量$()。",
  "psi.book.page.vectorPrimer.3": "有趣的是，矢量非常容易相加。$(p)例如，我们在某个地方有一个草方块，我们用[$(o)x$(),$(o)y$(),$(o)z$()]来表示。$(p)如果我们想要将其与另一个矢量相加(例如：[0, 1, 0])，我们只需要增加对应的数值：$(br)最终结果：[$(o)x$()+0,$(o)y$()+1,$(o)z$()+0,或[$(o)x$(),$(o)y$()+1,$(o)z$()]。",
  "psi.book.page.vectorPrimer.4": "因为新的矢量的$(o)y$()参数增加了一，同时正的$(o)y$()值代表着向上，所以这个矢量指代草方块上方的方块。$(p)矢量[0, 1, 0]代表着两个位置矢量间的$(o)差别$()，它也是矢量的一种，我们叫它：$(l)偏移矢量$()。",
  "psi.book.page.vectorPrimer.5": "大多数术式师耗费大量时间操作偏移矢量，所以掌握它是关键。$(p)术式师通常以一个位置矢量作为基准，在此之上进行加,、减，或以其他方式将偏移矢量与这个位置矢量进行运算，以便在世界上确定所期望的点。",
  "psi.book.page.vectorPrimer.6": "重点注意：\"偏移\"和\"位置\"矢量是概念上的；这两个术语是这本书中独有的。$(p)再强调一遍：所有$(thing)Psi$(0)矢量都是包含三个数值的列表，它们没有本质上的区别。$(p)事实上，在这本书范围以外，这两种矢量的区别甚至$(o)没有意义$()。",
  "psi.book.page.vectorPrimer.7": "但是，在$(thing)Psi$(0)当中，错误地传递偏移/位置矢量到参数中可能会导致不可预料的结果。$(p)两条简略的规则：$(p)$(li)大部分$(thing)运算符$(0)仅接收最多一个位置矢量；$(p)$(li)大部分操作方块的$(thing)启动式$(0)只能$(o)$()接收位置矢量。$(p)这是一般性的规则；有些$(thing)术式$(0)可能会有例外。",
  "psi.book.page.vectorPrimer.8": "偏移矢量存在$(l)模长$()。$(p)你可以将偏移矢量的模长视为其\"长度\"，或世界上两点之间的距离，或是将偏移矢量与某位置矢量相加后得到的位置。$(p)例如，我们先前的偏移矢量[0, 1, 0]，能够将一个位置向上移动一格的长度，所以我们认为它是有长度的，即它的模长=1。",
  "psi.book.page.vectorPrimer.9": "一段距离的长度总是正的，对于矢量也是如此。$(p)将矢量[0, -3, 0]作为示例。它表示向下移动三格——移动的总距离是三格，\"向下\"的信息可以忽略。$(p)因此，此矢量的模长为$(l)正$()3。",
  "psi.book.page.vectorPrimer.10": "在矢量包含的数值大部分都是$(o)非零$()的情况下，它的模长通常难以计算。$(p)但是,因为$(o)x$(),$(o)y$()和$(o)z$()总是两两正交，我们可以使用众所周知的勾股定理来计算矢量的大小。$(p)因此，矢量[$(o)p$(),$(o)q$(),$(o)r$()]的模长为：√($(o)p$()²+$(o)q$()²+$(o)r$()²)。",
  "psi.book.page.vectorPrimer.11": "例如，矢量[3, -4, 0]的模长为√(3²+(-4)²+0²)=5。$(p)(虽然大部分的时候，矢量的模长都不是整数。)$(p)注意，尽管你$(o)能够$()计算一个位置矢量的模长，但你得到的数值基本上是毫无意义的——谁会$(o)关心$()你离[0, 0, 0]的距离？（可以是基岩层和世界出生点之间任意一点）",
  "psi.book.page.vectorPrimer.12": "几乎所有矢量的都有$(l)方向$()。$(p)一个偏移矢量的方向，是指一个物体沿着矢量所在直线移动的方向。$(p)例如，[0, 1, 0]的方向是竖直向上。$(p)矢量[1, 0, -1]则代表着向东一格以及向北一格，所以它的方向是东北。",
  "psi.book.page.vectorPrimer.13": "(大多数方向不那么好，它们通常的形式是\"西北36.86度，低于地平线22.62度。)$(p)注意，唯一没有方向的矢量是[0, 0, 0](即$(l)零矢量$()),因为你必须前往$(o)其他$()地方才能有一个具体的方向。$(p)请注意，位置矢量的方向及其模长是没有意义的-大多数$(thing)魔法式$(0)不需要知道\"我应该怎样走才能离开世界出生点的基岩层。\"",
  "psi.book.page.vectorPrimer.14": "事实上，你可以通过指定模长和方向来构造一个矢量，得到一个包含三个数值(也叫$(l)参数$())的列表。$(p)例如,方向\"向上\"以及模长为1的矢量为[0, 1, 0]。$(p)这不难理解：毕竟，如果有人告诉你要走哪个方向以及多远，你应该能理解他的意思。",
  "psi.book.page.vectorPrimer.15": "有几种简单的方法来操作位置/偏移矢量。$(p)首先，我们可以将一个位置矢量和一个偏移矢量相加来获取另一个位置矢量，就像我们之前草方块的例子。$(p)同样，我们可以用两个位置矢量$(o)相减$()来获取对应的偏移矢量：$(br)[$(o)x$(),$(o)y$()+1,$(o)z$()]-[$(o)x$(),$(o)y$(),$(o)z$()]=[0, 1, 0]。",
  "psi.book.page.vectorPrimer.16": "更有趣的是，我们可以用两个偏移矢量相加，以获取它们总的偏移矢量。$(p)将一个位置矢量与这个偏移矢量相加，等于将它与两个偏移矢量依次相加。",
  "psi.book.page.vectorPrimer.17": "最后，再介绍一个基本的矢量运算法则：我们可以将一个矢量乘以一个数值来对它进行$(l)缩放$()。$(p)注意我们正在乘以一个数值，$(o)而不是$()另一个矢量。$(p)如果我们想要将矢量[$(o)p$(),$(o)q$(),$(o)r$()]缩放$(o)n$()倍,我们只需将矢量的每个参数乘以$(o)n$()：$(br)$(o)n$()·[$(o)p$(),$(o)q$(),$(o)r$()]=[$(o)n$()·$(o)p$(),$(o)n$()·$(o)q$(),$(o)n$()·$(o)r$()]。",
  "psi.book.page.vectorPrimer.18": "最后的这一个运算操作与矢量的模长和方向的概念有着密切关系。$(p)当你将矢量缩放$(o)n$()倍，意味着：$(p)$(li)将矢量的模长乘以$(o)n$()的绝对值，并且$(p)$(li)如果$(o)n$()是正数，则不改变其方向；如果$(o)n$()是负数，则反转其方向。$(p)如果是$(o)n$()=0，那么结果自然是零向量。",
  "psi.book.page.vectorPrimer.19": "另一方面，如果我们指定$(o)n$()=-1，我们会得到一个模长相同(因为-1的绝对值是1)但方向相反(因为-1是负的)的矢量；$(p)此矢量称为$(l)反向$()矢量，当将这两个矢量相加时，我们会得到零向量。$(p)这是符合逻辑的，因为如果我们先朝一个方向行进。然后再朝相反方向移动相同距离，那么我们的位移自然是零。",
  "psi.book.page.vectorPrimer.20": "如果我们将乘换成除，用矢量的模长$(o)除$()一个（非零）矢量，我们可以得到一个模长为1(因为任何数除以自身得1)，但方向相同（因为模长总是正的）的矢量。$(p)这是一个重要且众所周知的运算，名为$(l)归一化$()一个矢量；产生的矢量(以及实际上任何模长为1的矢量)被称为$(l)单位矢量$()。",
  "psi.book.page.vectorPrimer.21": "单位矢量具有固定的模长，因此它仅代表方向。$(p)很多与方向相关的$(thing)术式$(0)返回的是单位矢量。例如：$(piece)运算符：矢量轴向追踪$(0)和$(piece)运算符：实体视线$(0)。$(p)事实上，这篇文章里提到的$(thing)运算符$(0)相关的矢量运算$(o)大多$()有相应的别称。",
  "psi.book.page.vectorPrimer.22": "矢量运算操作与对应的$(thing)运算符$(0)如下：$(p)$(li)反向矢量$(piece)运算符：反向矢量$(0);$(p)$(li)归一化$(piece)运算符：矢量归一化$(0);$(p)$(li)缩放$(piece)运算符：矢量乘$(0)和$(piece)运算符：矢量除$(0)；$(p)$(li)模长$(piece)运算符：矢量模长$(0);$(p)$(li)相加$(piece)运算符：矢量和$(0);$(p)$(li)相减$(piece)运算符：矢量减$(0)。",
  "psi.book.page.vectorPrimer.23": "最后：矢量是三个数值的列表。不要忽略这一点。$(p)在$(l:basics/spell_programmer)$(item)术式编写台$(0)$(/l)中，它们可以用三个数值来配合$(piece)运算符：矢量构造$(0)来构造。$(p)反过来说，矢量也可以用运算符重新拆解成单个数值：$(piece)运算符：矢量提取X$(0),$(piece)运算符：矢量提取Y$(0)，和$(piece)运算符：矢量提取Z$(0)",
  "psi.book.page.vectorPrimer.24": "恭喜！你已经读完了这篇教程！$(p)但是，这篇教程只是简要地讲述了矢量的基本概念——诸如点乘、叉乘以及向量投影相关的内容还没有涉及。$(p)但这应该足以让你编写一些有趣的$(thing)魔法式$(0)了。$(p)好了——现在开始编写术式吧！",
  "psi.book.entry.tutorial1": "教程(1)：编写一个魔法式",
  "psi.book.page.tutorial1.0": "恭喜！你已经掌握了$(thing)CAD$(0)的用法！$(p)此平板将作为此模组的参考手册，但某些条目（如此条）则是教程，它将向你讲授成为一名合格的术式师所需要掌握的概念和术语。$(p)不要担心，这篇教程就是最长的了，因为它涵盖了所有基础知识。",
  "psi.book.page.tutorial1.1": "$(o)请注意，许多$(item)着色$(0)的$(piece)文本$(0)是链接，能够点击以查看对应物品或概念的详细信息。$()$(p)若要开始$(thing)魔法式$(0)编程，你需要一个$(l:basics/spell_programmer)$(item)术式编写台$(0)$(/l)（废话）。此外，$(p)要实际运行你的$(thing)魔法式$(0)，你需要一个比现在这个更高级的$(thing)CAD$(0)——你可以用$(l:basics/cad_assembler)$(item)CAD装配器$(0)$(/l)来组装一个.",
  "psi.book.page.tutorial1.2": "为了达到这一目的，你需要一个$(l:components/core#basic)$(item)基础CAD核心$(0)$(/l)以及一个$(l:components/socket#basic)$(item)基础CAD弹夹$(0)$(/l)。$(p)你不需要再合成多一个$(l:components/assembly)$(thing)CAD机体$(0)$(/l)；你可以把你当前的$(thing)CAD$(0)放在合成栏内，将它还原成一个(因为它仅仅由一个$(l:components/assembly)$(thing)组件$(0)$(/l)组成)。$(p)此外，$(thing)魔法式$(0)不能直接通过$(thing)CAD$(0)施展；相反，它们需要被存储在$(l:items/spell_bullet)$(thing)术式弹药$(0)$(/l)中，所以你也需要合成几个这个。",
  "psi.book.page.tutorial1.3": "当你准备好所有材料之后，你就可以按以下流程来进行$(thing)魔法式$(0)的编写：$(p)$(li)在$(l:basics/spell_programmer)$(item)编写台$(0)$(/l)上编写一个$(thing)魔法式$(0)；$(br)$(li)将$(thing)魔法式$(0)复制到$(l:items/spell_bullet)$(thing)术式弹药$(0)$(/l)中；$(br)$(li)用$(l:basics/cad_assembler)$(item)CAD装配器$(0)$(/l)将$(l:items/spell_bullet)$(thing)术式弹药$(0)$(/l)加载到$(thing)CAD$(0)当中;$(br)$(li)拿起你的$(thing)CAD$(0)，瞄准然后发射。$(p)在这个教程以及下一个教程当中，我们会带你走一遍这个流程。",
  "psi.book.page.tutorial1.4": "当你打开$(l:basics/spell_programmer)$(item)术式编写台$(0)$(/l)，你会看到一个大的网格——这里就是$(thing)术式$(0)待的地方了，也是魔法发生的地方。$(p)$(thing)Psi$(0)的编程系统不是$(o)完完全全$()是一个传统的、复杂的系统；反之，$(thing)魔法式$(0)由简单的动作组成，名为$(thing)术式$(0)，它们按一定的顺序执行。$(p)整个模组的中心就是让这些$(thing)术式$(0)去做你想要做的事情。",
  "psi.book.page.tutorial1.5": "$(thing)Psi$(0)的$(thing)魔法式$(0)是在$(l:basics/spell_programmer)$(item)编写台$(0)$(/l)的格子上通过一个个$(thing)术式$(0)拼凑而成；你可以向网格添加尽可能多的术式，虽然不是所有的$(thing)术式$(0)都能产生有效的$(thing)魔法式$(0)。$(p)要将一个术式添加到网格中，右键单击你想要添加的地方，然后从弹出的菜单中选择你想要的术式。",
  "psi.book.page.tutorial1.6": "当从$(thing)术式$(0)的菜单中选择时，你可以悬停在一个术式上查看它的名称，然后点击将它放在网格中。$(p)术式太多？不要担心；你可以搜索特定的术式，然后按回车键放置第一个搜索结果。$(p)你可以悬停在右下方的\"？\"按钮上来查看所有快捷键。",
  "psi.book.page.tutorial1.7": "首先我们先在网格中任意一个地方放置$(piece)启动式：调试$(0)。$(p)前面提到，像这样叫做$(thing)启动式$(0)的$(thing)术式$(0)能够与世界进行交互。$(p)这是最简单的$(thing)启动式$(0)；它仅仅发送一条消息到你的聊天栏。不仅如此，$(thing)启动式$(0)还可以使用你的$(thing)Psi能量$(0)做到更多的事情。",
  "psi.book.page.tutorial1.8": "在与$(piece)启动式：调试$(0)$(l)相邻$()的格子上放置$(piece)选择符：施术者$(0)。$(p)$(thing)选择符$(0)是给其它$(thing)术式$(0)提供世界上的信息的$(thing)术式$(0)。$(p)这里这个选择符指代着你，即施展这个$(thing)术式$(0)的人。你会经常用到它，因为这是你$(thing)魔法式$(0)的一个自然的起始点(naturalstarting-point)。",
  "psi.book.page.tutorial1.9": "几乎所有的$(thing)术式$(0)都需要一个到多个$(l)参数$()，这些参数控制术式怎样执行相应的操作。$(p)例如，我们知道$(piece)启动式：调试$(0)会发送一些消息到聊天栏；它的第一个参数告诉它要发送$(o)什么$()。$(p)$(o)参数还拥有$(l)数据类型$()$(o)，简称$(l)类型$()$(o)，但我们现在还不需要关心这个。$()",
  "psi.book.page.tutorial1.10": "左键点击你的$(piece)启动式：调试$(0)术式；你应该能够看到左侧出现一个面板。面板有两行，每行都有一个标签和几个小箭头。$(p)这两行代表着$(piece)启动式：调试$(0)所需的两个参数。$(p)忽略标题为\"数值\"的行；你只要知道中心的点意味着这个参数是一个可选参数。若要使$(thing)术式$(0)正常工作，必须提供所有$(o)非$()可选参数。",
  "psi.book.page.tutorial1.11": "查看标注为\"目标\"的那些箭头，并选择指向$(piece)选择符：施术者$(0)的箭头(例如，如果你将它放置在$(piece)启动式：调试$(0)的右边，那么就选择最右边指向左的箭头)，现在$(thing)选择符$(0)应当指向$(thing)启动式$(0)的方向。",
  "psi.book.page.tutorial1.12": "这将使$(thing)启动式$(0)使用$(thing)选择符$(0)作为其\"目标\"的参数。$(p)我们说$(piece)启动式：调试$(0)$(l)接收$()或$(l)使用$()$(piece)选择符：施术者$(0)作为其\"目标\"的参数。$(p)参数也被称为$(l)输入$()。$(p)$(o)注意：这在编程的术语当中存在着微妙的差别，不过这不在本书的讨论范围。$()",
  "psi.book.page.tutorial1.13": "你最终的$(thing)魔法式$(0)看起来应该像是这样",
  "psi.book.page.tutorial1.14": "现在，$(l:basics/spell_programmer)$(item)编写台$(0)$(/l)界面左上角的X应该变成一个✔。$(p)✔意味着$(thing)魔法式$(0)$(l)编译成功$()(这表示\"$(l:basics/spell_programmer)$(item)编写台$(0)$(/l)\"已确保这个$(thing)魔法式$(0)能够正常运行)。",
  "psi.book.page.tutorial1.15": "如果标志是X(这意味着$(l)编译失败$()或$(l)编译错误$())，你可以悬停在它上面查看$(thing)魔法式$(0)存在的问题并予以纠正。$(p)一旦你的$(thing)魔法式$(0)编译成功，它就能被复制到$(l:items/spell_bullet)$(thing)术式弹药$(0)$(/l)中并发射。我们将在$(l:basics/tutorial_2)下一个教程$(/l)中进行这个操作！",
  "psi.book.entry.tutorial2": "教程(2)：施展一个魔法式",
  "psi.book.page.tutorial2.0": "所以，你已经完成了第一个$(thing)魔法式$(0)的编写！但在实际施法前还需要几个额外的步骤。$(p)首先关闭$(l:basics/spell_programmer)$(item)术式编写台$(0)$(/l)的界面，手持$(l:items/spell_bullet)$(thing)术式弹药$(0)$(/l)（你应该在上一个教程里准备好），并对着术式编写台\"使用\"($(k:use))，你应该听到一声响声，并且弹药被重命名为\"调试\"。",
  "psi.book.page.tutorial2.1": "现在这个术式弹药就包含着一份$(thing)魔法式$(0)的副本，并且它已经能够被装载到你的$(thing)CAD$(0)里。$(p)要将$(l:items/spell_bullet)$(thing)术式弹药$(0)$(/l)装载进$(thing)CAD$(0)，首先打开$(l:basics/cad_assembler)$(item)CAD装配器$(0)$(/l)的界面，然后将你的$(thing)CAD$(0)放到最左侧的槽里，这时可以看到下面有些槽位已经打开了，将带有$(thing)魔法式$(0)的弹药放到这些槽内。最后将$(thing)CAD$(0)取出。",
  "psi.book.page.tutorial2.2": "$(thing)CAD$(0)可以装载多个$(l:items/spell_bullet)$(thing)术式弹药$(0)$(/l)，也意味着可以装载多个$(thing)魔法式$(0)；当前激活的$(thing)魔法式$(0)可快速地切换。$(p)要选择一个$(thing)魔法式$(0)进行施展，手持你的$(thing)CAD$(0)并按住$(thing)Psi热键$(0)($(k:psimisc.keybind))。$(p)此时应当出现一个HUD界面；将鼠标悬停在标注为\"调试\"（你刚刚写的）的$(thing)魔法式$(0)上，松开热键来进行选择。",
  "psi.book.page.tutorial2.3": "当你施展$(thing)魔法式$(0)($(k:use))时，你应该看到在聊天栏中出现一大段文本信息，其中包括你的用户名和当前坐标。如果是这样：恭喜！你成功编写并施展了你的第一个$(thing)魔法式$(0)！$(p)如果你需要合成更多的$(l:components/psidust)$(item)Psi粉末$(0)$(/l)，重新打开HUD并选择一个没有$(thing)魔法式$(0)的槽，然后像之前那样对着$(item)红石粉$(0)施法。",
  "psi.book.page.tutorial2.4": "$(l)小注：你一次只能携带一个$(thing)CAD$(0)。$()$(p)如果你携带了多个，它们的$(thing)Psi$(0)频道会互相干扰，使$(thing)魔法式$(0)在施展时短路。这种现象被称为\"演算干扰\"，最好的避免办法是只保留一个$(thing)CAD$(0)。$(p)一旦你成功施展了你的调试$(thing)魔法式$(0)，你就可以继续$(l:basics/tutorial_3)下一个教程$(/l)了。",
  "psi.book.entry.tutorial3": "教程(3)：类型&数值",
  "psi.book.page.tutorial3.0": "打开你的$(l:basics/spell_programmer)$(item)术式编写台$(0)$(/l)并查看你的\"调试\"$(thing)魔法式$(0)。$(p)还记得在$(l:basics/tutorial_1)教程1$(/l)中提到的$(piece)启动式：调试$(0)有一个叫做\"数值\"的参数吗？我们先前提到，该参数在中心有一个额外的点，这意味着它是一个可省略的参数。但现在，我们$(o)不再$()省略这个参数。",
  "psi.book.page.tutorial3.1": "$(piece)启动式：调试$(0)名叫的\"数值\"的参数，是用作输出调试信息时的一个标签，这样就可以区分一个复杂的$(thing)魔法式$(0)中多个$(piece)启动式：调试$(0)输出的信息。$(p)这个参数的$(l)类型$()是\"数值\"，这意味着这个参数只接受输出(或$(l)返回值$())为\"数值\"的术式。$(p)第一个参数，\"目标\"则接受一个特殊的类型——\"任意\"；这意味着它可以接收任何类型。",
  "psi.book.page.tutorial3.2": "当你按住Shift并且将鼠标悬停在术式上时，它会告诉你它所有的参数的类型以及其输出类型。例如，我们可以看到$(piece)选择符：施术者$(0)返回的是实体而不是数值。因此，我们需要另外一个返回数值的术式。",
  "psi.book.page.tutorial3.3": "$(piece)选择符：施术者$(0)的提示信息;它返回一个实体",
  "psi.book.page.tutorial3.4": "选择邻近$(piece)启动式：调试$(0)的一个空白格，并放置$(piece)常数：数值$(0)。$(p)如果你按住Shift并悬停在这个术式上，你会看到它返回一个$(o)数值$()(实际上，它返回一个数值常数，它是一个数值，但更具体)。$(p)因此，如果你左键点击你的$(piece)启动式：调试$(0)并将其数字参数指向$(piece)常量：数值$(0)你的$(thing)魔法式$(0)应该能够成功编译。",
  "psi.book.page.tutorial3.5": "要运行你新的改进版的调试$(thing)魔法式$(0)，你可能会以为需要先卸载弹药，重新复制$(thing)魔法式$(0)，重新装载弹药，重新选择$(thing)魔法式$(0)。$(p)幸运的是，你有更为快捷的方法：在$(thing)CAD$(0)中选择\"调试\"这一$(thing)魔法式$(0)，然后将$(thing)CAD$(0)对着$(l:basics/spell_programmer)$(item)编写台$(0)$(/l)挥动($(k:use))，存储在对应弹药中的$(thing)魔法式$(0)将会被更新到与$(l:basics/spell_programmer)$(item)编写台$(0)$(/l)相同的版本。",
  "psi.book.page.tutorial3.6": "如果你施展了你的调试$(thing)魔法式$(0)，你会注意到你会得到与以前相同的一大段的文本。但在最前面有一个\"[0]\"：与$(piece)常量：数值$(0)的内容相同。$(p)所以你的下一个问题是：我们如何指定$(o)除$()零以外的数值？",
  "psi.book.page.tutorial3.7": "好吧，$(piece)常量：数值$(0)是特殊的术式：要设置其存储的常量，你需要选择该术式，然后直接输入一个新数值。$(p)其他$(thing)术式$(0)只能在左边参数面板上配置。$(p)$(o)技术指引：所有\"常数\"都是\"数值\"，但一个普通的\"数值\"类型不被认为是常数。只有$(thing)常量$(0)$(thing)术式$(0)返回的才是\"常数\"。$()",
  "psi.book.page.tutorial3.8": "尝试更改$(piece)常量：数值$(0)的数值，更新存储在你的$(thing)CAD$(0)中的$(thing)术式$(0)并重新施展。你应该看到数值前缀发生了改变！真有条理！",
  "psi.book.page.tutorial3.9": "现在的情况是：我们已经给$(piece)启动式：调试$(0)，提供了两个不同的输入。$(p)实际上，$(o)大部分$()$(thing)术式$(0)需要两到三个参数的输入。当术式排布得紧密时，你的几个$(thing)术式$(0)可能需要同时共用一个输入格。$(p)接下来就轮到$(piece)连接符$(0)出场了。",
  "psi.book.page.tutorial3.10": "连接符是简单的术式，但是它非常有用：它们接收一个任意类型的输入，并返回与输入同样的值。因此，如果某一个$(thing)术式$(0)需要两格以外的术式作为输入，你可以将它们用$(piece)连接符$(0)连在一起。",
  "psi.book.page.tutorial3.11": "通往Terabithia的桥",
  "psi.book.page.tutorial3.12": "当然，$(piece)连接符$(0)的真正强大的地方是它们能够$(o)彼此相连$()：因此你想连多远的$(thing)术式$(0)就连多远。$(p)试着练习使用$(piece)连接符$(0)，当你熟悉了它的基本用法之后，你就可以继续$(l:basics/tutorial_4)下一个教程$(/l)！",
  "psi.book.page.tutorial3.13": "长路漫漫",
  "psi.book.entry.tutorial4": "教程(4)：移动",
  "psi.book.page.tutorial4.0": "好吧，好吧。我知道你在想什么：\"这很无聊。我们什么时候可以开始做些很酷的东西？\"答案是……现在！$(p)首先来介绍一个能够与世界交互的$(thing)术式$(0)—$(piece)启动式：附加运动$(0)。$(p)这个$(thing)术式$(0)会给予实体一个特定方向上的速度（即给予一个推力）。",
  "psi.book.page.tutorial4.1": "实体包括但不限于：你（施术者）、鸡、僵尸、矿车、下落方块、箭、凋灵。$(p)这个$(thing)启动式$(0)以实体（代表我们将要移动实体），一个矢量（推力的方向）和一个常数($(thing)启动式$(0)推动实体的力度)作为参数。$(p)$(o)注意：如果你不理解\"矢量\"这个词的意思，$(l:basics/vector_primer)这个条目$(/l)应该是一个很好的入门教程。$()",
  "psi.book.page.tutorial4.2": "让我们来编写一个这样的$(thing)魔法式$(0)：当施展时，给予施术者一个向前的速度；这就需要用到$(piece)启动式：附加运动$(0)。$(p)之前提到过，$(piece)选择符：施术者$(0)会返回一个实体(施术者，即你自己)，我们可以将它作为$(piece)启动式：附加运动$(0)的第一个参数。$(p)我们需要让这个$(thing)术式$(0)让你$(o)前进$()--也就是$(o)你所看的方向$()。为了做到这一点，我们需要：$(piece)运算符：实体视线$(0)。",
  "psi.book.page.tutorial4.3": "$(thing)运算符$(0)不会以任何形式与世界进行交互，也不从中获取信息（除少数例外情况）。相反，它们只是把信息$(o)转换$()成更有用的形式。$(p)举例：$(piece)运算符：实体视线$(0)接受一个实体，并返回一个单位矢量：实体正在看的方向。$(p)因此，将它绑定到$(piece)选择符：施术者$(0)，将返回一个指代你所看的方向的矢量。",
  "psi.book.page.tutorial4.4": "最后，对于$(piece)启动式：附加运动$(0)的最后一个参数，绑定一个简单的$(piece)常量：数值$(0)就行了。$(p)让我们把这些个$(thing)术式$(0)拼凑在一起：首先，打开你$(l:basics/spell_programmer)$(item)术式编写台$(0)$(/l)并清空里面的$(thing)魔法式$(0)然后在网格中间位置放置一个$(piece)启动式：附加运动$(0)。",
  "psi.book.page.tutorial4.5": "在$(thing)启动式$(0)的上方放置一个$(piece)选择符：施术者$(0)，右边放置一个$(piece)运算符：实体视线$(0)，左边放置一个$(piece)常量：数值$(0)。$(p)给$(thing)常量$(0)填一个值(我建议填3)。$(p)在$(thing)运算符$(0)和$(thing)选择符$(0)之间放置一个$(piece)连接符$(0)，然后绑定所有$(thing)运算符$(0)和$(thing)启动式$(0)的参数，然后$(thing)魔法式$(0)应该能够编译成功——如下页图所示。",
  "psi.book.page.tutorial4.6": "激动人心的时刻",
  "psi.book.page.tutorial4.7": "将$(thing)魔法式$(0)复制到你的$(thing)CAD$(0)里，面朝前方然后施展术式。如果你向前移动了一小段距离，恭喜！你成功完成了你的第一个真正的$(thing)魔法式$(0)！$(p)$(o)注意：施展$(thing)魔法式$(0)次数过多可能会对你的身体造成伤害。有关这个问题的更多信息请看$(l:basics/tutorial_5)下一个教程$(/l)。$()",
  "psi.book.entry.tutorial5": "教程(5)：限制",
  "psi.book.page.tutorial5.0": "再次打开你的$(l:basics/spell_programmer)$(item)术式编写台$(0)$(/l)并查看你在$(l:basics/tutorial_4)上一个教程$(/l)中编写的$(thing)魔法式$(0)。$(p)编译通过时，你应该看到在网格右侧出现五个图标，每个图标有两个数值。这些属性信息指示了$(thing)魔法式$(0)施展的前提要求。",
  "psi.book.page.tutorial5.1": "附加运动$(thing)魔法式$(0)的属性(假设你设定的常量值为3)",
  "psi.book.subsec.tutorial5.2": "复杂度",
  "psi.book.page.tutorial5.2": "第一个属性是$(thing)复杂度$(0)，即$(thing)魔法式$(0)中$(thing)运算符$(0)，$(thing)选择符$(0)以及非调试$(thing)启动式$(0)的数量。$(p)其最大值由你安装的$(l:components/core)$(thing)CAD核心$(0)$(/l)确定；如果一个$(thing)魔法式$(0)的$(thing)复杂度$(0)超过了你的$(thing)CAD$(0)的容量，它就无法施展。",
  "psi.book.subsec.tutorial5.3": "强度",
  "psi.book.page.tutorial5.3": "第二个属性是$(thing)强度$(0)，受限于你的$(l:components/assembly)$(thing)CAD机体$(0)$(/l)；代表着你$(thing)魔法式$(0)内所有的$(thing)启动式$(0)的总的近似的能量消耗。$(p)一部分的$(thing)启动式$(0)有着固定的$(thing)强度$(0)值。然而，更多的$(thing)启动式$(0)由其常量类型参数来确定它们的$(thing)强度$(0)；常量越大，$(thing)强度$(0)越大。",
  "psi.book.subsec.tutorial5.4": "消耗",
  "psi.book.page.tutorial5.4": "第三个属性是$(thing)消耗$(0)，是唯一不受$(thing)CAD$(0)限制的属性。相反，每次你施展$(thing)魔法式$(0)的时候，它都会从你的身体的$(thing)Psi能量$(0)里扣取$(thing)消耗$(0)的值。$(p)第一个数值表示$(o)理想情况$()下$(thing)魔法式$(0)的$(thing)消耗$(0)——每一个不够优良的$(l:components/assembly)$(thing)CAD组件$(0)$(/l)都会提升这一数值。",
  "psi.book.page.tutorial5.5": "$(l:basics/spell_programmer)$(item)编写台$(0)$(/l)里用括号括起来的数值，才是你用$(thing)CAD$(0)施展时真正的$(thing)消耗$(0)。$(l:components/assembly)$(thing)CAD机体$(0)$(/l)的$(thing)效率$(0)越高，在用你的$(thing)CAD$(0)施展时的$(thing)消耗$(0)就越靠近理想值。",
  "psi.book.page.tutorial5.6": "你的$(thing)Psi能量$(0)产生的速率是每秒500单位，以限制你施展$(thing)魔法式$(0)的速率。$(p)你当前的$(thing)Psi能量$(0)等级可以通过$(piece)选择符：施术者能量$(0)在$(thing)魔法式$(0)中获取。",
  "psi.book.page.tutorial5.7": "注意，在你施展$(thing)魔法式$(0)时没有足够的$(thing)Psi能量$(0)可供扣除(也就是$(l)透支$())的时候，你的$(thing)CAD$(0)会从你的生命值里扣除不足部分的消耗，然后，为了保护你的身体，它会进入休眠模式，直到你的$(thing)Psi能量$(0)完全恢复。$(p)给$(thing)CAD$(0)安装一块$(l:components/battery)$(thing)电池$(0)$(/l)防止这样的事情发生。$(p)小心——透支的后果十分严重，有时它还可能危及你的生命！",
  "psi.book.subsec.tutorial5.8": "映射",
  "psi.book.page.tutorial5.8": "$(l:basics/spell_programmer)$(item)编写台$(0)$(/l)上显示的第四个属性是$(thing)映射$(0)：$(thing)魔法式$(0)中非调试的$(thing)启动式$(0)的总数。$(p)你$(thing)CAD$(0)的$(l:components/core)$(thing)核心$(0)$(/l)决定了每个$(thing)魔法式$(0)$(thing)映射$(0)的最大值；$(thing)魔法式$(0)中的$(thing)启动式$(0)过多的话是无法施展的。",
  "psi.book.subsec.tutorial5.9": "带宽",
  "psi.book.page.tutorial5.9": "第五个也就是最后一个属性是$(thing)带宽$(0)，受限于$(l:components/socket)$(thing)CAD弹夹$(0)$(/l)：$(thing)魔法式$(0)占用的宽和高的格数的最大值。$(p)这个有趣的属性需要你花费更多的心思在它上面；如果你的$(thing)魔法式$(0)太大，你就需要$(l)压缩$()它——尝试移动术式的位置，删除不必要的术式，以减小它的大小。",
  "psi.book.page.tutorial5.10": "$(thing)魔法式$(0)的最后一个限制条件是：$(thing)启动式$(0)不能干涉$(l:items/spell_bullet#focal_point)$(thing)焦点$(0)$(/l)(对于一般的$(l:items/basic_bullet)$(item)术式弹药$(0)$(/l)，焦点就是施术者)32格以外的东西，除非这个东西是施展这个$(thing)魔法式$(0)的人。$(p)尝试干涉32格外的东西的$(thing)魔法式$(0)，会在聊天栏里弹出一道错误信息，然后$(l)呲~的一声灭掉$()。$(p)当$(thing)魔法式$(0)灭掉时，它仅仅向周围散尽其存储的$(thing)Psi能量$(0)，任何还未执行的$(thing)启动式$(0)将不会被执行。",
  "psi.book.page.tutorial5.11": "之前提到的例外情况的解释：$(br)某些类型的$(l:items/spell_bullet)$(thing)术式弹药$(0)$(/l)的$(l:items/spell_bullet#focal_point)$(thing)焦点$(0)$(/l)$(o)不是$()施术者本身——在这种情况下，不论它们离$(l:items/spell_bullet#focal_point)$(thing)焦点$(0)$(/l)的距离有多远，内部的$(thing)魔法式$(0)仍然能通过$(piece)选择符：施术者$(0)获取到施术者。$(p)$(l:basics/tutorial_6)最终教程$(/l)将会综合运用我们所学的知识，让你自由地在$(thing)Psi$(0)的世界里翱翔。祝好运！",
  "psi.book.entry.tutorial6": "教程(6)：爆炸",
  "psi.book.page.tutorial6.0": "你喜欢爆炸吗？$(p)你当然喜欢。每个人都喜欢爆炸！$(p)让我们制作一个$(thing)魔法式$(0)，用它来炸毁你所看到的一切。$(p)这还能出什么问题吗？",
  "psi.book.page.tutorial6.1": "要编写这个$(thing)魔法式$(0)，我们先从用来产生爆炸的$(thing)启动式$(0)开始，然后再弄其它的。$(p)方便起见，它被命名为$(piece)启动式：爆炸$(0)——打开你的$(l:basics/spell_programmer)$(item)术式编写台$(0)$(/l)，清空网格，然后在中间放一个$(piece)启动式：爆炸$(0)。$(p)按住Shift悬停在它上方，可以看到它需要一个矢量和一个常数作为参数。",
  "psi.book.page.tutorial6.2": "常数参数代表爆炸的能量——我们可以简单地指定一个$(piece)常量：数值$(0)。$(p)另一方面，矢量指示你想要产生爆炸的位置。这需要花点的精力来计算。",
  "psi.book.page.tutorial6.3": "在$(l:basics/tutorial_5)上一个教程$(/l)里，我们使用了$(piece)运算符：实体视线$(0)。$(p)这个$(thing)运算符$(0)返回的是单位矢量，然而，$(piece)启动式：爆炸$(0)需要的是一个位置矢量，所以直接将那个术式绑定到$(thing)启动式$(0)可能不会产生我们想要的结果。$(p)因此让我们介绍另一个$(thing)运算符$(0)：$(piece)运算符：实体位置$(0)。",
  "psi.book.page.tutorial6.4": "$(piece)运算符：实体位置$(0)接受一个实体参数(例如：$(thing)魔法式$(0)的施术者)，并返回该实体的位置(更准确地说，对于像你这样的玩家实体来说，它返回你的眼睛所在位置(eye-level))。$(p)然而，我们也不想将它直接传入$(piece)启动式：爆炸$(0)，因为当你施展的时候它会在你的脸上产生爆炸。",
  "psi.book.page.tutorial6.5": "我们现在$(o)应该$()将$(piece)运算符：实体视线$(0)返回的向量进行缩放，我们在这里给它x10倍，然后将它与$(piece)运算符：实体位置$(0)返回的向量相加。$(p)将相加后的结果传入$(piece)启动式：爆炸$(0)，它就会在$(o)你所看方向上，正好10格远$()的地方产生一个爆炸。",
  "psi.book.page.tutorial6.6": "但是这个$(thing)魔法式$(0)的缺点是很明显的：如果你想要炸毁更远或更近的东西，你就要四处走动，估计距离以调整爆炸产生的位置。$(p)这不符合我们日常使用的需求。$(p)现在，让我们来介绍一个更加智能的运算符：$(piece)运算符：矢量追踪$(0)。",
  "psi.book.page.tutorial6.7": "这个$(thing)运算符$(0)的功能非常简单；它接受一个位置矢量和一个\"射线\"矢量（仅仅是一个代表方向的矢量）。$(p)其返回值代表着\"如果我站在那里（位置矢量定义）并朝着这个方向（射线矢量定义）看，我所指向的方块的坐标。它非常符合我们的需求。$(p)欲了解更多详情，包括\"最大值\"参数的作用，请阅读$(piece)运算符：矢量追踪$(0)的页面。",
  "psi.book.page.tutorial6.8": "因此！要构建这样的$(thing)魔法式$(0)，我们要先来返下工。$(p)在$(piece)启动式：爆炸$(0)旁边放置一个$(piece)常量：数值$(0)(如果你还在使用你在$(l:basics/tutorial_1)教程1$(/l)中制作的$(thing)CAD$(0)，1.4是个比较恰当的数值)。$(p)然后，在$(thing)启动式$(0)旁边放置一个$(piece)运算符：矢量追踪$(0)，并将$(thing)启动式$(0)与另外两个$(thing)术式$(0)关联。",
  "psi.book.page.tutorial6.9": "接下来，分别放置两个实体运算符：$(piece)运算符：实体位置$(0)和$(piece)运算符：实体视线$(0)，然后将$(piece)运算符：矢量追踪$(0)与这两个运算符相连接。$(p)请确保将\"位置\"绑定到实体位置以及将\"射线\"绑定到实体视线，而不是相反。否则，当你施展$(thing)魔法式$(0)时，你会得到一些奇怪的结果/错误。$(p)最后，放置一个$(piece)选择符：施术者$(0)并将其绑定到两个实体$(thing)运算符$(0)上。",
  "psi.book.page.tutorial6.10": "看起来像是这样",
  "psi.book.page.tutorial6.11": "一旦你的$(thing)魔法式$(0)编译成功，把它加载到你的$(thing)CAD$(0)中，小心地瞄准某个东西（最好是对你不那么重要的东西）并施展。$(p)如果你所看的位置发生了爆炸，请花一点时间来回味你的新力量。$(p)额，最好，不要对着你的脚下施展。",
  "psi.book.page.tutorial6.12": "最后要注意的是：尝试在超过32格的地方(或者对着空气，例如天空)施展你的\"爆炸\"$(thing)魔法式$(0)，$(p)你将看不到爆炸的发生，并且聊天栏里会弹出一道错误信息，告诉你\"$(c)术式的目标超出了32格半径限制。$(0)\"（这个限制将在最后一个教程中讨论）。$(p)这种在聊天栏中弹出的错误可能会相当的烦人。",
  "psi.book.page.tutorial6.13": "为了解决这个问题，只需要在网格的任意位置放置一个$(piece)错误消除符$(0)，$(thing)魔法式$(0)所产生的错误将会被屏蔽掉。$(p)在调试时你可能要删掉这个术式。因为错误有时也是$(o)有用的$()。",
  "psi.book.page.tutorial6.14": "这就是所有的教程！$(p)你可以通过阅读这本书的其他部分来了解这个mod更多的具体功能。经验丰富的魔法师能够做出许多令人意想不到的事情。现在你可以用你的$(thing)CAD$(0)以及$(l:basics/spell_programmer)$(item)术式编写台$(0)$(/l)开始编写$(thing)魔法式$(0)的实验了。$(p)欢迎你来到$(thing)Psi$(0)的广阔世界！$(p)祝好运！",
  "psi.book.entry.evalOrder": "执行顺序",
  "psi.book.page.evalOrder.0": "几乎所有$(thing)启动式$(0)都与$(thing)魔法式$(0)同步运行。尽管如此，要使用$(piece)流程控制术式$(0)，你需要有基本的执行次序的知识；即$(thing)术式$(0)执行的顺序。",
  "psi.book.page.evalOrder.1": "术式的执行次序有三条基本规则；之后的几页对它们作了详细的解释，现在这里是一个简要的总结：$(p)$(li)当一个$(thing)魔法式$(0)被施展时，它的$(thing)启动式$(0)是从左到右，从上到下依次执行的；$(p)$(li)任何$(thing)术式$(0)执行前，都会先执行其参数的求值工作；$(p)$(li)每次施展$(thing)魔法式$(0)时，一个$(thing)术式$(0)最多只会被求值一次（在首次用到它的时候执行计算）。",
  "psi.book.page.evalOrder.2": "第一条规则应该是不言自明的：放置在网格上更高的$(thing)启动式$(0)比放置更低的$(thing)启动式$(0)更早地执行，并且当两个或更多的$(thing)启动式$(0)处于同一行时，最左边的先执行。$(p)因此，施展下一页的$(thing)魔法式$(0)应该在聊天栏中依次显示\"1.0\"，\"2.0\"，\"3.0\"和\"4.0\"。",
  "psi.book.page.evalOrder.3": "让它报数",
  "psi.book.page.evalOrder.4": "第二条规则也很简单；一个$(thing)术式$(0)当且仅当其被取值时才会执行。$(p)与之相反，当一个$(thing)术式$(o)没有被一个$(thing)启动式$(0)直接或间接地取值，它将永远不会被执行。$(p)任何没有连接到一个$(thing)启动式$(0)的$(thing)术式$(0)，会产生未定义的行为——$(thing)术式$(0)的执行与否不能被保证。",
  "psi.book.page.evalOrder.5": "不建议这样做",
  "psi.book.page.evalOrder.6": "第三条，也是最后一条规则，这是一条更微妙的规则，我们通过下一页的$(thing)魔法式$(0)来更好地说明：$(p)一个$(thing)术式$(0)仅会被求值一次，并在之后的求值中返回与第一次求得的$(o)完全相同$()的值。因此，这四个$(piece)启动式：调试$(0)都将输出$(o)相同的$()数值，因为$(piece)运算符：随机$(0)只会求值一次。$(p)$(piece)启动式：求值$(0)可以用来让一个$(thing)术式$(0)的求值发生地\"更早\"。",
  "psi.book.page.evalOrder.7": "先到先得",
  "psi.book.category.components": "材料&组件",
  "psi.book.category.components.desc": "该书的这一部分详细地介绍了所有$(thing)Psi$(0)添加到游戏中的新的材料，以及用来构造$(thing)CAD$(0)所需的所有组件。",
  "psi.book.entry.psidust": "Psi粉末",
  "psi.book.page.psidust.0": "$(item)Psi粉末$(0)是一种从$(item)红石粉$(0)被没有聚焦的$(thing)Psi能量$(0)转化的材料，因此，它是上述能量的良导体。$(p)也因为这个原因，它是低配$(thing)CAD$(0)中的一个关键组件，它被用于合成简陋的$(l:components/core#basic)$(thing)CAD核心$(0)$(/l)，$(l:components/socket#basic)$(thing)弹夹$(0)$(/l)，$(l:components/battery#basic)$(thing)电池$(0)$(/l)，$(l:components/colorizer)$(thing)CAD着色器$(0)$(/l)。$(p)它也被用在$(l:items/spell_bullet)$(thing)术式弹药$(0)$(/l)的制作上面。",
  "psi.book.page.psidust.1": "要合成$(item)Psi粉末$(0)，首先在地上扔一些$(item)红石粉$(0)。$(p)然后，站在附近用一个$(l)没有选择$(thing)魔法式$(0)$()的$(thing)CAD$(0)进行施法($(k:use))，以此来将红石粉转为$(item)Psi粉末$(0)。$(p)$(item)Psi粉末$(0)同样能够用任意的$(piece)灌注术式$(0)来制作。",
  "psi.book.entry.psimetal": "Psi金属",
  "psi.book.page.psimetal.0": "$(item)Psi金属$(0)是一种从$(item)金锭$(0)转换而来的材料，引导、储存、传递$(thing)Psi能量$(0)的效率要$(o)更$()优于$(l:components/psidust)$(item)Psi粉末$(0)$(/l)。$(p)除了是更强大的$(l:components/core)$(thing)CAD核心$(0)$(/l)，$(l:components/socket)$(thing)弹夹$(0)$(/l)，$(l:components/battery#extended)$(thing)电池$(0)$(/l)，$(l:components/assembly#psimetal)$(thing)CAD机体$(0)$(/l)的材料，它也被用来制作$(l:items/tools)$(thing)Psi金属工具$(0)$(/l)、$(l:items/exosuit)$(thing)装甲$(0)$(/l)以及$(l:components/ebony_ivory)$(item)阴阳合金$(0)$(/l)。",
  "psi.book.page.psimetal.1": "若要制作$(item)Psi金属$(0)，首先在地上丢一些$(item)金锭$(0)。$(p)站在附近，然后用带有$(piece)启动式：灌注$(0)(或其他的$(piece)灌注术式$(0))的$(thing)魔法式$(0)来将金锭转换为$(item)Psi金属$(0)。",
  "psi.book.entry.psigem": "Psi宝石",
  "psi.book.page.psigem.0": "$(item)Psi宝石$(0)是从$(item)钻石$(0)转换而来的晶体，这些晶体的折射性质使得它们在引导、传输以及存储$(thing)Psi能量$(0)方面表现优异。$(p)它们被用来打造顶级的$(l:components/core)$(thing)CAD核心$(0)$(/l)，$(l:components/socket)$(thing)弹夹$(0)$(/l)，和$(l:components/battery#ultradense)$(thing)电池$(0)$(/l)，同时它们还是$(l:items/tools)$(thing)Psi金属工具$(0)$(/l)，$(l:items/exosuit)$(thing)装甲$(0)$(/l)的基础材料。",
  "psi.book.page.psigem.1": "若要制作$(item)Psi宝石$(0)，首先在地面上丢一个$(item)钻石$(0)。$(p)然后，站在附近，使用带有$(piece)启动式：高级灌注$(0)(或$(piece)启动式：阴阳变化$(0))的$(thing)魔法式$(0)，来将$(item)钻石$(0)转换为$(item)Psi宝石$(0)。",
  "psi.book.entry.ebonyIvory": "阴阳变化",
  "psi.book.page.ebonyIvory.0": "$(thing)末地$(0)是一个比$(thing)主世界$(0)更靠近精神体的地方。因此，它的精华对$(thing)Psi能量$(0)更具有导向性，这也是由精神体造成的。$(p)$(piece)启动式：阴阳转换$(0)可以用来捕获这些精华，将$(item)煤炭$(0)和$(item)下界石英$(0)分别转化为$(item)乌金色物质$(0)和$(item)象牙白物质$(0)。",
  "psi.book.page.ebonyIvory.1": "不幸的是，不论是$(item)乌金色$(0)还是$(item)象牙白物质$(0)都与$(thing)主世界$(0)的材料相性不好。$(p)这意味着想要将它们制作成$(l:components/core)$(thing)CAD核心$(0)$(/l)，$(l:components/socket)$(thing)弹夹$(0)$(/l)，或者$(l:components/battery)$(thing)电池$(0)$(/l)都是十分困难的。$(p)但是我们实际上$(o)可以做到$()，只要给它们镀上一层$(l:components/psimetal)$(item)Psi金属$(0)$(/l)，我们就能分别得到$(item)乌金$(0)以及$(item)象牙白Psi金属锭$(0)，这种材料足够的稳定，因此能被用于$(l:components/assembly)$(thing)CAD组件$(0)$(/l)的制作。",
  "psi.book.page.ebonyIvory.2": "若要制作$(item)乌金色物质$(0)，首先去到末地，然后在地面上丢些$(item)煤炭$(0)。$(p)然后，站在附近，使用带有$(piece)启动式：阴阳变化$(0)的$(thing)魔法式$(0)，来将$(item)煤炭$(0)转换为$(item)乌金色物质$(0)。",
  "psi.book.page.ebonyIvory.3": "若要制作$(item)象牙白物质$(0)，首先去到末地，然后在地面上丢些$(item)下界石英$(0)。$(p)然后，站在附近，使用带有$(piece)启动式：阴阳变化$(0)的$(thing)魔法式$(0)，来将$(item)下界石英$(0)转换为$(item)象牙白物质$(0)。",
  "psi.book.page.ebonyIvory.4": "黑暗之路",
  "psi.book.page.ebonyIvory.5": "在这个过程当中没有一头大象受到伤害",
  "psi.book.entry.assembly": "组件",
  "psi.book.page.assembly.0": "$(thing)CAD机体$(0)在结构上是简单的，但却是$(thing)CAD$(0)一个至关重要的组件。$(p)$(thing)CAD机体$(0)作为使用者$(thing)Psi能量$(0)的传导者——仅仅是作为一条形状合适的管道。$(p)所有$(thing)Psi$(0)的$(thing)CAD机体$(0)都是通过在合成格中，用对应的材料摆出一个侧着的L形来合成。$(p)",
  "psi.book.page.assembly.1": "$(thing)CAD机体$(0)是唯一一个必要的$(thing)CAD$(0)的组件——仅用一个$(thing)机体$(0)组装而成的$(thing)CAD$(0)可以通过合成栏将它还原成$(thing)机体$(0)。$(p)每个$(thing)机体$(0)都有一个$(l:basics/tutorial_5#potency)$(thing)强度$(0)$(/l)：它可以传导$(thing)Psi能量$(0)的最大速率。$(p)它还有一个$(l:basics/tutorial_5#cost)$(thing)效率$(0)$(/l)属性，它是使用者的$(thing)Psi能量$(0)能被$(thing)魔法式$(0)实际$(o)利用$()的百分比——$(l:basics/tutorial_5#cost)$(thing)效率$(0)$(/l)越高转化率越高。",
  "psi.book.page.assembly.2": "初级的$(item)铁质CAD机体$(0)的$(l:basics/tutorial_5#potency)$(thing)强度$(0)$(/l)以及$(l:basics/tutorial_5#cost)$(thing)效率$(0)$(/l)是本书中的$(thing)机体$(0)里面最低的。$(p)但相对的，它的成本更低，是初学者用来合成$(l:components/psidust)$(item)Psi粉末$(0)$(/l)以及其它$(thing)CAD$(0)的首选$(thing)机体$(0)。",
  "psi.book.page.assembly.3": "简洁而又优美",
  "psi.book.page.assembly.4": "$(item)金质CAD机体$(0)拥有比铁质的机体更高的$(l:basics/tutorial_5#potency)$(thing)强度$(0)$(/l)以及$(l:basics/tutorial_5#cost)$(thing)效率$(0)$(/l)——事实上，这是本书中能用普通材料做出的最好的$(thing)机体$(0)了。",
  "psi.book.page.assembly.5": "不过带着这个有点重",
  "psi.book.page.assembly.6": "$(item)Psi金属CAD机体$(0)有比$(l:components/assembly#iron)$(item)铁质机体$(0)$(/l)更高的$(l:basics/tutorial_5#cost)$(thing)效率$(0)$(/l)比$(l:components/assembly#gold)$(item)金质机体$(0)$(/l)更高的$(l:basics/tutorial_5#potency)$(thing)强度$(0)$(/l)，让它能适应更多样的需求。$(p)$(piece)启动式：高级灌注$(0)以及$(piece)启动式：阴阳变化$(0)需要这个等级或以上的$(thing)机体$(0)打造的$(thing)CAD$(0)才能够正常施展。",
  "psi.book.page.assembly.7": "两全其美",
  "psi.book.page.assembly.8": "$(item)乌金CAD机体$(0)是顶级的$(item)机体$(0)。$(p)与它的$(l:components/assembly#ivory)$(item)象牙白$(0)$(/l)变体比起来，虽然效率有点不够高，但能提供更高的$(l:basics/tutorial_5#potency)$(thing)强度$(0)$(/l)。",
  "psi.book.page.assembly.9": "大炮（可以这么说）",
  "psi.book.page.assembly.10": "$(item)象牙白CAD机体$(0)是顶级的$(item)机体$(0)。$(p)与它的$(l:components/assembly#ebony)$(item)乌金色$(0)$(/l)变体比起来，虽然强度有点不够高，但能提供更高的$(l:basics/tutorial_5#cost)$(thing)效率$(0)$(/l)。",
  "psi.book.page.assembly.11": "顺应潮流",
  "psi.book.entry.core": "CAD核心",
  "psi.book.page.core.0": "一台$(thing)CAD$(0)的$(thing)核心$(0)就是它的CPU——它负责从$(l:components/socket)$(thing)弹夹$(0)$(/l)中读取$(thing)魔法式$(0)并使用$(thing)Psi能量$(0)进行计算，以在世界上产生$(thing)术式$(0)的效果。$(p)$(thing)CAD核心$(0)通过将四个$(thing)Psi$(0)的传导材料包围在中间的Psi粉末（作为一个处理器）四周制成。",
  "psi.book.page.core.1": "每种$(thing)CAD核心$(0)都有一个$(l:basics/tutorial_5#complexity)$(thing)复杂度$(0)$(/l)属性，指代着它的最大算力(即这个$(thing)核心$(0)所能运行的$(thing)魔法式$(0)中包含的$(thing)选择符$(0)，$(thing)运算符$(0)，非调试$(thing)启动式$(0)的最大数量)。$(p)并且这个$(thing)核心$(0)还有一个$(l:basics/tutorial_5#projection)$(thing)映射$(0)$(/l)属性，指代着非调试$(thing)启动式$(0)的最大数量。",
  "psi.book.page.core.2": "$(item)基础CAD核心$(0)，它用$(item)铁$(0)作为外壳，中间是一撮$(l:components/psidust)$(item)Psi粉末$(0)$(/l)，它一般会是一个魔法师合成的第一个$(thing)CAD核心$(0)。$(p)尽管它不是十分优秀(事实上，每次施展时它只能执行一个$(thing)启动式$(0))，但是这对于一个初学者来说已经足够了。",
  "psi.book.page.core.3": "拼出来",
  "psi.book.page.core.4": "用$(l:components/psimetal)$(item)Psi金属$(0)$(/l)替换$(item)铁锭$(0)来作为$(thing)CAD核心$(0)的外壳能让我们在合成时使用不同的粉作为$(thing)核心$(0)中间的材料。$(p)如果使用$(item)红石粉$(0)，我们能得到一个$(item)超频CAD核心$(0)，它的$(l:basics/tutorial_5#complexity)$(thing)复杂度$(0)$(/l)是$(l:components/core#basic)$(item)基础版$(0)$(/l)的两倍，$(l:basics/tutorial_5#projection)$(thing)映射$(0)$(/l)则是三倍。",
  "psi.book.page.core.5": "帽子戏法",
  "psi.book.page.core.6": "如果在$(l:components/psimetal)$(item)Psi金属$(0)$(/l)的壳内放的是$(item)荧石粉$(0)，我们将得到一个$(item)传导CAD核心$(0)。$(p)这个$(thing)核心$(0)的$(l:basics/tutorial_5#complexity)$(thing)复杂度$(0)$(/l)比基于$(item)红石粉$(0)的变体要低一些，但它每次施展的时候可以执行4个$(thing)启动式$(0)，比$(l:components/core#overclocked)$(item)超频版$(0)$(/l)的3个要多。",
  "psi.book.page.core.7": "一些十分棘手的业务",
  "psi.book.page.core.8": "在$(thing)CAD核心$(0)制作的过程中嵌入两块$(l:components/psigem)$(item)Psi宝石$(0)$(/l)，能得到$(o)极大的$()性能提升。$(p)$(item)极频CAD核心$(0)，中间放的是$(item)红石粉$(0)，有双倍于$(l:components/core#conductive)$(item)传导CAD核心$(0)$(/l)的$(l:basics/tutorial_5#complexity)$(thing)复杂度$(0)$(/l)$(o)同时$()有双倍于$(l:components/core#overclocked)$(item)超频CAD核心$(0)$(/l)的$(l:basics/tutorial_5#projection)$(thing)映射$(0)$(/l)。",
  "psi.book.page.core.9": "虽然它不会告诉你时间",
  "psi.book.page.core.10": "如果我们在合成$(thing)CAD核心$(0)时在中间放上的是$(item)荧石粉$(0)并且放入$(l:components/psigem)$(item)Psi宝石$(0)$(/l)，我们就能得到一个$(item)辐射CAD核心$(0)。$(p)这个$(thing)核心$(0)与$(l:components/core#hyperclocked)$(item)极频版$(0)$(/l)相比，其$(l:basics/tutorial_5#projection)$(thing)映射$(0)$(/l)更低一些，但是每次施展时它能运行$(o)7$()个$(thing)启动式$(0)。",
  "psi.book.page.core.11": "不涉及任何技术问题",
  "psi.book.entry.socket": "弹夹",
  "psi.book.page.socket.0": "$(thing)CAD$(0)的$(thing)弹夹$(0)只是弹药的一个固定夹。$(p)是$(l:items/spell_bullet)$(thing)术式弹药$(0)$(/l)装载的地方，并且它还负责将$(l:items/spell_bullet)$(thing)弹药$(0)$(/l)里的$(thing)魔法式$(0)传到$(l:components/core)$(thing)核心$(0)$(/l)当中。$(p)只需要在金属衬底上撒一层粉末，就可以合成出$(thing)弹夹$(0)了，粉末是$(l:items/spell_bullet)$(thing)弹药$(0)$(/l)与机体连接的一个媒介。",
  "psi.book.page.socket.1": "$(thing)弹夹$(0)有一个$(l:basics/tutorial_5#bandwidth)$(thing)带宽$(0)$(/l)属性，指代着能够传导到$(l:components/core)$(thing)核心$(0)$(/l)的$(thing)魔法式$(0)的最大的大小（以格数计）——例如，一个带宽为5的$(thing)弹夹$(0)最大可以传输5x5的$(thing)魔法式$(0)。$(p)同时，它还有一个$(thing)弹仓$(0)数目，指代着$(l:items/spell_bullet)$(thing)术式弹药$(0)$(/l)的最大数量。",
  "psi.book.page.socket.2": "$(item)基础CAD弹夹$(0)是最简单的$(thing)弹夹$(0)，将一个$(l:components/psidust)$(item)Psi粉末$(0)$(/l)放在在一个$(item)铁$(0)的衬底上来合成。$(p)它可以装载4枚$(l:items/spell_bullet)$(thing)术式弹药$(0)$(/l)并且可以传输最大5x5的$(thing)魔法式$(0)。",
  "psi.book.page.socket.3": "装弹——咔嚓~",
  "psi.book.page.socket.4": "将$(thing)弹夹$(0)的$(item)铁质$(0)衬底替换为对$(thing)Psi能量$(0)传导率更高的金属(例如：$(l:components/psimetal)$(item)Psi金属$(0)$(/l))可以让我们选择不同的粉末作为$(l:items/spell_bullet)$(thing)术式弹药$(0)$(/l)的传输媒质。$(p)用$(item)红石粉$(0)作为媒质，可以得到一个$(item)信号CAD弹夹$(0)，它最多可以装载6枚$(l:items/spell_bullet)$(thing)弹药$(0)$(/l)，并且可以传输最大7x7的$(thing)魔法式$(0)。",
  "psi.book.page.socket.5": "适合作为俄罗斯转盘",
  "psi.book.page.socket.6": "将$(item)荧石粉$(0)放在$(l:components/psimetal)$(item)Psi金属$(0)$(/l)衬底上来合成$(item)大型CAD弹夹$(0)。$(p)这种$(thing)弹夹$(0)不能传输像$(l:components/socket#signaling)$(item)信号CAD弹夹$(0)$(/l)那么大的$(thing)魔法式$(0)，最多是6x6的大小，但它能装载最多8枚$(l:items/spell_bullet)$(thing)弹药$(0)$(/l)。",
  "psi.book.page.socket.7": "几乎没完没了",
  "psi.book.page.socket.8": "在$(thing)弹夹$(0)的合成表中加入一个$(l:components/psigem)$(item)Psi宝石$(0)$(/l)让它能传输更多的数据，提升了传输速度。$(p)$(l:components/socket#signaling)$(item)信号CAD弹夹$(0)$(/l)通过这种方法改进后变成了$(item)透射CAD弹夹$(0)，可以装载最多10枚$(l:items/spell_bullet)$(thing)弹药$(0)$(/l)，并且能传输$(o)任何$()在$(l:basics/spell_programmer)$(item)术式编写台$(0)$(/l)中编写的$(thing)魔法式$(0)。",
  "psi.book.page.socket.9": "Avaritia的克星",
  "psi.book.page.socket.10": "$(l:components/socket#large)$(item)大型CAD弹夹$(0)$(/l)在合成过程中添加一块$(l:components/psigem)$(item)Psi宝石$(0)$(/l)就变为$(item)巨型CAD弹夹$(0)。$(p)它没有$(l:components/socket#transmissive)$(item)透射CAD弹夹$(0)$(/l)那么大的$(l:basics/tutorial_5#bandwidth)$(thing)带宽$(0)$(/l)(只能传输最大8x8大小的$(thing)魔法式$(0))，但它能够装载十几枚$(l:items/spell_bullet)$(thing)术式弹药$(0)$(/l)。",
  "psi.book.page.socket.11": "希望Ophiuchus不要在意",
  "psi.book.entry.battery": "电池",
  "psi.book.page.battery.0": "$(thing)CAD电池$(0)是$(thing)CAD$(0)的一个可选组件，能够储存使用者身上少量的$(thing)Psi能量$(0)——它的$(thing)溢值$(0)指代着具体的量。$(p)$(thing)电池$(0)在使用者自身的$(thing)Psi能量$(0)耗尽时释放能量，这个过程是在$(thing)CAD$(0)汲取使用者生命值之前发生的。",
  "psi.book.page.battery.1": "事实上，$(thing)电池$(0)是作为$(thing)Psi能量$(0)耗尽时的一种保护性装置。$(p)它允许你透支$(o)一小部分$()能量，而不需要受伤或等待你自身$(thing)Psi能量$(0)的恢复。$(p)所有$(thing)电池$(0)都是用$(thing)Psi能量$(0)良导体围住一块$(item)铁锭$(0)和一块$(item)金锭$(0)制作而成。$(p)$(thing)电池$(0)当前的能量等级可以通过$(piece)选择符：电池$(0)在$(thing)魔法式$(0)中获取。",
  "psi.book.page.battery.2": "不是锂离子的",
  "psi.book.page.battery.3": "它是金属制的",
  "psi.book.page.battery.4": "它叫做1-(800)-BATTERY",
  "psi.book.entry.colorizer": "着色器",
  "psi.book.page.colorizer.0": "$(thing)CAD着色器$(0)是$(thing)CAD$(0)的一个可选组件，它改变使用者的$(thing)Psi能量$(0)显示在世界的时候的颜色。$(p)所有$(thing)着色器$(0)都是以一块$(item)铁锭$(0)作为基础，一撮$(l:components/psidust)$(item)Psi粉末$(0)$(/l)放在其上，两块$(item)玻璃$(0)（分别在两侧），当然，还要放一个用于染色的物品在中间。",
  "psi.book.page.colorizer.1": "$(thing)着色器$(0)可以用原版16色的$(item)染料$(0)合成为对应颜色的着色器。$(p)如果用$(item)海晶沙粒$(0)作为染料，合成出的$(thing)着色器$(0)会按照彩虹的颜色顺序不断地切换颜色。$(p)另一方面，如果$(o)没有放入$()染色的物品，合成出的$(thing)着色器$(0)会以使用者$(o)本身的$()$(thing)Psi能量$(0)的颜色来$(o)着色$()，并导致颗粒效果不可见。",
  "psi.book.page.colorizer.2": "用一撮$(l:components/psidust)$(item)Psi粉末$(0)$(/l)作为$(thing)着色器$(0)的染料会产生不可预知的现象，因为不同人报告的现象各不相同。$(p)安装在$(thing)CAD$(0)里的$(thing)着色器$(0)将影响：$(p)$(li)$(thing)CAD$(0)发射时产生粒子；$(p)$(li)投射型以及$(l:items/circle_bullet)$(thing)圈阵型$(0)$(/l)的发射；$(p)$(li)由$(piece)构筑型术式$(0)产生的方块和光源。",
  "psi.book.page.colorizer.3": "尝尝彩虹的味道",
  "psi.book.category.items": "物品",
  "psi.book.category.items.desc": "本节将介绍如何用各种实用的工具来更加方便地施展$(thing)魔法式$(0)。",
  "psi.book.entry.spellBullet": "术式弹药类型",
  "psi.book.page.spellBullet.0": "$(thing)术式弹药$(0)是一个简单的组件——将它插入$(thing)CAD$(0)的$(l:components/socket)$(thing)弹夹$(0)$(/l)里时，它仅仅是提供其内部所储存的$(thing)魔法式$(0)的数据（和元数据）给$(thing)CAD$(0)。$(p)$(thing)弹药$(0)有多种类型，每种都各有优劣。$(p)下一页中每个条目的链接都包含有对应$(thing)弹药$(0)更详细的信息。",
  "psi.book.page.spellBullet.1": "如果你想要了解一个的特定类型$(thing)术式弹药$(0)，那就开始吧。",
  "psi.book.page.spellBullet.2": "每种$(thing)术式弹药$(0)都是用一个$(item)铁锭$(0)以及一撮$(l:components/psidust)$(item)Psi粉末$(0)$(/l)水平地放置在合成格中来合成。$(p)如果没有添加额外的物品到这个合成中，那合成出来的就是最简单的$(thing)术式弹药$(0)，我们叫它$(l:items/basic_bullet)$(item)术式弹药$(0)$(/l)（不要混淆二者的名称）。$(p)其它类型的$(thing)术式弹药$(0)需要一个或多个额外的材料，只需要将它们水平地放置在$(item)铁锭$(0)的旁边。",
  "psi.book.page.spellBullet.3": "其它类型$(thing)术式弹药$(0)的额外材料如下：$(p)$(li)$(l:items/projectile_bullet)$(item)投射型术式弹药$(0)$(/l)需要$(item)箭$(0)，$(p)$(li)$(l:items/loopcast_bullet)$(item)循环型术式弹药$(0)$(/l)需要$(item)线$(0),$(p)$(li)$(l:items/circle_bullet)$(item)圈阵型术式弹药$(0)$(/l)需要，嗯，圆的东西($(item)雪球$(0)或者是$(item)黏液球$(0))，$(p)$(li)$(l:items/grenade_bullet)$(item)榴弹型术式弹药$(0)$(/l)需要一份$(item)火药$(0)，$(p)$(li)$(l:items/charge_bullet)$(item)遥控型术式弹药$(0)$(/l)需要一撮$(item)红石粉$(0)，$(p)$(li)$(l:items/mine_bullet)$(item)地雷型术式弹药$(0)$(/l)需要一个$(item)按钮$(0).",
  "psi.book.page.spellBullet.4": "在一个$(thing)术式弹药$(0)被装载到$(thing)CAD$(0)之前，它首先需要保存有$(thing)魔法式$(0)。$(p)要将$(l:basics/spell_programmer)$(item)术式编写台$(0)$(/l)中的$(thing)魔法式$(0)存入$(thing)弹药$(0)当中，只需要将$(thing)术式弹药$(0)对着$(l:basics/spell_programmer)$(item)术式编写台$(0)$(/l)挥动($(k:use))。$(p)存储在$(thing)术式弹药$(0)中的$(thing)魔法式$(0)能够被复制到一个空白的$(l:items/spell_drive)术式存储器$(item)$(0)$(/l)当中。",
  "psi.book.page.spellBullet.5": "在$(l:basics/spell_programmer)$(item)术式编写台$(0)$(/l)成功编译一个$(thing)魔法式$(0)之后会显示其$(l:basics/tutorial_5#cost)$(thing)消耗$(0)$(/l)——然而对于不同类型的$(thing)弹药$(0)，这个$(l:basics/tutorial_5#cost)$(thing)消耗$(0)$(/l)还会有变化。$(p)$(l:basics/spell_programmer)$(item)编写台$(0)$(/l)的值是基于最基础的$(thing)术式弹药$(0)，这个弹药的名字就叫做$(l:items/basic_bullet)$(item)术式弹药$(0)$(/l)。",
  "psi.book.page.spellBullet.6": "其它类型的$(thing)术式弹药$(0)会显示一个以百分比为单位$(thing)消耗乘数$(0)，可以将它直接与$(l:basics/spell_programmer)$(item)编写台$(0)$(/l)里显示的数值相乘，来计算对应类型$(thing)弹药$(0)的$(thing)魔法式$(0)的真实$(l:basics/tutorial_5#cost)$(thing)消耗$(0)$(/l)。$(p)例如，如果一个$(thing)魔法式$(0)在$(l:basics/spell_programmer)$(item)编写台$(0)$(/l)里显示的消耗是300，当它被复制到$(l:items/projectile_bullet)$(item)投射型术式弹药$(0)$(/l)($(thing)消耗乘数$(0)是：102%%)中时，它每次施展时真实的$(l:basics/tutorial_5#cost)$(thing)消耗$(0)$(/l)是：$(br)300 × 102%% = 306单位$(thing)Psi能量$(0)。",
  "psi.book.page.spellBullet.7": "大部分的$(thing)术式弹药$(0)都会在$(thing)魔法式$(0)的法术与法术之间、施展法术后法术正式开始执行之间引入一个延时。$(p)因此需要注意的是，一个$(thing)魔法式$(0)的$(l:basics/tutorial_5#cost)$(thing)消耗$(0)$(/l)在你施展瞬间就会被扣除，即使$(thing)魔法式$(0)中的$(thing)启动式$(0)没有执行，这部分消耗也不会退还。",
  "psi.book.page.spellBullet.8": "每一个$(thing)魔法式$(0)，在投射时都有一个$(thing)焦点$(0)。$(p)$(thing)焦点$(0)是施术者$(thing)Psi能量$(0)在世界上的载体(包含一个或多个$(thing)启动式$(0))。$(p)当然，$(thing)焦点$(0)不能在超过施展点32格范围外执行任何$(thing)启动式$(0)或对任何$(thing)选择符$(0)进行求值（除非这些操作是作用在施术者身上的）。$(p)$(thing)魔法式$(0)可以通过$(piece)选择符：焦点$(0)获取$(thing)焦点$(0)。",
  "psi.book.page.spellBullet.9": "$(thing)焦点$(0)的位置取决于$(thing)术式弹药$(0)的类型。$(p)基础$(l:items/basic_bullet)$(item)术式弹药$(0)$(/l)的$(thing)焦点$(0)是这个$(thing)魔法式$(0)的施术者，但其它类型的$(l:items/basic_bullet)$(item)术式弹药$(0)$(/l)可以有不同的$(thing)焦点$(0)。$(p)例如，$(l:items/projectile_bullet)$(item)投射型术式弹药$(0)$(/l)的$(thing)焦点$(0)是投射出去的弹药本身。$(p)要了解更多不同$(thing)弹药$(0)的$(thing)焦点$(0)信息，请参考对应的条目。",
  "psi.book.entry.basicBullet": "术式弹药",
  "psi.book.page.basicBullet.0": "最简单的$(l:items/spell_bullet)$(thing)术式弹药$(0)$(/l)（与物品名同名），可以储存一个$(thing)魔法式$(0)。$(p)当存储在里面的$(thing)魔法式$(0)被施展时，它将立即执行。这种$(l:items/spell_bullet)$(thing)弹药$(0)$(/l)的$(l:items/spell_bullet#focal_point)$(thing)焦点$(0)$(/l)是施术者本身。它的消耗等于$(l:basics/spell_programmer)$(item)术式编写台$(0)$(/l)上计算的消耗。$(p)这个弹药没什么有趣的点。",
  "psi.book.page.basicBullet.1": "无需火药",
  "psi.book.entry.projectileBullet": "投射型术式弹药",
  "psi.book.page.projectileBullet.0": "一个由$(item)投射型术式弹药$(0)施展的$(thing)魔法式$(0)不会被立即执行。$(p)相反，一个包含有这个术式的$(thing)魔法式投射物$(0)被从$(thing)CAD$(0)中打出。$(p)这个投射物作为这个$(thing)魔法式$(0)的$(l:items/spell_bullet#focal_point)$(thing)焦点$(0)$(/l)，当这个投射物与什么东西碰撞之后，里面的术式才会被执行。",
  "psi.book.page.projectileBullet.1": "还没到午时",
  "psi.book.page.projectileBullet.2": "$(thing)投射型术式弹药$(0)不是物理意义上的弹药；而是一颗由$(thing)Psi能量$(0)构成的，包含有$(thing)魔法式$(0)的弹药(这也导致$(l:items/spell_bullet)$(thing)弹药$(0)$(/l)的成本更高)。$(p)因此，它的存在仅能持续30秒。$(p)一颗$(thing)投射型术式弹药$(0)的移速很高，在其生命周期内可以移动超过200格的距离，并且不需要额外的辅助。",
  "psi.book.page.projectileBullet.3": "存储在投射物内的$(thing)魔法式$(0)在与方块/实体碰撞时执行。$(p)在后者的情况下，$(piece)选择符：攻击目标$(0)可以用来获取它与哪个实体进行了碰撞。$(p)另一种情况下，如果投射物$(o)没有$()与任何东西碰撞，$(thing)魔法式$(0)将会消散，释放掉其中的$(thing)Psi能量$(0)——所以，瞄准点！",
  "psi.book.entry.loopcastBullet": "循环型术式弹药",
  "psi.book.page.loopcastBullet.0": "从$(item)循环型术式弹药$(0)中施展的$(thing)魔法式$(0)，其术式产生的效果与其它$(l:items/basic_bullett)$(item)术式弹药$(0)$(/l)没有差别。$(p)但它会反复地执行里面的$(thing)魔法式$(0)。$(p)从这种$(l:items/spell_bullet)$(thing)弹药$(0)$(/l)中发射的$(thing)魔法式$(0)会以每秒4次的频率被执行，直到发射它的$(thing)CAD$(0)不再拿在同一只手上/选择了另外的$(thing)魔法式$(0)。",
  "psi.book.page.loopcastBullet.1": "定义疯狂",
  "psi.book.page.loopcastBullet.2": "一个通过$(item)循环型弹药$(0)发射的$(thing)魔法式$(0)的$(l:items/spell_bullet#focal_point)$(thing)焦点$(0)$(/l)是施术者本身，运行过程中$(thing)Psi能量$(0)的消耗都从施术者身上扣除。$(p)使用这种$(l:items/spell_bullet)$(thing)弹药$(0)$(/l)的好处是施法的速度非常快，仅仅取决于你的$(thing)Psi能量$(0)$(o)恢复速率$()。",
  "psi.book.page.loopcastBullet.3": "当你施展了一个$(thing)魔法式$(0)时（或者你受到伤害时），你的$(thing)Psi能量$(0)将暂时处于不平衡状态，在你视角稳定下来并且重新稳定住能量之前，它不会再生。$(br)虽然这不难做到，但这总归还是要耗一点时间。$(p)不过，如果你施展的是$(item)循环型术式弹药$(0)，这个现象只会发生在你$(o)施展的时候$()——在这之后，这个$(l:items/spell_bullet)$(thing)弹药$(0)$()不会再影响你的$(thing)Psi能量$(0)，从而能让它再生。",
  "psi.book.page.loopcastBullet.4": "通过这种$(l:items/spell_bullet)$(thing)弹药$(0)$(/l)发射的$(thing)魔法式$(0)可以在每次循环时做不同的事情。$(p)具体来说，$(piece)选择符：循环型次数$(0)可以返回自发射以来$(thing)魔法式$(0)已执行的次数。$(p)因此，它返回1则代表$(thing)魔法式$(0)正在执行第一次，返回2则代表正在执行第二次，以此类推。",
  "psi.book.page.loopcastBullet.5": "在配合$(piece)运算符：整除$(0)或$(piece)运算符：求余$(0)使用时，这个$(l:items/spell_bullet)$(thing)弹药$(0)$(/l)可以轻松地执行在一大片区域内执行$(o)同样的操作$()。",
  "psi.book.entry.circleBullet": "圈阵型术式弹药",
  "psi.book.page.circleBullet.0": "一个通过$(item)圈阵型术式弹药$(0)施展的$(thing)魔法式$(0)可以连续地执行20次。$(p)当$(thing)魔法式$(0)被施展时，一个$(thing)魔法式圈阵$(0)会在施术者所看的位置出现，它是这个$(thing)魔法式$(0)的$(l:items/spell_bullet#focal_point)$(thing)焦点$(0)$(/l)。这个圈阵每秒执行4次$(thing)魔法式$(0)，一共持续5秒，直到$(thing)Psi能量$(0)被耗尽。",
  "psi.book.page.circleBullet.1": "术式师们的便利店",
  "psi.book.page.circleBullet.2": "在施展时，一个$(thing)魔法式圈阵$(0)将会出现在施术者所看的最近的方块上，其最大距离为32格。$(p)和$(l:items/loopcast_bullet)$(item)循环型术式弹药$(0)$(/l)相似的是，一个通过$(thing)魔法式圈阵$(0)施展的$(thing)魔法式$(0)可以通过$(piece)选择符：循环型次数$(0)(返回1-20的数值)来获取已经循环的次数。",
  "psi.book.page.circleBullet.3": "$(thing)魔法式圈阵$(0)在发射时就会扣除其在运行时所需的全部$(thing)Psi能量$(0)，因此它的$(thing)消耗乘数$(0)是1500%%这么大。$(p)但是，它巨大的$(l:basics/tutorial_5#cost)$(thing)消耗$(0)$(/l)不是一个缺点；它紧凑的结构让它的执行效率$(o)很高$()，它仅消耗执行15次所需的能量就能把一个$(thing)魔法式$(0)执行20次。$(p)对它持观望态度的人，我要告诉你的是，它每次的执行都有25%%的消耗减免。",
  "psi.book.page.circleBullet.4": "$(item)圈阵型术式弹药$(0)因其功能的多样性以及其对$(thing)Psi能量$(0)保持性，在术式师行列里很受欢迎。$(p)因此，存在几个相对常见的适用于$(item)圈阵型术式弹药$(0)$(thing)术式$(0)。",
  "psi.book.page.circleBullet.5": "采用$(thing)同步圆环$(0)的设计，在施展时相对来说更容易构造，它能让$(thing)魔法式$(0)的那20次执行同时发生，对比单独运行的情况它有可观的规模效应。$(p)$(thing)20比特塔$(0)的设计在施展时需要用到$(l:items/vector_ruler)$(item)矢量尺$(0)$(/l)；但它能让$(thing)魔法式$(0)在20次的执行中，分别执行不同的指令。",
  "psi.book.subsec.circleBullet.6": "同步圆环",
  "psi.book.page.circleBullet.6": "$(thing)同步圆环$(0)设计（图右）需要用$(piece)启动式：休眠$(0)作为它的核心。$(p)将它放入$(thing)魔法式$(0)中，它会在执行它之后的$(thing)启动式$(0)之前作一个精确的延时。$(p)在$(piece)启动式：休眠$(0)执行完之后，之后的$(thing)启动式$(0)都会被同时地执行。",
  "psi.book.page.circleBullet.7": "当星星排成一行的时候……",
  "psi.book.subsec.circleBullet.8": "20比特塔",
  "psi.book.page.circleBullet.8": "$(thing)20比特塔$(0)是一个先进的设计技术。$(p)要使用这个技术，首先用$(l:items/vector_ruler)$(item)矢量尺$(0)$(/l)选定一个方块，然后在你所选的方块上放置20格高的方块（可以是任意方块），然后将下页中的代码复制到你$(thing)魔法式$(0)的顶部。",
  "psi.book.page.circleBullet.9": "这些垂直放置的方块所在的位置代表着一个$(thing)魔法式$(0)的执行位置；从低到高依次执行。$(p)这个塔中的空气方块代表着这个位点上的$(thing)魔法式$(0)$(o)需要执行$()，非空气方块代表着$(o)不需要执行$()。$(p)最后，复制下页中的代码到你$(thing)魔法式$(0)的顶部。",
  "psi.book.page.circleBullet.10": "条件执行",
  "psi.book.entry.grenadeBullet": "榴弹型术式弹药",
  "psi.book.page.grenadeBullet.0": "通过$(item)榴弹型术式弹药$(0)施展的$(thing)魔法式$(0)不会被立即执行，相反，会从$(thing)CAD$(0)中射出一枚$(thing)榴弹型魔法式$(0)。$(p)和$(l:items/projectile_bullet)$(thing)投射型魔法式$(0)$(/l)不同的是，榴弹型$(o)受到$()重力影响。$(p)在射出去3秒钟后其中包含的$(thing)魔法式$(0)就会被执行。",
  "psi.book.page.grenadeBullet.1": "扣动扳机，而不是保险销",
  "psi.book.page.grenadeBullet.2": "$(thing)榴弹型魔法式$(0)是用无形的$(thing)Psi能量$(0)包裹住的，是通过$(item)榴弹型术式弹药$(0)额外汲取的能量所创造的。$(p)用能量制造出的榴弹是$(thing)魔法式$(0)的$(l:items/spell_bullet#focal_point)$(thing)焦点$(0)$(/l)。$(p)虽然$(thing)榴弹型魔法式$(0)看起来用途很窄，但它能做到$(l:items/projectile_bullet)$(thing)投射型魔法式$(0)$(/l)所做不到的事(例如，翻过一堵墙，或进到一个洞里)。",
  "psi.book.page.grenadeBullet.3": "$(thing)榴弹型魔法式$(0)会记录最后与它接触过的实体。$(p)可以通过$(piece)选择符：攻击目标$(0)在$(thing)魔法式$(0)运行时获取到。",
  "psi.book.entry.chargeBullet": "遥控型术式弹药",
  "psi.book.page.chargeBullet.0": "通过$(item)遥控型术式弹药$(0)施展的$(thing)魔法式$(0)不会被立即执行，而是从$(thing)CAD$(0)中射出一枚$(thing)遥控型魔法式$(0)，它和$(l:items/grenade_bullet)$(thing)榴弹型魔法式$(0)$(/l)一样受到重力影响。$(p)但是和$(l:items/grenade_bullet)$(thing)榴弹型魔法式$(0)$(/l)不同的是，$(thing)遥控型魔法式$(0)可以持续存在5分钟的时间，并且仅仅在$(l:items/detonator)$(item)术式引信$(0)$(/l)触发它的时候才会执行$(thing)魔法式$(0)。",
  "psi.book.page.chargeBullet.1": "炸药已安置",
  "psi.book.page.chargeBullet.2": "$(thing)遥控型魔法式$(0)是用一个稳定的$(thing)Psi能量$(0)外壳包裹住$(thing)魔法式$(0)所构成，它也是$(thing)魔法式$(0)执行时的$(l:items/spell_bullet#focal_point)$(thing)焦点$(0)$(/l)。$(p)如果$(thing)遥控型魔法式$(0)在它生命周期内没有被执行，它仅仅会消散掉，里面包含的$(thing)魔法式$(0)和$(thing)Psi能量$(0)都会消失。",
  "psi.book.page.chargeBullet.3": "但是，当许多的$(thing)遥控型魔法式$(0)在小范围内被$(l:items/detonator)$(item)术式引信$(0)$(/l)(或者$(piece)启动式：触发引信$(0))同时触发，可以产生可观的规模效应。$(p)$(thing)遥控型魔法式$(0)可以记录最后一次与它碰撞的实体(更口语化：最后一个踩到它的实体)。$(p)当$(thing)魔法式$(0)运行的时候，这个实体可以通过$(piece)选择符：攻击目标$(0)来获取，这个实体也可能不存在。",
  "psi.book.entry.mineBullet": "地雷型术式弹药",
  "psi.book.page.mineBullet.0": "通过$(item)地雷型术式弹药$(0)施展的$(thing)魔法式$(0)会从$(thing)CAD$(0)中射出一枚$(thing)地雷型魔法式$(0)。$(p)$(thing)地雷型魔法式$(0)受重力影响并且其生命周期是5分钟，其仅仅在有人（或物）踩到它才会执行内部的$(thing)魔法式$(0)。",
  "psi.book.page.mineBullet.1": "乡村道路……",
  "psi.book.page.mineBullet.2": "$(thing)地雷型魔法式$(0)的执行条件相当严格；地雷仅在它触碰到地面时才会对踩到它的实体起反应。$(p)当一个或多个实体踩在它上面时，地雷不会立即触发；它仅仅激活雷管。$(p)当雷管激活后，并且没有实体仍踩在它上面，它才会执行$(thing)魔法式$(0)。",
  "psi.book.page.mineBullet.3": "触发$(thing)魔法式$(0)的实体(也就是最后一个离开$(thing)地雷型魔法式$(0)的实体)可以通过$(piece)选择符：攻击目标$(0)来获取。$(p)但是，如果$(thing)地雷型魔法式$(0)在它的生命周期内没有被执行，它仅仅会消散掉，释放其中包含的能量。$(p)所以如果你踩到了一个$(thing)地雷型魔法式$(0)，等待它的消散可能比知道它执行的效果更好。",
  "psi.book.entry.detonator": "术式引信",
  "psi.book.page.detonator.0": "一个$(item)术式引信$(0)是由两个$(item)铁锭$(0)，一个$(l:components/psidust)$(item)Psi粉末$(0)$(/l)以及一个$(item)按钮$(0)制作出来的。$(p)它只有一个用途：当它激活的时候($(k:use))，它将触发以你为中心，半径32格内所有由你发射的$(l:items/charge_bullet)$(thing)遥控型弹药$(0)$(/l)(以及$(l:items/exosuit_sensor#trigger)$(item)引信传感器$(0)$(/l))指示它们同时运行其内的$(thing)魔法式$(0)。",
  "psi.book.page.detonator.1": "第一枚炸弹",
  "psi.book.entry.exosuit": "Psi金属装甲",
  "psi.book.page.exosuit.0": "$(thing)Psi金属装甲$(0)是一套能将$(thing)魔法式$(0)的施展无缝融入到你日常冒险中的装备。$(p)$(thing)装甲$(0)的每个部份都是用两个$(l:components/psigem)$(item)Psi宝石$(0)$(/l)以及一些$(l:components/psimetal)$(item)Psi金属$(0)$(/l)来合成，当它特定的传感器被触发后，对应的$(thing)魔法式$(0)就会被执行。",
  "psi.book.page.exosuit.1": "装甲的$(thing)魔法式$(0)是以你的$(thing)CAD$(0)作为施展的工具，所以通常的$(thing)CAD$(0)的限制也适用于装甲。$(p)$(thing)Psi金属装甲$(0)的每个部分可以通过$(l:basics/cad_assembler)$(item)CAD装配器$(0))$(/l)装载最多3个$(l:items/spell_bullet)$(thing)术式弹药$(0)$(/l)，可惜的是部分$(l:items/spell_bullet)$(thing)术式弹药$(0)$(/l)类型不适用于装甲。$(p)装甲的每个部分都会存储它成功施展$(thing)魔法式$(0)的次数；可以通过$(piece)选择符：成功次数$(0)来获取。",
  "psi.book.page.exosuit.2": "要设置装甲每个部分所施展的$(thing)魔法式$(0)，合成一个$(item)装甲控制器$(0)，它用$(item)红石粉$(0)，$(item)玻璃$(0)以及$(l:components/psimetal)$(item)Psi金属$(0)$(/l)来合成。要使用$(item)控制器$(0)，按住$(thing)Psi键位$(0)($(k:psimisc.keybind))。$(p)用鼠标的左右键来循环切换装甲的部分。",
  "psi.book.page.exosuit.3": "没有JARVIS，但它能正常工作",
  "psi.book.page.exosuit.4": "当你选择了你要配置的装甲部分，像$(thing)CAD$(0)那样选择一个你要的$(l:items/spell_bullet)$(thing)术式弹药$(0)$(/l)。$(p)选择第四个空的槽位意味着你关闭了这一部分装甲——无论它的传感器是否激活，其中的$(thing)魔法式$(0)都不会被执行。",
  "psi.book.page.exosuit.5": "$(thing)Psi金属装甲$(0)在强度和耐久度上比$(thing)铁甲$(0)好上一点。$(p)每个装甲的部分都会汲取穿戴者溢出的$(thing)Psi能量$(0)来修复损伤，在合成时用到的$(l:components/psigem)$(item)Psi宝石$(0)$(/l)使这个功能变为可能。",
  "psi.book.page.exosuit.6": "$(item)Psi金属装甲头盔$(0)是所有装甲中可配置属性最多的，当其中的$(l:items/exosuit_sensor)$(thing)装甲传感器$(0)$(/l)被触发时，它就会施展指定的$(thing)魔法式$(0)。$(p)$(l:items/exosuit_sensor)$(thing)传感器$(0)$(/l)可以在合成栏中被加入/取出$(item)头盔$(0)；$(item)头盔$(0)一次只能加入一个$(l:items/exosuit_sensor)$(thing)装甲传感器$(0)$(/l)。",
  "psi.book.page.exosuit.7": "你听到了一个响声，然后转过身",
  "psi.book.page.exosuit.8": "$(item)Psi金属装甲胸甲$(0)在穿戴者受到伤害时施展选定的$(thing)魔法式$(0)。$(p)$(piece)选择符：攻击者$(0)以及$(piece)选择符：受到的伤害$(0)可以用来获取攻击源以及受到伤害的值。",
  "psi.book.page.exosuit.9": "易爆的荆棘",
  "psi.book.page.exosuit.10": "$(item)Psi金属装甲护腿$(0)会$(o)不停地$()施展选定的$(thing)魔法式$(0)。$(p)事实上，它每$(thing)CAD$(0)Tick施展一次，即0.05秒。$(p)它被广泛地作为\"更好的$(l:items/loopcast_bullet)$(item)循环型术式弹药$(0)$(/l)\"。",
  "psi.book.page.exosuit.11": "while(true){}",
  "psi.book.page.exosuit.12": "$(item)Psi金属装甲靴子$(0)在穿戴者跳到地上时执行一次$(thing)魔法式$(0)。$(p)一次不多一次不少。",
  "psi.book.page.exosuit.13": "跳跃提升——额，是靴子",
  "psi.book.entry.exosuitSensor": "装甲传感器",
  "psi.book.page.exosuitSensor.0": "$(thing)装甲传感器$(0)是设计来嵌入装甲的小型组件(例如，$(l:items/exosuit#helmet)$(item)Psi金属装甲头盔$(0)$(/l))，并且会在其受到触发时传递信号给装甲。$(p)每个$(thing)传感器$(0)的触发条件各不相同。",
  "psi.book.page.exosuitSensor.1": "所有$(thing)传感器$(0)都是用两个$(item)铁锭$(0)和两个$(l:components/psimetal)$(item)Psi金属$(0)$(/l)包裹着反应物来合成；反应物用来决定$(thing)传感器$(0)最终的效果。$(p)$(li)$(item)光传感器$(0)需要$(item)荧石粉$(0)；$(p)$(li)$(item)热传感器$(0)需要$(item)火焰弹$(0)；$(p)$(li)$(item)应激传感器$(0)需要$(item)闪烁的西瓜$(0)；$(p)$(li)$(item)水传感器$(0)需要$(item)海晶沙粒$(0)；$(p)$(li)$(item)引信传感器$(0)需要$(item)火药$(0)。",
  "psi.book.page.exosuitSensor.2": "$(item)光传感器$(0)在穿戴者从一个明亮的区域移动到一个昏暗的区域时会被触发（也就是亮度允许刷怪的区域）。$(p)可以通过$(piece)启动式：构筑光线$(0)来使其在昏暗的区域被手动触发。",
  "psi.book.page.exosuitSensor.3": "谁把灯关了？",
  "psi.book.page.exosuitSensor.4": "$(item)热传感器$(0)在穿戴者着火时被触发。$(p)$(piece)启动式：抗火$(0)或$(piece)启动式：洪流$(0)是在$(thing)传感器$(0)被触发时的首选响应术式，除非你$(o)真的$()知道你在做什么。",
  "psi.book.page.exosuitSensor.5": "我们继续",
  "psi.book.page.exosuitSensor.6": "$(item)应激传感器$(0)在穿戴者生命值低的时候被触发(准确地说是在3颗心或以下时触发)。$(p)$(piece)启动式：再生$(0)是在触发时的首选响应术式。",
  "psi.book.page.exosuitSensor.7": "别慌",
  "psi.book.page.exosuitSensor.8": "$(item)水传感器$(0)在穿戴者触碰到水的时候触发。$(p)聪明的你可以想到，它可以通过$(piece)启动式：洪流$(0)来手动触发。",
  "psi.book.page.exosuitSensor.9": "引起轰动",
  "psi.book.page.exosuitSensor.10": "$(item)引信传感器$(0)：在$(l:items/detonator)$(item)术式引信$(0)$(/l)在32格半径内激活时被触发，或当一个$(piece)启动式：触发引信$(0)在同一范围内施展时被触发。",
  "psi.book.page.exosuitSensor.11": "当你按下按钮",
  "psi.book.entry.tools": "Psi金属工具",
  "psi.book.page.tools.0": "$(thing)Psi金属工具$(0)是一系列工具，有着与$(item)钻石$(0)工具相媲美的挖掘等级，每个工具在使用时都可以施展$(thing)魔法式$(0)。$(p)所有$(thing)Psi金属工具$(0)都是用$(item)铁锭$(0)来代替$(item)木棍$(0)，一个$(l:components/psigem)$(item)Psi宝石$(0)$(/l)，以及一些$(l:components/psimetal)$(item)Psi金属$(0)$(/l)来合成。",
  "psi.book.page.tools.1": "这是一个额外的操作",
  "psi.book.page.tools.2": "$(thing)Psi金属工具$(0)最多可以在$(l:basics/cad_assembler)$(item)CAD装配器$(0)$(/l)中装载3个$(l:items/spell_bullet)$(thing)术式弹药$(0)$(/l)(虽然有部分$(l:items/spell_bullet)$(thing)术式弹药$(0)$(/l)不适用于Psi金属工具)。$(p)要为工具选择$(l:items/spell_bullet)$(thing)术式弹药$(0)$(/l)，按住$(thing)Psi热键$(0)($(k:psimisc.keybind))然后和平常一样从菜单中选择就好。$(p)选择一个空的槽位意味着关闭工具的施展功能。",
  "psi.book.page.tools.3": "所有$(thing)Psi金属工具，$(0)除了$(item)Psi金属剑，$(0)在每次破坏一个方块时都会施展一次$(thing)魔法式$(0)。$(p)$(item)剑$(0)则在每次击中一个实体时施展$(thing)魔法式$(0)(需要注意的是，每次伤害了一个实体后，这个实体有短暂的无敌时间)。$(p)$(thing)Psi金属工具$(0)会汲取使用者逸散的$(thing)Psi能量$(0)来修复损伤。",
  "psi.book.page.tools.4": "$(thing)Psi金属工具$(0)对部分$(thing)术式$(0)有兼容性更改。$(p)当$(item)Psi金属剑$(0)施展$(thing)魔法式$(0)时，$(piece)选择符：攻击目标$(0)返回你所伤害的目标。$(p)当其它$(thing)工具$(0)破坏方块时，$(piece)选择符：被破坏的方块$(0)返回你刚刚所破坏的方块，$(piece)选择符：被破坏的方块 | 挖掘面$(0)返回被破坏的方块被挖掘面的法向量。",
  "psi.book.entry.vectorRuler": "矢量尺",
  "psi.book.page.vectorRuler.0": "$(item)矢量尺$(0)可以存储任意矢量，可以在$(thing)魔法式$(0)中获取到。$(p)它使用$(item)铁锭$(0)和一撮$(l:components/psidust)$(item)Psi粉末$(0)$(/l)来合成。",
  "psi.book.page.vectorRuler.1": "矢量规则",
  "psi.book.page.vectorRuler.2": "在潜行时用$(item)尺$(0)敲($(k:use))一下方块，能够将方块的位置矢量保存到$(item)尺$(0)中。$(p)在$(item)尺$(0)中存有方块位置时，在非潜行状态用$(item)尺$(0)敲($(k:use))另一个方块，能够将两个方块之间的偏移作为一个矢量存储起来。$(p)存储在$(item)尺$(0)中的矢量可以用$(piece)选择符：矢量尺$(0)来获取。",
  "psi.book.page.vectorRuler.3": "如果你身上带有多把$(item)尺$(0)，$(piece)选择符：矢量尺$(0)会返回你快捷栏中最左边的$(item)尺$(0)，如果你快捷栏中没有的话则返回你背包中最左上方的$(item)尺$(0)。",
  "psi.book.entry.spellDrive": "术式存储器",
  "psi.book.page.spellDrive.0": "$(item)术式存储器$(0)，由两个$(l:components/psimetal)$(item)Psi金属锭$(0)$(/l)和一撮$(item)红石粉$(0)来合成，它可以存储一个$(thing)魔法式$(0)以供日后使用。$(p)要将$(l:basics/spell_programmer)$(item)术式编写台$(0)$(/l)里的$(thing)魔法式$(0)存储到$(item)存储器$(0)当中，潜行并对着编写台挥动($(k:use))空的$(item)存储器$(0)。$(p)要将$(thing)魔法式$(0)复制回编写台，手持一个存有$(thing)魔法式$(0)的$(item)存储器$(0)，潜行并对着$(l:basics/spell_programmer)$(item)编写台$(0)$(/l)挥动($(k:use))。",
  "psi.book.page.spellDrive.1": "建一个属于你的图书馆",
  "psi.book.page.spellDrive.2": "要清除里面存储的$(thing)魔法式$(0)，手持$(item)存储器$(0)对着任意方块潜行右击。$(p)可以通过将空白的$(item)存储器$(0)与存有$(thing)魔法式$(0)的$(item)存储器$(0)或$(l:items/spell_bullet)$(thing)术式弹药$(0)$(/l)合成来将后者的$(thing)魔法式$(0)复制到前者当中。",
  "psi.book.category.legacy": "旧版条目",
  "psi.book.category.legacy.desc": "这些条目出自1.12及之前版本的$(thing)Psi$(0)。现在这本书中的条目还在重写，当所有条目都重写完毕之后，这些个条目就会永久消失。",
  "psi.book.entry.vectors101": "矢量101",
  "psi.book.page.vectors101.0": "矢量操作是$(thing)魔法式$(0)编写的基础。大部分矢量运算符在$(l:basics/vector_primer#ops)这里$(/l)介绍；唯一没有提到的术式是$(piece)运算符：矢量叉乘$(0)。",
  "psi.book.page.vectors101.1": "两个矢量$(l)叉乘$()的结果是一个矢量，这个矢量同时垂直于这两个矢量。通过将你视线的矢量和[0,1,0]($(piece)运算符：矢量构造$(0))叉乘，可以获得一个指向你侧面的矢量。",
  "psi.book.entry.entities101": "实体101",
  "psi.book.page.entities101.0": "实体操作是$(thing)魔法式$(0)编写的基本组成部分。最显然的可操作实体是你本身，即施术者，通过$(piece)选择符：施术者$(0)来获取。其它的术式，允许你操作其它在世界上的实体。$(p)你可以用这些术式来创造可以作用在其它实体上的$(thing)魔法式$(0)。尝试将它们配合$(piece)启动式：附加运动$(0)来抛起附近的实体。",
  "psi.book.entry.blockworks": "方块操作",
  "psi.book.page.blockworks.0": "方块操作是魔法师的基础技能。你可以通过矢量来指向一个方块的位置，所以了解与矢量有关的知识是你操作方块的必要前提。$(p)两个基础的方块相关的术式是$(piece)启动式：放置方块$(0)和$(piece)启动式：破坏方块$(0)。",
  "psi.book.page.blockworks.1": "这两个术式都接受一个位置矢量，放置/破坏对应位置的方块。$(piece)启动式：放置方块$(0)使用你快捷栏$(thing)CAD$(0)右边格子里的方块来放置。要知道要破坏的方块的位置是十分容易的；$(piece)运算符：矢量追踪$(0)能够满足你的需要。",
  "psi.book.page.blockworks.2": "然而，放置一个方块则要更为复杂一些：$(piece)运算符：矢量追踪$(0)返回玩家正在看的方块的位置。我们不能在那里放置方块——因为那里$(o)已经$()有一个方块了！要处理这个问题，我们可以将$(piece)运算符：矢量追踪$(0)与$(piece)运算符：矢量轴向追踪$(0)术式配合使用，它返回一个我们正在看的方块的面的法向量。",
  "psi.book.page.blockworks.3": "例如，如果我们看着方块的顶部，它会返回一个轴向矢量[0, 1, 0]。我们可以用$(piece)运算符：矢量和$(0)来将它与矢量追踪得到的位置矢量相加！$(p)$(piece)运算符：实体轴向视线$(0)类似于$(piece)运算符：实体视线$(0)，但它返回六个轴向矢量中的一个(例如，如果你看着西面，则返回[1, 0, 0])。参考你F3调试屏幕中\"Facing\"的值。",
  "psi.book.page.blockworks.4": "另外两个实用的$(thing)启动式$(0)是$(piece)启动式：放置方块序列$(0)以及$(piece)启动式：破坏方块序列$(0)。这两个$(thing)启动式$(0)破坏/放置一行方块。类似于普通的破坏/放置$(thing)启动式$(0)，它们需要一个开始放置的位置矢量，以及另一个矢量，\"目标\"，它定义了执行术式时的方向。所以如果\"目标\"是[0, 1, 0]，它会从指定的\"位置\"开始向上放置/破坏方块。",
  "psi.book.page.blockworks.5": "这些$(thing)启动式$(0)的最后一个参数是\"最大\"，这个常数指示了$(thing)启动式$(0)能够破坏/放置的方块的最大数量。因为矢量参数是实时计算的，这个值就被用来作为这个$(thing)启动式$(0)的强度和消耗的依据。这个值越高，$(thing)魔法式$(0)的消耗就越大。$(p)这个条目要介绍的最后一个术式是$(piece)运算符：矢量投影$(0)。",
  "psi.book.page.blockworks.6": "矢量投影是一个复杂的话题，所以接下来仅仅介绍一下它的一些可能的用途。$(p)假设你想让一个$(thing)魔法式$(0)在你的位置到你所指方块的面(用$(piece)运算符：矢量轴向追踪$(0))这条直线上放置方块的话。",
  "psi.book.page.blockworks.7": "首先你要计算一个沿着那条直线的矢量，然后你就可以将这个矢量传递给$(piece)启动式：放置方块序列$(0)。如果你与所指方块呈对角线站立，你可能会得到[3, 2, 4]这样的矢量。这不是一条直线！我们可以用$(piece)运算符：矢量投影$(0)来将它投影到所指的面的轴上，例如[0, 0, 1]。",
  "psi.book.page.blockworks.8": "因此我们的\"矢量A\"是[3, 2, 4]、\"矢量B\"是[0, 0, 1]。执行投影运算之后我们得到[0, 0, 4]。如果我们的\"矢量B\"是，例如，[1, 0, 0]，我们会得到[3, 0, 0]。总之，当将一个轴向矢量作为\"矢量B\"进行$(piece)运算符：矢量投影$(0)，可以让B中为0的值同样在A中也为0，从而得到一条直线。$(p)尝试制作一个可以破坏8格高方块的$(thing)魔法式$(0)，这样你就可以用它来砍树了。",
  "psi.book.entry.movementAdvances": "高级移动",
  "psi.book.page.movementAdvances.0": "与移动有关的$(thing)启动式$(0)我们在之前提到过：$(piece)启动式：附加运动$(0)。本章的术式是在它的上面改进而来。$(p)$(piece)启动式：闪现$(0)可以将实体往它们看的方向传送一段距离。指定一个负值可以让它们往反方向传送。",
  "psi.book.page.movementAdvances.1": "$(piece)启动式：群体闪现$(0)所做的操作和$(piece)启动式：闪现$(0)相同，不同的是它接受一个实体列表作为参数；每个在列表内的实体受到$(thing)启动式$(0)的影响是独立的。$(p)$(piece)启动式：群体附加运动$(0)也是类似的；是$(piece)启动式：附加运动$(0)的实体列表的版本。$(p)最后，$(piece)启动式：群体移动$(0)可以将实体列表中的每个实体附加一个指向指定位置的速度。负的速度可以将它们往返方向推动。",
  "psi.book.entry.blockMovement": "移动方块",
  "psi.book.page.blockMovement.0": "移动方块的能力与破坏和放置方块相比没那么重要，但是它有时候相当的有用。$(p)$(piece)启动式：移动方块$(0)接受一个方块的位置矢量，让它朝指定矢量的方向上移动，就好像它被活塞所推动那样。目标的向量必须为轴向向量，否则$(thing)启动式$(0)会运行失败。",
  "psi.book.page.blockMovement.1": "另一方面，$(piece)启动式：方块崩塌$(0)能够让方块像沙子或沙砾那样下落。$(p)这两个$(thing)启动式$(0)在作用于复杂的方块(即TileEntities)以及无法被精准采集的方块时会失效。",
  "psi.book.entry.elementalArts": "元素艺术",
  "psi.book.page.elementalArts.0": "一个无法施展元素$(thing)魔法式$(0)的魔法系统会是什么样的？$(p)这个条目包含4种元素类$(thing)启动式$(0)；例如，$(piece)启动式：雷击$(0)能够在指定位置产生闪电。",
  "psi.book.page.elementalArts.1": "同时也包含$(piece)运算符：随机$(0)，一个会产生在[0,X)区间内的随机数的术式，这个可以用在循环型或圈阵型$(thing)魔法式$(0)上。例如，创建一个使用$(piece)启动式：催生$(0)来批量催熟种植园里的作物的$(thing)魔法式$(0)。",
  "psi.book.entry.positiveEffects": "正面效果",
  "psi.book.page.positiveEffects.0": "能够给予物品、实体魔法般的效果是任何重量级魔法词汇所必备的特征。尽管我们没有按照魔导书来编写$(thing)魔法式$(0)，但你仍然能够给予实体你想要的效果。$(p)这一章将介绍可以给予实体指定时长（以秒为单位）药水效果的术式。",
  "psi.book.page.positiveEffects.1": "如果术式还指定了\"级别\"参数，它指示了要附加的药水效果的等级。$(p)例如，给$(piece)启动式：速度$(0)指定时间20级别2，会给实体附加一个时长20秒的速度II效果。",
  "psi.book.entry.negativeEffects": "负面效果",
  "psi.book.page.negativeEffects.0": "正如你所想，既然有$(l:legacy/positive_effects)正面效果$(/l)那就有负面效果。$(p)这没什么可说的，真的。所有的启动式所附加的效果和它们的名称一样。$(p)祝玩得开心。",
  "psi.book.entry.trigonometry": "三角函数",
  "psi.book.page.trigonometry.0": "这章所包含的$(thing)运算符$(0)与三角函数有关。$(piece)常量：Pi$(0)顾名思义，返回π=3.1415……。$(p)同样地，这章还有基础的三角函数运算符：正弦、余弦函数，以及对应的反函数（反正弦，反余弦）。",
  "psi.book.page.trigonometry.1": "此外，$(piece)运算符：矢量点乘$(0)返回两个矢量点乘的结果：两个矢量的模乘以它们角度的cos值。将结果传递给$(piece)运算符：反余弦$(0)能够让你获取两个矢量的夹角。",
  "psi.book.entry.smeltery": "冶炼",
  "psi.book.page.smeltery.0": "这章中的术式的功能十分简单；它们可以将一个东西熔炼成另一个东西，就跟将它们放到熔炉中一样。$(p)$(piece)启动式：熔炼物品$(0)会将地上的物品熔炼成对应的产物。",
  "psi.book.page.smeltery.1": "$(piece)启动式：熔炼方块$(0)会将一个方块熔炼成它被熔炼后的版本，熔炼之后它仍然保持其方块的状态。$(p)所以，一个圆石可以熔炼成石头，然后是平滑石头，但一个原木不能被熔炼成木炭。",
  "psi.book.entry.flowControl": "流程控制",
  "psi.book.page.flowControl.0": "流程控制是一个复杂的课题。这里的术式能让$(thing)魔法式$(0)以完全不同的形式来运行。但是，要知道如何正确地使用这些术式需要深入了解术式的执行系统——读$(l:basics/eval_order)这篇文章$(/l)以了解更多。",
  "psi.book.page.flowControl.1": "读完上述文章，让我们先从$(piece)启动式：休眠$(0)开始介绍。这个术式让$(thing)魔法式$(0)延迟指定tick(1tick= 0.05秒)后再继续执行。所以如果你想让$(thing)魔法式$(0)延迟0.5秒执行，你需要在\"时间\"参数处指定10。$(piece)启动式：休眠$(0)不会增加$(thing)魔法式$(0)的$(l:basics/tutorial_5#projection)$(thing)映射$(0)$(/l)但会增加$(l:basics/tutorial_5#potency)$(thing)强度$(0)$(/l)。",
  "psi.book.page.flowControl.2": "$(piece)启动式：求值$(0)是一个不做任何操作的$(thing)启动式$(0)。$(p)是的，你没听错。这个$(thing)启动式$(0)不做任何操作。它也不会给你的$(thing)魔法式$(0)增加任何属性。$(p)它仅仅能够让你在$(piece)启动式：休眠$(0)执行前求值，例如，在$(piece)启动式：休眠$(0)执行前获取实体的位置，为后续$(thing)魔法式$(0)的操作做准备。",
  "psi.book.page.flowControl.3": "另一方面，$(piece)启动式：终结$(0)，是传统意义上的流程控制术式。$(p)它接受一个数值参数，如果数值的绝对值小于1(不包含1)，它就会立即停止$(thing)魔法式$(0)的执行。传入其它的数值到$(thing)启动式$(0)能让$(thing)魔法式$(0)和平常一样继续执行下去。$(p)这个术式不增加$(l:basics/tutorial_5#projection)$(thing)映射$(0)$(/l)。",
  "psi.book.page.flowControl.4": "一个非常简单的使用$(piece)启动式：终结$(0)的方法是将它与$(piece)选择符：潜行状态$(0)配合使用，它在施术者潜行时返回0否则返回1。$(p)为什么，这两个术式就好像天生就应该被一起使用！",
  "psi.book.page.flowControl.5": "$(piece)常量：封装$(0)允许你将术式的返回值提供给需要常量类型的$(thing)启动式$(0)。$(p)你应该知道的是，提供给$(thing)启动式$(0)的常量如果是被用于计算$(thing)魔法式$(0)的属性(包括消耗$(0)$(l:basics/tutorial_5#cost)$(thing)$(/l))的话，那么这些常量的值必须在$(thing)魔法式$(0)施展前就被确定。$(p)正因为这些常量需要在编译时确定，所以在运行时才能确定的数值是不能在这里使用的。",
  "psi.book.page.flowControl.6": "$(piece)常量：封装$(0)通过接受两个数值，一个常量，一个非常量来处理这个问题。$(p)常量用于$(thing)魔法式$(0)编译期的计算；在$(thing)魔法式$(0)实际运行的时候，使用的是非常量的数值。$(p)非常量数值在$(thing)魔法式$(0)运行时的值的上限是常量的值，以此防止一些愚蠢的行为。",
  "psi.book.page.flowControl.7": "运行时数值的符号位强制指定为常量的符号位，因此两个数值的符号位能够匹配。如果常量是0，那么无论运行时的值是多少$(piece)常量：封装$(0)总是返回0。",
  "psi.book.entry.blockConjuration": "方块构筑术",
  "psi.book.page.blockConjuration.0": "这章节的术式的功能和宣传的一样：它们构筑方块。$(p)$(piece)启动式：构筑方块$(0)在指定位置构筑一个方块，一个半透明的固体方块。构筑出的方块，如果指定了\"时间\"参数，在经过指定时间后就会自己消失。",
  "psi.book.page.blockConjuration.1": "\"时间\"参数，以tick为单位(0.05秒)。因此，如果你想要方块在0.5秒后消失，设置\"时间\"参数为10tick。$(p)$(piece)启动式：构筑光线$(0)则会构筑一个光源，这个光源是没有碰撞箱的。",
  "psi.book.page.blockConjuration.2": "$(piece)启动式：构筑方块序列$(0)的功能与$(piece)启动式：放置方块序列$(0)类似，但它是构筑而不是放置方块。这两个术式都包含有\"时间\"参数。$(p)构筑出的方块十分脆弱，在玩家用任意工具敲的时候会立即碎裂。",
  "psi.book.entry.eidosManipulation": "时空操作",
  "psi.book.page.eidosManipulation.0": "时空相关的$(thing)启动式$(0)允许施术者控制时间和空间。$(p)$(piece)启动式：时空逆流$(0)能让施术者以两倍速回溯他们移动的路径，这个术式需要指定回溯的时间（以秒为单位）。",
  "psi.book.page.eidosManipulation.1": "一次施展只能运行一个时空逆流，并且在逆流一次之后，之后施展的逆流只能回到上一次逆流之后的位置。潜行可以终止正在进行的逆流。$(p)这章节中另一个$(thing)启动式$(0)，$(piece)启动式：时空之锚$(0)可以为施术者创建一个\"锚点\"。",
  "psi.book.page.eidosManipulation.2": "在经过指定的时间（以秒为单位）后，施术者会被传送回锚点所在的位置。$(piece)启动式：时空之锚$(0)可以多次执行，但只有最后一次创建的锚点是有效的。",
  "psi.book.page.eidosManipulation.3": "最后，$(piece)选择符：时空变更记录$(0)接受一个数值参数(让我们叫它n)，然后返回第n个时空变更记录的位置矢量。换言之，它返回你n Tick前所在的位置矢量。$(p)$(piece)启动式：时空逆流$(0)会带你回到记录中你之前的位置，并且清除\"之后\"的所有位置信息。$(piece)启动式：时空之锚$(0)不会更改记录中的数据。",
  "psi.book.entry.detectionDynamics": "探测&焦点",
  "psi.book.page.detectionDynamics.0": "这章节中包含两种类型的术式，就如同标题所说的：探测和焦点。要理解这一切，就必须引入\"槽位焦点\"的概念。",
  "psi.book.page.detectionDynamics.1": "一个已知的槽位焦点的例子是放置方块类型的$(thing)启动式$(0)。这些术式直接使用你的$(thing)CAD$(0)槽位右侧的方块。槽位焦点意味着对应的槽位会被上述类型的$(thing)启动式$(0)所使用。它可以是相对的(以你的$(thing)CAD$(0)为基准)也可以是绝对的，并且它的只能够是快捷栏中的1 - 9个槽位。",
  "psi.book.page.detectionDynamics.2": "默认情况下，当你施展一个$(thing)魔法式$(0)时，它的值是\"相对1\"，所以它指代着你的$(thing)CAD$(0)右侧的1格。如果它是\"相对-1\"，那就指代着你的$(thing)CAD$(0)左侧一格。\"绝对3\"指代着你快捷栏第3个格。并且它是循环的，所以如果你的$(thing)CAD$(0)放在快捷栏最右边的格子，然后焦点槽位是\"相对1\"，那么它指代着你快捷栏第1个格。",
  "psi.book.page.detectionDynamics.3": "要设置焦点槽位，你可以使用$(piece)启动式：切换焦点槽位$(0)。它接受2个参数。两个参数都是可选并且互斥的，如果你都不指定，它就会设置为默认的\"相对1\"。如果你指定\"位置\"参数，它会设置一个绝对的值，\"移位\"参数会设置一个相对的值。",
  "psi.book.page.detectionDynamics.4": "这个术式能让你做许多事，例如，根据不同环境选择不同的方块来构建东西。这个$(thing)启动式$(0)仅仅在当前施展的$(thing)魔法式$(0)中生效，当你下一次施展$(thing)魔法式$(0)时焦点槽位就会被重置(即使两次施展都是同一个$(thing)魔法式$(0))。$(p)这章另外两个术式是用在\"探测\"领域。",
  "psi.book.page.detectionDynamics.5": "首先，$(piece)选择符：物品存在性$(0)接受一个可选槽位的数值(如果不指定，默认是你的焦点槽位)，然后返回这个槽位里有多少个物品，当然，如果槽位是空的，那就返回0。",
  "psi.book.page.detectionDynamics.6": "最后，$(piece)选择符：方块存在性$(0)接受一个矢量，指代世界中方块的坐标，并在指代位置找寻方块，如果对应的位置没有方块或方块可以被替换（像是高草），返回0，如果是非固体方块则返回1，如果是固体方块则放回2。",
  "psi.book.entry.memoryManagement": "内存管理",
  "psi.book.page.memoryManagement.0": "这个章节介绍如何让$(thing)魔法式$(0)在$(thing)CAD$(0)中存储数据。$(thing)CAD$(0)能够存储一个矢量供之后的$(thing)魔法式$(0)使用。$(thing)CAD$(0)每3个$(l:components/socket)$(thing)弹夹$(0)$(/l)容量可以存储一个矢量。",
  "psi.book.page.memoryManagement.1": "$(thing)CAD$(0)能够存储矢量的数量也叫做$(thing)内存槽位$(0)的数量。$(p)这章介绍两个$(thing)术式$(0)，它们可以保存以及读取$(thing)CAD$(0)$(thing)内存槽位$(0)中的矢量。$(p)$(piece)启动式：保存矢量$(0)保存一个矢量到指定的$(thing)内存槽位$(0)，反之，$(piece)选择符：读取矢量$(0)从$(thing)内存槽位$(0)中读取存储的矢量。",
  "psi.book.page.memoryManagement.2": "$(thing)CAD$(0)的$(thing)内存槽位$(0)从1开始计数，所以一个有着3个内存槽位的$(thing)CAD$(0)可以将数据保存到槽位1，2，3。$(p)这章当中的两个$(thing)启动式$(0)会根据它们所使用的槽位的序号增加$(thing)魔法式$(0)的$(l:basics/tutorial_5#potency)$(thing)强度$(0)$(/l)属性。$(p)例如，从槽位2中保存/读取数据将会增加2点$(l:basics/tutorial_5#potency)$(thing)强度$(0)$(/l)。",
  "psi.book.page.memoryManagement.3": "$(piece)启动式：保存矢量$(0)有个缺点：它会\"锁定\"它写入过数据的$(thing)内存槽位$(0)。$(p)这会阻止之后的术式与同一个$(thing)内存槽位$(0)进行交互。$(p)所以如果你想在写入数据之前读取槽位中的数据，你需要运用流程控制的规则来保证数据的读取发生在写入之前。",
  "psi.book.entry.secondaryOperators": "次级运算符",
  "psi.book.page.secondaryOperators.0": "顾名思义，这是一些相对没那么重要的数学$(thing)运算符$(0)，对比\"主要运算符\"而言（像是加或减）。本章运算符仅仅是各种数学或逻辑有关的混合，它们可以帮助你编写$(thing)术式$(0)。我们将这些运算符分为两部分来介绍。",
  "psi.book.page.secondaryOperators.1": "第一部分是与数的幂相关的，包括诸如$(piece)运算符：平方$(0)，$(piece)运算符：立方$(0)，$(piece)运算符：平方根$(0)以及$(piece)运算符：对数$(0)大部分的运算符所做的运算都和它的字面义相同$(p)请注意，$(piece)运算符：对数$(0)的底数是可选参数；如果没有指定底数，它默认以10为底。$(p)$(piece)常量：e$(0)可以用来获得一个自然对数。",
  "psi.book.page.secondaryOperators.2": "第二部分的$(thing)运算符$(0)与逻辑运算相关。包括进行取整运算的术式：$(p)$(piece)运算符：向上取整$(0)，$(piece)运算符：向下取整$(0)以及$(piece)运算符：四舍五入$(0)。$(p)还包括$(piece)运算符：最小值$(0)和$(piece)运算符：最大值$(0)。这些运算符分别返回参数中的最小值和最大值。"
}